<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyRover</title>
  <subtitle>做我的仲夏夜之梦～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://microndgt.github.io/"/>
  <updated>2017-01-28T15:41:06.000Z</updated>
  <id>http://microndgt.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python类与对象</title>
    <link href="http://microndgt.github.io/2017/01/28/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://microndgt.github.io/2017/01/28/Python类与对象/</id>
    <published>2017-01-28T09:01:05.000Z</published>
    <updated>2017-01-28T15:41:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。</p>
<h1 id="改变对象的字符串显示"><a href="#改变对象的字符串显示" class="headerlink" title="改变对象的字符串显示"></a>改变对象的字符串显示</h1><p>要改变一个实例的字符串表示，可以重新定义它的<code>__str__()</code>和<code>__repr__()</code>方法，今天彻底解决这两个的混乱，repr用于返回一个实例的代码表示形式，用于调试，交互式解释器显示的值是一样的。而str会将实例转换成一个字符串，使用<code>str()</code>或者<code>print()</code>函数会输出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Pair:</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line">    # &#123;!r&#125;和&#123;!s&#125;取得%r和%s的效果，也就是输出这个属性的时候也用%r或者%s</div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&apos;.format(self)</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&apos;.format(self)</div></pre></td></tr></table></figure>
<p>很有道理呀，自定义<code>__repr__()</code>和<code>__str__()</code>这样就可以分别在调试的时候和正式运行的时候有所差异</p>
<h1 id="自定义字符串的格式化"><a href="#自定义字符串的格式化" class="headerlink" title="自定义字符串的格式化"></a>自定义字符串的格式化</h1><p>format()函数和字符串方法使得一个对象能够支持自定义的格式化。需要在类上面定义<code>__format__()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_formats = &#123;</div><div class="line">  &apos;ymd&apos; : &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;,</div><div class="line">&#125;</div><div class="line">class Date:</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div><div class="line">    def __format__(self, code):</div><div class="line">        if code == &quot;&quot;:</div><div class="line">            code = &apos;ymd&apos;</div><div class="line">        fmt = _formats[code]</div><div class="line">        return fmt.format(d=self)</div><div class="line">d = Date(2012, 12, 21)</div><div class="line">format(d)</div><div class="line">format(d, &apos;ymd&apos;)</div></pre></td></tr></table></figure>
<p>就和之前自己写date的解析函数一样，自定义字符串格式功能。<code>__format__()</code>方法给Python的字符串格式化功能提供一个钩子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。&lt;/p&gt;
&lt;h1 id=&quot;改变对象的字符串显示&quot;&gt;&lt;a href=&quot;#改变对象的字符串显示&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python Guide</title>
    <link href="http://microndgt.github.io/2017/01/27/Python-guide/"/>
    <id>http://microndgt.github.io/2017/01/27/Python-guide/</id>
    <published>2017-01-27T03:18:47.000Z</published>
    <updated>2017-01-28T06:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><p><code>list, tuple, set</code></p>
<h2 id="fronzenset"><a href="#fronzenset" class="headerlink" title="fronzenset"></a>fronzenset</h2><p>元素一经创建，不可增加、删除和修改。</p>
<h2 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h2><p>记录了内容添加的顺序，以添加顺序为准<code>d1 = collections.OrderedDict()</code></p>
<h2 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h2><p>会自动为它的键赋一个初值，<code>frequencies = defaultdict(int)</code>，所以默认值是int类型的，如果<code>frequencies = defaultdict(list)</code>，键对应的值类型就默认是列表类型的</p>
<h2 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h2><p>高效实现插入和删除操作的双向列表，适合用于列表和栈，对的，是否可以用在项目上经常有<code>insert</code>的列表数据结构上？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</div><div class="line">q.append(&apos;x&apos;)</div><div class="line">q.appendleft(&apos;y&apos;)</div><div class="line"># 还支持pop()和popleft()</div></pre></td></tr></table></figure>
<h2 id="collections-namedtuple"><a href="#collections-namedtuple" class="headerlink" title="collections.namedtuple"></a>collections.namedtuple</h2><p>创建了一个自定义的tuple对象，并且规定了tuple元素的个数，并且可以用属性而不是索引来表示tuple中的某个元素，这样<code>namedtuple</code>定义的数据类型，具备tuple的不变性，又可以根据属性来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"># 名称，属性list</div><div class="line">Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])</div><div class="line">p = Point(1, 2)</div><div class="line">p.x</div><div class="line">p.y</div></pre></td></tr></table></figure>
<h2 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h2><p>简单的计数器，比如统计字符出现的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">a = &quot;programming&quot;</div><div class="line">c = Counter(a)</div><div class="line">c.most_common()</div></pre></td></tr></table></figure>
<blockquote>
<p>去刷leetcode！看看算法导论</p>
</blockquote>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>这块自己应该是最薄弱的地方吧，没有系统的概念，所以多看书，多学习吧。这里有两个资源：</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">从输入URL 到页面加载完成的过程中都发生了什么事情</a></p>
<p>图解Http</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>有三种类型的数据库，关系型数据库，文档型数据库(mongodb)，内存型数据库(Redis)</p>
<p>有时间去研究一下mongodb，强化学习一下Redis</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>这块虽然基本的自己在用，但是好多都没有实践，比如合并请求之类的命令，现在发现好多都需要学习。。。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add . #将什么添加到仓库</div><div class="line">git commit -m &quot;wrote a note&quot; # 将文件提交到仓库</div><div class="line">git status #掌握仓库当前状态</div><div class="line">git diff # 查看做了什么修改</div></pre></td></tr></table></figure>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git log # 查看历史记录，显示最近到最远的提交日志</div><div class="line">git log --pretty=oneline # 只输出一条必要信息</div><div class="line"># HEAD表示当前版本，HEAD^表示上一个版本,HEAD^^上上一个版本，HEAD^100表示往上100个版本</div><div class="line">git reset --hard HEAD^ # 表示回退到上一个版本</div><div class="line"># 可以使用新版本的commit id号再回去，输入前几位也可以</div><div class="line">git reset --hard 326234</div><div class="line"># 下面命令记录了git的每次命令</div><div class="line">git reflog</div></pre></td></tr></table></figure>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><code>git add</code>命令是把要提交的所有修改放到暂存区，<code>git commit</code>是把暂存区的所有修改提交到分支</p>
<p>每次修改，如果不add到暂存区，就不会加入到commit中</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，将文件在工作区的修改全部撤销，也就是将该文件回到最近一次<code>git commit</code>或者<code>git add</code>时的状态</p>
<p>如果不想要的内容已经<code>git add</code>到暂存区，但是没有提交，那么<code>git reset HEAD file</code>可以将暂存区的修改撤销掉，重新放回工作区，然后<code>git checkout -- file</code>丢弃工作区的修改</p>
<p>如果已经commit那么使用版本回退</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除之后，工作区和版本库就不一致，这时候如果确实要在版本库中删除文件，那么使用<code>git rm file</code>并且<code>git commit</code></p>
<p>如果删除错了，那么从版本库中将文件恢复<code>git checkout -- file</code>，<code>git checkout</code>其实是用版本库的版本替换工作区的版本</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>一台电脑充当服务器的角色，其他每个人都是从服务器仓库中克隆一份到自己电脑上，并且各自把自己的提交推送到服务器仓库中，也从服务器仓库中拉取别人的提交。所以完全可以自己搭建一台运行Git的服务器。</p>
<p>git支持多种协议，https，但是通过ssh支持的原生的git协议速度最快，有必要，每次都输密码真是烦。在<code>hexo</code>配置文件中<code>_config.yml</code>设置<code>deploy</code>属性，<code>repo</code>为<code>git@github.com:Microndgt/microndgt.github.io.git</code>即可。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>HEAD</code>指向的是<code>master</code>，<code>master</code>指向提交，所以<code>HEAD</code>指向的就是当前分支</p>
<p>创建一个分支后，增加了一个<code>dev</code>指针，指向与<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上，新提交一次，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变，合并的时候把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并，删除<code>dev</code>分支是把<code>dev</code>指针给删掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># -b创建并且切换</div><div class="line">git checkout -b dev</div><div class="line"># 相当于以下</div><div class="line">git branch dev</div><div class="line">git checkout dev</div><div class="line"># 查看分支</div><div class="line">git branch</div><div class="line"># 切换分支</div><div class="line">git checkout master</div><div class="line"># 合并分支,合并指定分支到当前分支</div><div class="line">git merge dev</div><div class="line"># 合并完成后，删除dev分支</div><div class="line">git branch -d dev</div></pre></td></tr></table></figure>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>就是自己之前考虑的情况，这种情况如果是两个分支修改的文件各不相同就可以自动merge，没有冲突，但是如果修改了一个文件的话，就会产生冲突，就不能快速合并，必须解决冲突之后才能合并，可以使用<code>git status</code>来查看冲突文件，解决冲突之后<code>git merge feature1</code>，然后删除<code>feature1</code>分支,<code>git branch -d feature1</code></p>
<h2 id="非快速合并分支"><a href="#非快速合并分支" class="headerlink" title="非快速合并分支"></a>非快速合并分支</h2><p>通常分支合并会使用<code>Fast forward</code>，这种模式下，删除分支后，会丢掉分支信息，强制禁用<code>Fast forward</code>，就会在<code>merge</code>生成一个新的commit，这样在分支历史上就可以看出分支信息。</p>
<p>合并的时候指定<code>--no-ff</code>参数<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p>
<h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>一般是<code>master</code>分支非常稳定，仅用来发布新版本，平时在<code>dev</code>分支干活，如果1.0版本发布的时候，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本</p>
<p>然后团队每个人在<code>dev</code>分支上干活，每个人都有自己的分支，时不时往<code>dev</code>分支上合并即可。</p>
<p>我打算是<code>master</code>作为主分支，然后建立一个<code>dev</code>分支，我在这个上面干活，然后其他人就建立自己的分支，然后我来从<code>dev</code>分支合并他们的分支，然后每次稳定版本发布再合并到<code>master</code></p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>每添加一个新功能的时候，最好新建一个feature分支，在上面开发，如果完成，合并，最后删除该feature分支，如果新功能要取消，就可以销毁掉这个分支<code>git branch -D feature-vulcan</code></p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>git中，分支完全可以自己本地搞，推送的时候推送合并后的主分支好了。所以开发的时候，现在可以创建一个新分支，然后开发，最后合并删除即可，再推送。</p>
<p>如果别人clone，默认只能看到<code>master</code>分支，那么要用其他分支，必须创建远程<code>origin</code>的<code>dev</code>分支到本地，<code>git checkout -b dev origin/dev</code>，如果别人更新了仓库，那么可以<code>git pull</code>然后再本地合并，解决冲突，再推送，但是必须指定本地分支与远程分支进行链接<code>git branch --set-upstream dev origin/dev</code></p>
<p>查看远程库信息<code>git remote -v</code></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>git tag -a v0.1 -m &quot;version 0.1 released&quot;</code></p>
<h1 id="专业素养"><a href="#专业素养" class="headerlink" title="专业素养"></a>专业素养</h1><p>不仅需要写程序，还要写文档，写注释，单元测试，这里自己还欠缺的能力是单元测试，有时间去研究学习一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法与数据结构&quot;&gt;&lt;a href=&quot;#算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构&quot;&gt;&lt;/a&gt;算法与数据结构&lt;/h1&gt;&lt;p&gt;&lt;code&gt;list, tuple, set&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;fronzens
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="http://microndgt.github.io/2017/01/23/Python%E5%87%BD%E6%95%B0/"/>
    <id>http://microndgt.github.io/2017/01/23/Python函数/</id>
    <published>2017-01-23T06:34:34.000Z</published>
    <updated>2017-01-27T05:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认参数，任意数量参数，强制关键字参数，注解和闭包。</p>
<h1 id="可接受任意数量参数的函数"><a href="#可接受任意数量参数的函数" class="headerlink" title="可接受任意数量参数的函数"></a>可接受任意数量参数的函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def avg(first, *rest):</div><div class="line">    # 传入相当于一个序列</div><div class="line">    return (first + sum(rest)) / (1 + len(rest))</div></pre></td></tr></table></figure>
<p>任意数量的关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def make_element(name, value, **attrs):</div><div class="line">    keyvals = [&apos; %s = &quot;%s&quot; &apos; % item for item in attrs.items()]</div></pre></td></tr></table></figure>
<p>任意数量的位置参数和关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def anyargs(*args, **kwargs):</div><div class="line">    print(args)</div><div class="line">    print(kwargs)</div></pre></td></tr></table></figure>
<h1 id="强制关键字参数"><a href="#强制关键字参数" class="headerlink" title="强制关键字参数"></a>强制关键字参数</h1><p>将强制关键字参数放到某个<em>参数，或者单个</em>后面就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def recv(maxsize, *, block):</div><div class="line">    pass</div><div class="line">recv(1024, block=True)</div><div class="line">def mininum(*values, clip=None):</div><div class="line">    pass</div><div class="line">mininum(1, 5, 2, clip=0)</div></pre></td></tr></table></figure>
<p>使用强制关键字参数可以使得对调用者友好，并且也比<code>**kwargs</code>友好，因为help输出的时候更容易理解</p>
<h1 id="给函数参数增加元信息"><a href="#给函数参数增加元信息" class="headerlink" title="给函数参数增加元信息"></a>给函数参数增加元信息</h1><p>增加额外信息，这样使用者就知道函数应该怎样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add(x:int, y:int) -&gt; int:</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>并不会类型检查，一般加上简单的注解，通常使用类或者字符串会更好</p>
<h1 id="定义有默认参数的函数"><a href="#定义有默认参数的函数" class="headerlink" title="定义有默认参数的函数"></a>定义有默认参数的函数</h1><p>定义一个有可选参数的函数直接在函数定义中给参数指定一个默认值，并且放到参数列表最后就可以了。</p>
<p>如果默认参数是一个可以修改的容器比如列表，使用None作为默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def spam(a, b=None):</div><div class="line">    if b is None:</div><div class="line">        b = []</div></pre></td></tr></table></figure>
<p>默认值仅仅在函数定义的时候赋值一次，默认参数的值应该是不可变的对象，并且在测试None值的时候使用is操作符。<code>if a is None:</code></p>
<h1 id="匿名函数捕获变量值"><a href="#匿名函数捕获变量值" class="headerlink" title="匿名函数捕获变量值"></a>匿名函数捕获变量值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10</div><div class="line">a = lambda y: x + y</div><div class="line">x = 20</div><div class="line">b = lambda y: x + y</div></pre></td></tr></table></figure>
<p><code>a(10)</code>和<code>b(10)</code>的结果都是30，因为lambda表达式中x是一个自由变量，在运行的时候绑定值，也就是说，在调用lambda表达式的时候，x的值是执行时的值，和函数的默认参数定义是不一样的。</p>
<p>如果想让某个匿名函数在定义的时候捕获到值，可以将那个参数值定义成默认参数</p>
<p><code>a = lambda y, x=x: x + y</code></p>
<h1 id="减少可调用对象的参数个数"><a href="#减少可调用对象的参数个数" class="headerlink" title="减少可调用对象的参数个数"></a>减少可调用对象的参数个数</h1><p>有一个被其他python代码使用的callable对象，可能是一个回调函数或者是一个处理器，但是参数过多的时候，可能导致调用出错。对这就是为什么我的多进程调用没有作用，可能这个是一方面原因，另外一方面原因就是传入的是可变对象。</p>
<p>使用<code>functools.partial()</code>允许给一个或者多个参数设置固定的值，减少接下来被调用时候的参数个数。</p>
<p>一个例子，partial用来微调其他库函数所使用的回调函数的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def output_result(result, log=None):</div><div class="line">    if log is not None:</div><div class="line">        log.debug(&apos;Got: %r&apos;, result)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import logging</div><div class="line">    from multiprocessing import Pool</div><div class="line">    from functools import partial</div><div class="line">    logging.basicConfig(level=logging.DEBUG)</div><div class="line">    log = logging.getLogger(&apos;test&apos;)</div><div class="line">    p = Pool()</div><div class="line">    p.apply_async(add, (3, 4), callback=partial(outoutput_result, log=log))</div><div class="line">    p.close()</div><div class="line">    p.join()</div></pre></td></tr></table></figure>
<h1 id="将单方法的类转换成函数"><a href="#将单方法的类转换成函数" class="headerlink" title="将单方法的类转换成函数"></a>将单方法的类转换成函数</h1><p>可以使用闭包将单个方法的类转换成函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from urllib.request import urlopen</div><div class="line">class UrlTemplate:</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">    def open(self, **kwargs):</div><div class="line">        return urlopen(self.template.format_map(kwargs))</div></pre></td></tr></table></figure>
<p>可以使用闭包来代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def urltemplate(template):</div><div class="line">    def opener(**kwargs):</div><div class="line">        return urlopen(template.format_map(kwargs))</div><div class="line">    return opener</div></pre></td></tr></table></figure>
<p>经典啊！使用单方法类的原因是需要存储某些额外的状态来给方法使用，但是使用内部函数或者闭包更优雅，一个闭包就是一个函数，只不过在函数内部带上了一个额外的变量环境。闭包关键特点是它会记住自己被定义时的环境。</p>
<p>任何时候遇到需要给某个函数增加额外的状态信息的问题，都可以考虑使用闭包。</p>
<h1 id="带额外状态信息的回调函数"><a href="#带额外状态信息的回调函数" class="headerlink" title="带额外状态信息的回调函数"></a>带额外状态信息的回调函数</h1><p>代码需要依赖到回调函数的使用，并且需要让回调函数拥有额外的状态值，以便在它的内部使用。</p>
<p>回调函数的使用，仅仅接受一个参数，不能再传入其他信息。</p>
<p>为了让回调函数访问外部信息，一种方法是使用绑定方法来代替一个简单函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ResultHandler:</div><div class="line">    def __init__(self):</div><div class="line">        self.sequence = 0</div><div class="line">    def handler(self, result):</div><div class="line">        self.sequence += 1</div><div class="line">        print(self.sequence, result)</div></pre></td></tr></table></figure>
<p>先创建实例，然后使用它的handler()绑定方法作为回调函数</p>
<p><code>apply_async(add, (2, 3), callback=r.handler)</code></p>
<p>可以使用闭包捕获状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    def handler(result):</div><div class="line">        nonlocal sequence</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div><div class="line">    return handler</div></pre></td></tr></table></figure>
<p>使用协程来储存状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    while True:</div><div class="line">        result = yield</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div></pre></td></tr></table></figure>
<p>使用send方法作为回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handler=make_handler()</div><div class="line">next(handler) ＃必须的，走到yield</div><div class="line">apply_async(add, (2, 3), callback=handler.send)</div></pre></td></tr></table></figure>
<h1 id="访问闭包中定义的变量"><a href="#访问闭包中定义的变量" class="headerlink" title="访问闭包中定义的变量"></a>访问闭包中定义的变量</h1><p>扩展函数中的某个闭包，允许其能访问和修改函数的内部变量，通过编写访问函数并将其作为函数属性绑定到闭包上实现这个目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def sample():</div><div class="line">    n = 0</div><div class="line">    def func():</div><div class="line">        print(&apos;n=&apos;, n)</div><div class="line">    def get_n():</div><div class="line">        return n</div><div class="line">    def set_n(value):</div><div class="line">        nonlocal n</div><div class="line">        n = value</div><div class="line">    fuuc.get_n = get_n</div><div class="line">    func.set_n = set_n</div><div class="line">    return func</div><div class="line">f = sample()</div><div class="line">f()</div><div class="line">f.set_n(10)</div><div class="line">f.get_n()</div></pre></td></tr></table></figure>
<p>函数属性可以使用简单的方式将访问方法绑定到闭包函数上。</p>
<h1 id="内联回调函数"><a href="#内联回调函数" class="headerlink" title="内联回调函数"></a>内联回调函数</h1><p>回调函数可能会找不清楚程序控制流，所以使用内联回调函数可以看起来像一个普通的执行序列。</p>
<p>使用生成器和协程可以使得回调函数内联在某个函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from functools import wraps</div><div class="line"># 使用functools.wraps可以保证装饰器不会对被装饰函数造成影响，原函数返回内部函数，这样原函数的名字变成了内部函数，所以把原函数的名字等属性复制到内部函数中，这样的话依赖函数签名的代码就不会执行出错。</div><div class="line">class Async:</div><div class="line">    def __init__(self, func, args):</div><div class="line">        self.func = func</div><div class="line">        self.args = args</div><div class="line">def inlined_async(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args):</div><div class="line">        # 这里相当于初始化生成器</div><div class="line">        f = func(*args)</div><div class="line">        result_queue = Queue()</div><div class="line">        result_queue.put(None)</div><div class="line">        while True:</div><div class="line">            result = result_queue.get()</div><div class="line">            try:</div><div class="line">                # 第一次发送None，作为必须的next，走到yield,下次来就会把计算结果发送过去，作为r，然后print，然后走向下一个yield</div><div class="line">                a = f.send(result)</div><div class="line">                # 返回a是Async对象，也就是yield之后的对象</div><div class="line">                apply_async(a.func, a.args, callback=result_queue.put)</div><div class="line">            except StopIteration:</div><div class="line">                break</div><div class="line">    return wrapper</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">@inlined_async</div><div class="line">def test():</div><div class="line">    r = yield Async(add, (2, 3))</div><div class="line">    print(r)</div><div class="line">    r = yield Async(add, (&apos;hello&apos;, &apos;world&apos;))</div><div class="line">    print(r)</div><div class="line">    for n in range(10):</div><div class="line">        r = yield Async(add, (n, n))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认参数，任意数量参数，强制关键字参数，注解和闭包。&lt;/p&gt;
&lt;h1 id=&quot;可接受任意数量参数的函数&quot;&gt;&lt;a href=&quot;#可接受任意数量参数的函数&quot; class=&quot;headerlink&quot; title=&quot;可接受任意数量参数的函数&quot;&gt;&lt;/a&gt;可接受任意数量参数的函数&lt;/h1
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>使用Python和Flask设计RESTful API</title>
    <link href="http://microndgt.github.io/2017/01/22/%E4%BD%BF%E7%94%A8Python%E5%92%8CFlask%E8%AE%BE%E8%AE%A1RESTful-API/"/>
    <id>http://microndgt.github.io/2017/01/22/使用Python和Flask设计RESTful-API/</id>
    <published>2017-01-22T03:25:20.000Z</published>
    <updated>2017-01-26T03:56:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST-REpresentational-State-Transfer表现层状态迁移"><a href="#REST-REpresentational-State-Transfer表现层状态迁移" class="headerlink" title="REST(REpresentational State Transfer表现层状态迁移)"></a>REST(REpresentational State Transfer表现层状态迁移)</h1><p>web services和web APIs</p>
<ul>
<li>客户端－服务器，两者隔离</li>
<li>无状态，一种服务器不会存储客户端上一次请求的信息用来下一次使用</li>
<li>可缓存，服务器明示客户端请求能否缓存</li>
<li>分层系统，客户端和服务器通信应该以一种标准方式，中间层代替服务器做出相应，客户端不需要做任何变动</li>
<li>统一接口，通信方法必须是统一的</li>
<li>按需编码：服务器可以提供可执行代码的脚本，为客户端在它们的环境中执行</li>
</ul>
<h1 id="RESTful-的-web-service"><a href="#RESTful-的-web-service" class="headerlink" title="RESTful 的 web service"></a>RESTful 的 web service</h1><p>核心是资源，资源可以用URI表示，客户端使用HTTP协议定义的方法来发送请求到这些URIs，当然可能会导致这些被访问的资源状态改变</p>
<p><code>GET,POST,PUT,DELETE</code></p>
<p>REST设计不需要特定的数据格式，在请求中数据可以以JSON形式，或者作为url中查询参数项。</p>
<h1 id="设计一个web-service"><a href="#设计一个web-service" class="headerlink" title="设计一个web service"></a>设计一个web service</h1><p>其实就是一个标识资源被展示出来以及它们是怎样受不同的请求方法影响。</p>
<p>首先设计URL: <code>http://[hostname]/todo/api/v1.0</code>，在URL中包含应用名称有助于提供一个命名空间以便区分同一系统上的其他服务，包含版本号能够帮助以后的更新，如果新版本中存在新的和潜在不兼容的功能，可以不影响依赖于旧的功能的应用程序。</p>
<p>现在从前端过来的也就是指令信息，然后发送给服务器，计算之后返回数据信息，主要在于要将这些数据格式化成json格式，把指令从json变成python可用的。</p>
<p>有这么几项，一个是登陆，密码验证之类。另外一个是开始计算，返回数据，已完成百分比，耗费时间。另外一个是返回summary数据，输入id的话返回对应的ability或者其他数据，这块也就是数据查询功能，看查询类型了</p>
<p>擦，在虚拟环境指定Python3也是不容易啊，<code>virtualenv backend -p /usr/local/bin/python3</code>使用用户安装的python3，貌似anaconda的Python3用不了</p>
<h1 id="使用Python和Flask实现RESTful-services"><a href="#使用Python和Flask实现RESTful-services" class="headerlink" title="使用Python和Flask实现RESTful services"></a>使用Python和Flask实现RESTful services</h1><p>使用ssdb数据库</p>
<p>最后使用了<code>flask-restful</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST-REpresentational-State-Transfer表现层状态迁移&quot;&gt;&lt;a href=&quot;#REST-REpresentational-State-Transfer表现层状态迁移&quot; class=&quot;headerlink&quot; title=&quot;REST(R
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数字日期和时间</title>
    <link href="http://microndgt.github.io/2017/01/20/Python%E6%95%B0%E5%AD%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/"/>
    <id>http://microndgt.github.io/2017/01/20/Python数字日期和时间/</id>
    <published>2017-01-20T03:20:22.000Z</published>
    <updated>2017-01-27T05:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。</p>
<h1 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h1><p><code>round(value, ndigits)</code>比如<code>round(1.231, 1)</code>为1.2，如果在中间的话，返回离它最近的偶数，1.5和2.5都会返回2，并且ndigits可以是负数，这样舍入运算作用在十位，百位和千位上。</p>
<p>如果不允许小误差，那么使用decimal模块。</p>
<h1 id="精确的浮点数运算"><a href="#精确的浮点数运算" class="headerlink" title="精确的浮点数运算"></a>精确的浮点数运算</h1><p>精确但是有性能损失，使用decimal模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from decimal import Decimal</div><div class="line">a = Decimal(&apos;4.2&apos;)</div><div class="line">b = Decimal(&apos;2.1&apos;)</div><div class="line">print(a + b) # 6.3</div></pre></td></tr></table></figure>
<p>decimal可以允许你控制计算的数字位数和四舍五入运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 创建本地上下文并且更改它的设置</div><div class="line">with localcontext() as ctx:</div><div class="line">    ctx.prec = 3 # 位数</div><div class="line">print(a / b)</div></pre></td></tr></table></figure>
<p>之前遇到的情况是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nums = [1.23e+18, 1, -1.23e+18]</div><div class="line">sum(nums)</div><div class="line"># 可以使用math.fsum()提供的更精确计算能力来解决</div><div class="line">import math</div><div class="line">math.fsum(nums)</div></pre></td></tr></table></figure>
<p>处理金融数据的时候会用到decimal模块</p>
<h1 id="数字的格式化输出"><a href="#数字的格式化输出" class="headerlink" title="数字的格式化输出"></a>数字的格式化输出</h1><p>控制数字位数，对齐，千位分隔符和其他细节</p>
<p>格式化输出单个数字的时候，可以使用内置的format()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = 1234.56789</div><div class="line">format(x, &apos;0.2f&apos;)</div><div class="line">format(x, &apos;&gt;10.1f&apos;) # 右对齐宽度10</div><div class="line">format(x, &apos;~10.1f&apos;) # 居中</div><div class="line">format(x, &apos;,&apos;) # 千位符</div></pre></td></tr></table></figure>
<p>指定宽度和精度的一般形式是<code>&#39;[&lt;&gt;^]?width[,]?(.digits)?&#39;</code>，同样的格式也用在字符串的format()方法中</p>
<p><code>the value is {:0,.2f}.format(x)</code></p>
<p>格式化值会根据指定数字的位数，和round函数采用同样的规则</p>
<h1 id="二八十六进制整数"><a href="#二八十六进制整数" class="headerlink" title="二八十六进制整数"></a>二八十六进制整数</h1><p><code>bin(x)</code>和<code>oct(x)</code>和<code>hex(x)</code>，如果不想显示前缀的话，使用format函数，<code>format(x, &#39;b&#39;)</code> 和 <code>format(x, &#39;o&#39;)</code>和<code>format(x, &#39;x&#39;)</code></p>
<p>将不同进制转换整数字符串，使用带有进制的int()函数<code>int(&#39;4d2&#39;, 16)</code>或者<code>int(&#39;0010&#39;, 2)</code>表示16进制，2进制</p>
<h1 id="无穷大和NaN"><a href="#无穷大和NaN" class="headerlink" title="无穷大和NaN"></a>无穷大和NaN</h1><p>使用<code>float()</code>来创建它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = float(&apos;inf&apos;)</div><div class="line">b = float(&apos;-inf&apos;)</div><div class="line">c = float(&apos;nan&apos;)</div></pre></td></tr></table></figure>
<p>使用<code>math.isinf()</code>和<code>math.isnan()</code>函数来测试值是否存在,也可以使用<code>numpy.isinf()</code>或者<code>numpy.isnan()</code></p>
<p>NaN值会在所有操作中传播，而不会产生异常</p>
<h1 id="分数运算"><a href="#分数运算" class="headerlink" title="分数运算"></a>分数运算</h1><p>fractions模块可以用来执行包含分数的数学运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from fractions import Fraction</div><div class="line">a = Fraction(5, 4)</div><div class="line">b = Fraction(7, 16)</div><div class="line">print(a + b)</div><div class="line">float(a + b)</div></pre></td></tr></table></figure>
<h1 id="大型数组运算"><a href="#大型数组运算" class="headerlink" title="大型数组运算"></a>大型数组运算</h1><p>使用NumPy库，提供一个数组对象，更适合用来进行数学运算，底层实现中，NumPy数组使用了C或者Fortran语言的机制分配内存，它们是一个非常大的连续的并且由同类型数据组成的内存区域。<code>import numpy as np</code></p>
<p>同时NumPy库有矩阵对象来进行线性代数运算</p>
<h1 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h1><p>从一个序列中随机抽选一个元素，使用<code>random.choice()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import random</div><div class="line">values = [1, 2, 3, 4, 5, 6]</div><div class="line">random.choice(values)</div></pre></td></tr></table></figure>
<p>提取N个不同元素的样本来作进一步操作，<code>random.sample(values, 2)</code></p>
<p>打乱序列中元素顺序，<code>random.shuffle(values)</code>，原地修改顺序</p>
<p>生成随机整数，<code>random.randint(0, 10)</code> 包括0和10</p>
<p>生成0到1范围内均匀分布的浮点书，使用<code>random.random()</code></p>
<p>通过<code>random.seed()</code>函数修改初始化种子，<code>random.seed(12345)</code></p>
<h1 id="基本的日期与时间转换"><a href="#基本的日期与时间转换" class="headerlink" title="基本的日期与时间转换"></a>基本的日期与时间转换</h1><p>使用datetime模块，表示一个时间段，创建一个timedelta实例，<code>a = timedelta(days=2)</code></p>
<p>创建一个datetime实例<code>a = datetime(2012, 9, 23)</code></p>
<p><code>now = datetime.today()</code>，并且datetime会自动处理闰年</p>
<p>使用<code>dateutil</code>模块处理时区，模糊时间范围，节假日计算，使用<code>dateutil.relativedelta</code>来计算间距日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">a = datetime(2017, 1, 21)</div><div class="line">a + relativedelta(years=-1)</div></pre></td></tr></table></figure>
<h1 id="最后一个周五的日期"><a href="#最后一个周五的日期" class="headerlink" title="最后一个周五的日期"></a>最后一个周五的日期</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime, timedelta</div><div class="line">weekdays = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;,</div><div class="line">            &apos;Friday&apos;, &apos;Saturday&apos;, &apos;Sunday&apos;]</div><div class="line">def get_previous_byday(dayname, start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        start_date = datetime.today()</div><div class="line">    day_num = start_date.weekday() # 返回序号，周一是第一个0</div><div class="line">    day_num_target = weekdays.index(dayname)</div><div class="line">    # 这里因为有两种情况，一种是现在日期序号大于或者等于target的，这样直接减就好，比如周三2减去周二1等于1，说明上一个周二离现在1天</div><div class="line">    ＃ 另外一种情况是日期序号小于的，这样直接减就是负的，并且肯定是上一个星期的，但是不足7天，所以7加上这个差</div><div class="line">    days_ago = (7 + day_num - day_num_target) % 7</div><div class="line">    if days_ago == 0:</div><div class="line">        days_ago = 7</div><div class="line">    target_date = start_date - timedelta(days=days_ago)</div><div class="line">    return target_date</div></pre></td></tr></table></figure>
<p>可以使用dateutil模块中的relativedelta()函数执行同样的计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">d = datetime.now()</div><div class="line">print(d + relativedelta(weekday=FR))</div><div class="line">print(d + relativedelta(weekday=FR(-1)))</div></pre></td></tr></table></figure>
<h1 id="计算当前月份的日期范围"><a href="#计算当前月份的日期范围" class="headerlink" title="计算当前月份的日期范围"></a>计算当前月份的日期范围</h1><p><code>calendar.monthrange(year, month)</code>返回该月第一天的weekday和这个月的天数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def get_month_range(start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        # 计算出对应月份第一天的日期</div><div class="line">        start_date = date.today().replace(day=1)</div><div class="line">    _, days_in_month = calendar.monthrange(start_date.year, start_date.month)</div><div class="line">    end_date = start_date + timedelta(days=days_in_month)</div><div class="line">    return (start_date, end_date)</div><div class="line">a_day = timedelta(days=1)</div><div class="line">first_day, last_day = get_month_range()</div><div class="line"># 结束日期不包含在日期范围内</div><div class="line">while first_day &lt; last_day:</div><div class="line">    print(first_day)</div><div class="line">    first_day += a_day</div><div class="line"># 或者定义一个生成器</div><div class="line">def date_range(start, stop, step):</div><div class="line">    while start &lt; stop:</div><div class="line">        yield start</div><div class="line">        start += step</div></pre></td></tr></table></figure>
<h1 id="字符串转换为日期"><a href="#字符串转换为日期" class="headerlink" title="字符串转换为日期"></a>字符串转换为日期</h1><p>使用<code>datetime.strptime()</code>方法的性能还是很低的，所以如果知道了日期字符串的确切形式，可以自己实现解析方案来获取更好的性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line">def parse_ymd(s):</div><div class="line">    year_s, mon_s, day_s = s.split(&apos;-&apos;)</div><div class="line">    return datetime(int(year_s), int(mon_s), int(day_s))</div></pre></td></tr></table></figure>
<p>速度比<code>datetime.strptime()</code>快7倍多，6666，把capacity项目的都改过来了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。&lt;/p&gt;
&lt;h1 id=&quot;数字的四舍五入&quot;&gt;&lt;a href=&quot;#数字的四舍五入&quot; class=&quot;headerlink&quot; title=&quot;数字的四舍五入&quot;&gt;&lt;/
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发可规模化的应用</title>
    <link href="http://microndgt.github.io/2017/01/20/%E7%94%A8Python%E5%BC%80%E5%8F%91%E5%8F%AF%E8%A7%84%E6%A8%A1%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://microndgt.github.io/2017/01/20/用Python开发可规模化的应用/</id>
    <published>2017-01-20T00:47:38.000Z</published>
    <updated>2017-01-27T05:22:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Developing Scalable Apps in Python!</p>
<h1 id="Scalability-Basics"><a href="#Scalability-Basics" class="headerlink" title="Scalability Basics"></a>Scalability Basics</h1><p>在Google基础结构上运行的应用，缩放，scale，可缩放应用</p>
<p>the race for scalability 可伸缩性争用</p>
<p>optimize software, change software to run on more servers -&gt; scalable architecture</p>
<h2 id="从在单个计算机运行解耦"><a href="#从在单个计算机运行解耦" class="headerlink" title="从在单个计算机运行解耦"></a>从在单个计算机运行解耦</h2><p>将向外扩展架构设计为将应用扩展到单一计算机范围之外，因此还需要扩展此分布式架构(distributed architecture)， 而不是共享架构(share architecture)，有道理，不能用共享的，这样扩展的时候共享资源就会称为瓶颈，分布式应用最好也不要有共享的数据，这样会导致通信，处理起来比较麻烦。虚拟机(virtual machine)</p>
<p>key step to building a scalable system is your need to decouple it from executing on a single computer. You design a scale out architecture as your application scales outside the scope of a single computer and this distributed architecture needs to be socalled, share nothing architecture. Meaning, that it must not depend on any shared resources that can become the bottleneck, this way if your application needs a scale, you can just provide more computer to provide the additional capacity required. That means, you can run your application on. All the things. And to get even more flexibility the concept of virtual machines was born which enables you to decouple a physical machine from the application execution machine. This had great flexibility gain since the infrastructure turned virtual you would now run your scale out application on several virtual machines instead of physical computers. You can now scale indefinitely by adding these standard building blocks of performance that your application can utilize and you have decomposed(分解) your application from the specific execution machine. So how do you design your application to be able to scale like this?</p>
<h2 id="Use-distributed-architecture-to-solve-problems"><a href="#Use-distributed-architecture-to-solve-problems" class="headerlink" title="Use distributed architecture to solve problems"></a>Use distributed architecture to solve problems</h2><p>plain virtual machines</p>
<p>First of all, virtual machines are nowadays a standard offering by any cloud service provider. This called IaaS, or infrastructure(基础设施) as a Service. This is because a computer and therefore also a virtual machine can be considered infrastructure today.And achieve unlimited scalability by distributing the execution(分布式计算) of our application, across these virtual machines.</p>
<p>creating this architecture for your application is a very complicated and resource intensive problem(资源密集型问题).</p>
<ul>
<li>VM Management. Starting and stopping the virtual machine.</li>
<li>Software Management</li>
<li>Web Server. Powerful</li>
<li>Distributed Database where you can read and write data, from all of your virtual machines.</li>
<li>A distributed file system, where you can read and write data which is accessible from all your virtual machines.</li>
<li>Application monitoring, with a consolidated view(统一视图) of any problems occurring in your distributed execution environment.</li>
<li>Availability including data replication, hardware software resilience(恢复力), geographic disaster recovery strategies. Back ups, recovery, automatic fail overs, et cetera.</li>
<li>Security set up and management(安全设置和管理) in your distributed execution environment</li>
<li>load balancing. How to spread the load across the VMs, including application level session management(应用级会话管理分布负载).</li>
</ul>
<h2 id="Google-App-Engine"><a href="#Google-App-Engine" class="headerlink" title="Google App Engine"></a>Google App Engine</h2><p>App Engine is a development and deployment platform that takes care of many things for your application.</p>
<p>internet services, server side applications.</p>
<h2 id="really-check"><a href="#really-check" class="headerlink" title="really check"></a>really check</h2><p>since App Engine provides services to control the execution environment, it also has to set up programming languages it supports. Python, Java, PHP, and GO. And since App Engine is an execution container, it also means that there are specific versions of these languages that are supported.</p>
<p><strong><em>it’s important to remember there are trade-offs with any framework or platform you use.</em></strong></p>
<p>outro(结尾)</p>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><p>app engine development cycle and create an app engine project where you can upload your code</p>
<p>cloud endpoints that allows you to create a backend that can work with any frontend device technology</p>
<p>a development environment where you develop code for app engine</p>
<p>conference central</p>
<p>不能连接Google是硬伤啊。。。算了，先到这里了，至少了解了scalable application</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Developing Scalable Apps in Python!&lt;/p&gt;
&lt;h1 id=&quot;Scalability-Basics&quot;&gt;&lt;a href=&quot;#Scalability-Basics&quot; class=&quot;headerlink&quot; title=&quot;Scalability B
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Udacity" scheme="http://microndgt.github.io/tags/Udacity/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hive学习</title>
    <link href="http://microndgt.github.io/2017/01/19/Hive%E5%AD%A6%E4%B9%A0/"/>
    <id>http://microndgt.github.io/2017/01/19/Hive学习/</id>
    <published>2017-01-19T07:26:16.000Z</published>
    <updated>2017-01-27T05:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据之Hive的数据操作以及开发</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Hive是基于Hadoop的一个数据仓库工具，通过它可以实现将结构化的数据文件映射为一张数据库表，并且提供简单的sql查询功能，同时将sql语句转换为MapReduce任务进行运行</p>
<p>Hive是构建在hadoop HDFS上的一个数据仓库</p>
<h2 id="数据仓库简介"><a href="#数据仓库简介" class="headerlink" title="数据仓库简介"></a>数据仓库简介</h2><p>有别于普通的数据库，数据仓库是一个面向主题的，集成的，不可更新的，随时间不变化的数据集合，它用于支持企业或组织的决策分析处理</p>
<p>面向主题：用户关注的具体方面</p>
<p>集成的：来自分散性的数据，进行加工和处理后进入数据仓库</p>
<p>不可更新：主要用于决策分析，主要涉及操作，数据查询</p>
<h2 id="数据仓库的结构和建立过程"><a href="#数据仓库的结构和建立过程" class="headerlink" title="数据仓库的结构和建立过程"></a>数据仓库的结构和建立过程</h2><p>数据源：业务数据系统，文档资料，其他数据</p>
<p>数据存储及管理：抽取，转换，装载，Extract,Transform,load，满足格式的数据</p>
<p>数据仓库引擎：为数据查询等提供服务</p>
<p>前端展示：数据查询，数据报表，数据分析，各类应用</p>
<h2 id="OLTP应用和OLAP应用"><a href="#OLTP应用和OLAP应用" class="headerlink" title="OLTP应用和OLAP应用"></a>OLTP应用和OLAP应用</h2><p>OLTP:连接事务处理，面对事务，操作频率高，银行转账</p>
<p>OLAP:连接分析处理，Online analysis process, 商品推荐系统,面对的是查询操作</p>
<h2 id="数据仓库中的数据模型"><a href="#数据仓库中的数据模型" class="headerlink" title="数据仓库中的数据模型"></a>数据仓库中的数据模型</h2><p>面向主题的模型</p>
<p>星形模型：商品信息-&gt;客户信息，订单信息，促销信息，生产信息，物流信息</p>
<p>雪花模型：客户也可以分很多信息，家庭信息，地址信息，教育背景信息，财务信息</p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>Hive是构建在hadoop HDFS上的一个数据仓库基础架构</p>
<p>可以用来进行数据提取转化加载ETL</p>
<p>定义了简单的类似SQL查询语言，称为HQL它允许熟悉SQL的用户查询数据</p>
<p>允许MapReduce开发者的开发自定义的mapper和reducer来处理内建的mapper和reducer无法完成的复杂分析工作</p>
<p>Hive是SQL解析引擎，将SQL语句转移成M/R job然后在hadoop执行</p>
<p>Hive的表其实是HDFS的目录/文件</p>
<h1 id="Hive的体系结构"><a href="#Hive的体系结构" class="headerlink" title="Hive的体系结构"></a>Hive的体系结构</h1><h2 id="Hive的元数据"><a href="#Hive的元数据" class="headerlink" title="Hive的元数据"></a>Hive的元数据</h2><p>将元数据存储在数据库中(metastore)，支持mysql，derby等数据库，默认是derby数据库。</p>
<p>元数据包括表的名字，表的列和分区及其属性，表的属性是否为外部表，表的数据所在目录</p>
<h2 id="HQL的执行过程"><a href="#HQL的执行过程" class="headerlink" title="HQL的执行过程"></a>HQL的执行过程</h2><p>解释器，编译器和优化器完成HQL查询语句从词法分析，语法分析，编译，优化以及查询计划的生成，生成的查询计划存储在HDFS中，并在随后由MapReduce调用执行</p>
<p>select-&gt;解析器，词法分析-&gt;编译器，生成HQL的执行计划-&gt;优化器，生成最佳的执行计划-&gt;执行</p>
<h2 id="Hive的体系结构-1"><a href="#Hive的体系结构-1" class="headerlink" title="Hive的体系结构"></a>Hive的体系结构</h2><ul>
<li>Hadoop</li>
<li>元数据存储</li>
</ul>
<p>linux-&gt;hadoop-&gt;hive</p>
<p>hadoop: DataNode数据节点，NameNode名称节点，JobTracker任务调度器</p>
<p>hive：Hive Driver驱动包括编译器，解析器，优化器。访问接口：CLI,ODBC,Web Console只可以查询。元数据metastore</p>
<h2 id="Hive安装和管理"><a href="#Hive安装和管理" class="headerlink" title="Hive安装和管理"></a>Hive安装和管理</h2><h2 id="Hive的数据模型和操作"><a href="#Hive的数据模型和操作" class="headerlink" title="Hive的数据模型和操作"></a>Hive的数据模型和操作</h2><h1 id="Hive的数据导入到数据仓库"><a href="#Hive的数据导入到数据仓库" class="headerlink" title="Hive的数据导入到数据仓库"></a>Hive的数据导入到数据仓库</h1><h2 id="load语句执行数据导入"><a href="#load语句执行数据导入" class="headerlink" title="load语句执行数据导入"></a>load语句执行数据导入</h2><p><code>LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=vall, partcol2=val2)]</code></p>
<p>PARTITION当是分区表</p>
<p>load命令，Sqoop组件导入</p>
<p>数据查询 HQL语句</p>
<p>Hive的Java客户端和自定义函数</p>
<p>Hive的体系结构和基本操作</p>
<p>Java编程</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据之Hive的数据操作以及开发&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Hive是基于Hadoop的一个数据仓库工具，通过它可以实现将结构化的数据文件映射为一张数
    
    </summary>
    
      <category term="数据分析" scheme="http://microndgt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Hive" scheme="http://microndgt.github.io/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串和文本</title>
    <link href="http://microndgt.github.io/2017/01/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/"/>
    <id>http://microndgt.github.io/2017/01/19/Python字符串和文本/</id>
    <published>2017-01-19T00:40:59.000Z</published>
    <updated>2017-01-27T05:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>拆分字符串，搜索，替换，词法分析以及解析，正则表达式.</p>
<h1 id="针对任意多的分隔符拆分字符串"><a href="#针对任意多的分隔符拆分字符串" class="headerlink" title="针对任意多的分隔符拆分字符串"></a>针对任意多的分隔符拆分字符串</h1><p>普通字符串的split方法只能处理单个的分隔符，如果要处理多个分隔符，使用<code>re.split()</code>，返回结果仍然是列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line = &apos;asdf fjdk; afed, fjek,asdf&apos;</div><div class="line">import re</div><div class="line">re.split(r&apos;[;,\s]\s*&apos;, line&apos;)</div><div class="line"># \s表示空格，*表示匹配前方0次或者多次</div></pre></td></tr></table></figure>
<p>如果使用捕获组，匹配的文本也会包含在最终结果中，捕获组中加入或<code>|</code>符号</p>
<p><code>fields = re.split(r&#39;(;|,|\s)\s*&#39;, line&#39;)</code></p>
<p>或者使用非捕获组<code>?:</code></p>
<p><code>fields = re.split(r&#39;(?:;|,|\s)\s*&#39;, line&#39;)</code></p>
<h1 id="在字符串开头或者结尾处做文本匹配"><a href="#在字符串开头或者结尾处做文本匹配" class="headerlink" title="在字符串开头或者结尾处做文本匹配"></a>在字符串开头或者结尾处做文本匹配</h1><p>使用<code>str.startswith()</code>和<code>str.endswith()</code>，如果要对多个选项做检查，给这两个函数传入包含可能选项的元组。</p>
<p><code>[name for name in filenames if name.endswith((&#39;.h&#39;, &#39;.c&#39;))]</code></p>
<p>使用<code>any()</code>函数：</p>
<p><code>any(name.endswith(&#39;.py&#39;) for name in filenames)</code></p>
<p>这里是Python需要把元组当成输入的一个地方，如果选项指定在列表或者集合里，使用<code>tuple()</code>函数将其转换成元组</p>
<h1 id="文本模式的匹配和查找"><a href="#文本模式的匹配和查找" class="headerlink" title="文本模式的匹配和查找"></a>文本模式的匹配和查找</h1><p>使用re模块</p>
<p>可以将正则表达式首先预编译成一个模式对象<code>datepat = re.compile(r&#39;\d+/\d+/\d+&#39;)</code></p>
<p><code>\d</code>表示数字，<code>+</code>表示匹配一次或者多次，<code>*</code>表示匹配0次或者多次</p>
<p><code>re.match()</code>返回一个匹配对象，可以使用<code>groups()</code>方法，<code>m.group(0)</code>表示所有匹配对象，<code>m.group(1)</code>表示第一次匹配的对象</p>
<p><code>re.search()</code>和<code>match()</code>不同的是对整个文本进行匹配而不是从头开始匹配</p>
<p><code>re.findall()</code>返回一个列表，包含所有匹配成功的字符串</p>
<h1 id="查找和替换文本"><a href="#查找和替换文本" class="headerlink" title="查找和替换文本"></a>查找和替换文本</h1><p><code>str.replace(old, new)</code>进行字符串的替换</p>
<p>使用<code>re.sub()</code>，第一个参数是要匹配的模式，第二个参数是要替换上的模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">t = &apos; today is 11/27/2017. Pycon is 3/13/2013&apos;</div><div class="line">import re</div><div class="line">re.sub(r&apos;(\d+)/(\d+)/(\d+)&apos;, r&apos;\3-\1-\2&apos;, t)</div><div class="line"># 真正运行一遍才知道自己掌握了没，注意：使用r原始字符串，使用捕获组后面的\3才能使用</div></pre></td></tr></table></figure>
<p>可以预先编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datepat = re.compile(r&apos;(\d+)/(\d+)/(\d+)&apos;)</div><div class="line">datapat.sub(r&apos;\3-\1-\2&apos;, t)</div></pre></td></tr></table></figure>
<p>完成多少次替换<code>re.subn()</code></p>
<p><code>newtext, n = datepat.subn(r&#39;\3-\1-\2&#39;, text)</code></p>
<h1 id="以不区分大小写的方式对文本做查找和替换"><a href="#以不区分大小写的方式对文本做查找和替换" class="headerlink" title="以不区分大小写的方式对文本做查找和替换"></a>以不区分大小写的方式对文本做查找和替换</h1><p>加上<code>re.IGNORECASE</code>标记</p>
<p><code>re.findall(&#39;python&#39;, text, flags=re.IGNORECASE)</code></p>
<p>可以使用一个支撑函数作为<code>sub()</code>中的要替换上的模式，返回一个替换后的字符串</p>
<h1 id="实现最短匹配的正则表达式"><a href="#实现最短匹配的正则表达式" class="headerlink" title="实现最短匹配的正则表达式"></a>实现最短匹配的正则表达式</h1><p><code>r&#39;\&quot;(.*)\&quot;&#39;</code>使用的是贪心策略，<code>r&#39;\&quot;(.*?)\&quot;&#39;</code>使用的是非贪心策略，另外<code>.</code>除了换行符可以匹配任意字符，可以使用<code>re.S</code>或者是<code>re.DOTALL</code>用来匹配换行符</p>
<p>另外一般遇到复杂情况都是自己书写正则表达式：<code>comment = re.compile(r&#39;/\*((?:.|\n)*?)\*/)</code>，其中指定了一个非捕获组，这个组只做匹配但是不捕获结果，也不会分配组号。</p>
<h1 id="将Unicode文本统一表示成规范形式"><a href="#将Unicode文本统一表示成规范形式" class="headerlink" title="将Unicode文本统一表示成规范形式"></a>将Unicode文本统一表示成规范形式</h1><p>对于任何需要确保以规范和一致性的方式处理Unicode文本的程序来说，规范化都是重要的一部分，在对文本进行过滤和净化的时候，规范化同样占据了重要的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import unicodedata</div><div class="line">t1 = unicodedata.normalize(&apos;NFD&apos;, s1)</div><div class="line">&apos;&apos;.join(c for c in t1 if not unicodedata.combining(c))</div></pre></td></tr></table></figure>
<p><code>combining()</code>函数对字符进行检查，判断它是否是一个组合型字符，若不是则返回0</p>
<p>NFC表示字符应该是全组成的，如果可能就使用单个代码点。NFD表示应该使用组合字符，每个字符应该是能完全分解开的。</p>
<h1 id="从字符串中去掉不需要的字符"><a href="#从字符串中去掉不需要的字符" class="headerlink" title="从字符串中去掉不需要的字符"></a>从字符串中去掉不需要的字符</h1><p>使用<code>strip()</code>方法，或者<code>lstrip()</code>，<code>rstrip()</code></p>
<p>如果要对里面的空格执行某些操作，应该使用其他技巧比如replace()方法或者正则表达式替换</p>
<p>经常遇到的情况是去除字符的操作和某些迭代操作结合起来，生成器表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with open(filename) as f:</div><div class="line">    lines = (line.strip() for line in f)</div><div class="line">    for line in line:</div><div class="line">        ...</div></pre></td></tr></table></figure>
<h1 id="文本过滤与清理"><a href="#文本过滤与清理" class="headerlink" title="文本过滤与清理"></a>文本过滤与清理</h1><p>感觉非常好用啊，使用<code>str.translate()</code>方法，首先创建一个转换表格，然后使用这个方法对字符串进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ord函数返回ASC值</div><div class="line">remap = &#123;</div><div class="line">  ord(&apos;\t&apos;): &apos; &apos;,</div><div class="line">  ord(&apos;\f&apos;): &apos; &apos;,</div><div class="line">  ord(&apos;\r&apos;): None # 直接被删除</div><div class="line">&#125;</div><div class="line"># 调用translate方法</div><div class="line">a = s.translate(remap)</div></pre></td></tr></table></figure>
<p>删除所有的和音符，使用NFD可以将字符串分解成单个字符，标准化称为分解形式字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode) if unicodedata.combining(chr(c)))</div><div class="line">b = unicodedata.normalize(&apos;NFD&apos;, a)</div><div class="line">b.translate(cmb_chrs)</div></pre></td></tr></table></figure>
<p>一般使用replace方法比较快，但是涉及任何复杂字符对字符的重新映射或者是删除操作的话，translate方法会比较快</p>
<h1 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h1><p>使用ljust(),rjust(),center()方法，并且可以接受一个可选的填充字符,<code>text.rjust(20, &#39;=&#39;)</code></p>
<p>format函数也可以用来对齐字符串<code>format(text, &#39;&gt;20&#39;)</code> 右对齐，或者指定一个非空格填充字符，<code>format(text, &#39;=&gt;20&#39;)</code></p>
<p>格式化多个值，<code>&#39;&#39;{:&gt;10s} {:&gt;10s}&#39;.format(&#39;hello&#39;, &#39;world&#39;)&#39;</code></p>
<p>可以格式化任何值，<code>x = 1.234</code>, <code>format(x, &#39;&gt;10&#39;)</code></p>
<p>优先选用format()函数或者方法</p>
<h1 id="合并拼接字符串"><a href="#合并拼接字符串" class="headerlink" title="合并拼接字符串"></a>合并拼接字符串</h1><p>如果要合并的字符串在一个序列中，最快的方式就是join()方法，如果是合并少数的几个字符串，使用加号就可以了。</p>
<p>如果只是将两个字面字符串合并起来，只需要简单的放在一起就OK, <code>a = &#39;Hello&#39; &#39;World&#39;</code></p>
<p>使用生成器表达式：<code>&#39;,&#39;.join(str(d) for d in data)</code></p>
<p>注意不必要的字符串连接操作：<code>print(a, b, c, sep=&quot;:&quot;)</code>，这样更加优雅</p>
<h1 id="内嵌变量的字符串"><a href="#内嵌变量的字符串" class="headerlink" title="内嵌变量的字符串"></a>内嵌变量的字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &apos;&#123;name&#125; has &#123;n&#125; message&apos;</div><div class="line">s.format(name=&quot;kevin&quot;, n=34)</div></pre></td></tr></table></figure>
<p>如果要被替换的变量能在变量域中找到，可以结合使用format_map()和vars(),vars()返回了一个字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name = &quot;kevin&quot;</div><div class="line">n = 5</div><div class="line">s.format_map(vars())</div></pre></td></tr></table></figure>
<p>vars()也适用于对象实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = Info(&apos;kevin&apos;, 30)</div><div class="line"># 其中Info类中含有相应的属性名字为name和n</div><div class="line">s.format_map(vars(a))</div></pre></td></tr></table></figure>
<p>定义一个含有<code>__missing__()</code>方法的字典对象这样就可以避免KeyError</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class safesub(dict):</div><div class="line">    # 定义如何处理缺失值</div><div class="line">    def __missing__(self, key):</div><div class="line">        return &apos;&#123;&apos; + key + &apos;&#125;&apos;</div><div class="line">s.format_map(safesub(vars()))</div><div class="line"># 这样即使不存在这个键也不会报错</div></pre></td></tr></table></figure>
<p>可以进一步封装成工具函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">def sub(text):</div><div class="line">    return text.format_map(safesub(sys._getframe(1).f_locals))</div></pre></td></tr></table></figure>
<p><code>sys._getframe(1)</code>返回调用者的栈帧，从中访问属性<code>f_locals</code>来获得局部变量，是一个复制调用函数本地变量的字典，对它的操作不回覆盖和改变调用者本地变量的值。</p>
<h1 id="文本分词"><a href="#文本分词" class="headerlink" title="文本分词"></a>文本分词</h1><p>有一个字符串，想从左到右将其解析为标记流</p>
<p>第一步是利用命名捕获组的正则表达式定义所有可能的标记，包括空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">NAME = r&apos;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&apos;</div><div class="line"># ?P&lt;TOKENNAME&gt;用于给一个模式命名</div><div class="line">NUM = r&apos;(?P&lt;NUM&gt;\d+)&apos;</div><div class="line">PLUS = r&apos;(?P&lt;PLUS&gt;\+)&apos;</div><div class="line">TIMES = r&apos;(?P&lt;TIMES&gt;\*)&apos;</div><div class="line">EQ = r&apos;(?P&lt;EQ&gt;=)&apos;</div><div class="line">WS = r&apos;(?P&lt;WS&gt;\s+)&apos;</div><div class="line">master_pat = re.compile(r&apos;|&apos;.join([NAME, NUM, PLUS, TIMES, EQ, WS]))</div></pre></td></tr></table></figure>
<p>第二步，使用scanner()方法，创建一个scanner对象，在这个对象上不断调用match()方法会一步步扫描目标文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scanner = master_pat.scanner(&apos;foo = 42&apos;)</div><div class="line"># 重复之</div><div class="line">scanner.match().groups()</div></pre></td></tr></table></figure>
<p>要点在于必须确认使用正则表达式制定了所有输入中可能出现的文本序列。另外分词顺序也是有影响的，re模块会按照制定好的顺序去做匹配，因此另一个模式恰好是另一个更长模式的子字符串，需要确定长模式在前面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拆分字符串，搜索，替换，词法分析以及解析，正则表达式.&lt;/p&gt;
&lt;h1 id=&quot;针对任意多的分隔符拆分字符串&quot;&gt;&lt;a href=&quot;#针对任意多的分隔符拆分字符串&quot; class=&quot;headerlink&quot; title=&quot;针对任意多的分隔符拆分字符串&quot;&gt;&lt;/a&gt;针对任意多的分隔符
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法</title>
    <link href="http://microndgt.github.io/2017/01/16/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://microndgt.github.io/2017/01/16/Python数据结构与算法/</id>
    <published>2017-01-16T13:18:44.000Z</published>
    <updated>2017-01-27T05:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python基本的数据结构与算法</p>
<h1 id="collections-deque的用法"><a href="#collections-deque的用法" class="headerlink" title="collections.deque的用法"></a>collections.deque的用法</h1><p>双端队列，可以用这个队列来保存有限的历史记录，形成一个简单的队列结构，如果不指定队列的大小，就会得到一个无界限的队列。</p>
<p>创建：<code>q = deque(maxlen=3)</code> 建立固定大小的队列</p>
<p>方法：append, appendleft, pop, popleft</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line"></div><div class="line">def search(lines, pattern, history=5):</div><div class="line">	previous_line = deque(maxlen=history)</div><div class="line">	count = 0</div><div class="line">	for li in lines:</div><div class="line">		if pattern in li:</div><div class="line">			yield li, previous_line</div><div class="line">		previous_line.append(li)</div><div class="line"></div><div class="line">with open(&quot;test.txt&quot;) as f:</div><div class="line">	for line, prevlines in search(f, &quot;python&quot;):</div><div class="line">		for pline in prevlines:</div><div class="line">			print(pline,end=&quot;&quot;)</div><div class="line">		print(line,end=&apos;&apos;)</div><div class="line">		print(&apos;-&apos; * 20)</div></pre></td></tr></table></figure>
<h1 id="heapq模块的用法"><a href="#heapq模块的用法" class="headerlink" title="heapq模块的用法"></a>heapq模块的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">start2 = time.time()</div><div class="line">for index, ele in enumerate(heapq.nsmallest(3, targetList)):</div><div class="line">	print(&quot;the %d st min value is %d&quot; % (index+1, ele))</div><div class="line">stop2 = time.time()</div></pre></td></tr></table></figure>
<p>如果查找的元素个数相对比较小，使用nlargest(), nsmallest()比较合适，如果查找唯一的话，使用min(), max()比较合适，如果N大小和集合大小相近，则先排序，sorted(items)[:N]</p>
<h1 id="用heapq模块实现优先级队列"><a href="#用heapq模块实现优先级队列" class="headerlink" title="用heapq模块实现优先级队列"></a>用heapq模块实现优先级队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">class PriorityQueue:</div><div class="line">	def __init__(self):</div><div class="line">		self._queue = []</div><div class="line">		self._index = 0</div><div class="line">	def push(self, item, priority):</div><div class="line">		# 元组比较大小,按照第一个元素来进行,如果优先级相同,按照插入顺序也就是</div><div class="line">		# 第二个元素决定顺序</div><div class="line">		heapq.heappush(self._queue, (-priority, self._index, item))</div><div class="line">		self._index += 1</div><div class="line">	def pop(self):</div><div class="line">		# 返回最小的元素，取出插入元组的最后一个项</div><div class="line">		return heapq.heappop(self._queue)[-1]</div><div class="line">class Item:</div><div class="line">	def __init__(self, name):</div><div class="line">		self.name = name</div><div class="line">	def __repr__(self):</div><div class="line">		return &apos;Item(&#123;&#125;)&apos;.format(self.name)</div><div class="line">q = PriorityQueue()</div><div class="line">q.push(Item(&apos;root&apos;), 5)</div><div class="line">q.push(Item(&apos;Elena&apos;), 3)</div><div class="line">q.push(Item(&apos;Kevin&apos;), 4)</div><div class="line">q.push(Item(&apos;group&apos;), 1)</div><div class="line">q.push(Item(&apos;other&apos;), 1)</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div></pre></td></tr></table></figure>
<h1 id="使用defaultdict类实现一键多值字典"><a href="#使用defaultdict类实现一键多值字典" class="headerlink" title="使用defaultdict类实现一键多值字典"></a>使用defaultdict类实现一键多值字典</h1><p>一个键映射多个值，需要将多个值放到另外的容器里，如列表，集合。</p>
<p>使用collections中的defaultdict构造这样的字典，它会自动初始化每个key刚开始对应的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from collections import defaultdict</div><div class="line">d = defaultdict(list)</div><div class="line">d[&apos;a&apos;].append(1)</div><div class="line">d[&apos;a&apos;].append(2)</div><div class="line">d[&apos;b&apos;].append(4)</div><div class="line">for key, value in d.items():</div><div class="line">	print(key, &quot; and &quot;, value)</div><div class="line">d = defaultdict(set)</div><div class="line">d[&apos;a&apos;].add(1)</div><div class="line">d[&apos;a&apos;].add(3)</div><div class="line">d[&apos;b&apos;].add(4)</div><div class="line">for key, value in d.items():</div><div class="line">	print(key, &quot; and &quot;, value)</div></pre></td></tr></table></figure>
<p>defaultdict会自动为将要访问的键创建映射实体，另外一个是字典的setdefault方法</p>
<p><code>d.setdefault(&#39;a&#39;, []).append(1)</code></p>
<h1 id="使用zip将字典的键和值翻转过来"><a href="#使用zip将字典的键和值翻转过来" class="headerlink" title="使用zip将字典的键和值翻转过来"></a>使用zip将字典的键和值翻转过来</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">d = &#123;&#125;</div><div class="line">d[&apos;a&apos;] = 5</div><div class="line">d[&apos;b&apos;] = 3</div><div class="line">d[&apos;c&apos;] = 6</div><div class="line">d[&apos;d&apos;] = 2</div><div class="line"># 求最小值,返回的是一个只能访问一次的迭代器</div><div class="line">min_value = min(zip(d.values(), d.keys()))</div><div class="line">print(min_value)</div><div class="line"># sorted默认是按照第一个元素进行排序的</div><div class="line">d_sorted = sorted(zip(d.values(), d.keys()))</div><div class="line">print(d_sorted)</div><div class="line"># 要改变的话,指定key</div><div class="line">d_sorted_1 = sorted(d.items(), key=lambda x: x[1])</div><div class="line">print(d_sorted_1)</div></pre></td></tr></table></figure>
<h1 id="keys-和items-方法都支持集合操作"><a href="#keys-和items-方法都支持集合操作" class="headerlink" title="keys()和items()方法都支持集合操作"></a>keys()和items()方法都支持集合操作</h1><p>这两个方法返回了<code>keys-view</code>对象，其中暴露了键或者键值，但是values()方法不支持集合操作，因为value可能是重复的，不是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(d.keys() &amp; e.keys())</div><div class="line">print(d.keys() - e.keys())</div><div class="line">print(d.items() &amp; e.items())</div><div class="line">c = &#123;key: d[key] for key in d.keys() - &#123;&apos;z&apos;, &apos;b&apos;&#125;&#125;</div><div class="line">print(c)</div></pre></td></tr></table></figure>
<h1 id="从序列中去除重复元素"><a href="#从序列中去除重复元素" class="headerlink" title="从序列中去除重复元素"></a>从序列中去除重复元素</h1><p>如果一个对象是可哈希的，那么在它的生存期内必须是不可变的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def dedupe(items, key=None):</div><div class="line">	seen = set()</div><div class="line">	for item in items:</div><div class="line">		val = item if key is None else key(item)</div><div class="line">		if val not in seen:</div><div class="line">			yield item</div><div class="line">			seen.add(val)</div><div class="line">a = [ &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;]</div><div class="line"># 将值转换成元组,hashable</div><div class="line">print(list(dedupe(a, key=lambda d: (d[&apos;x&apos;], d[&apos;y&apos;]))))</div></pre></td></tr></table></figure>
<h1 id="寻找序列中出现次数最多的元素"><a href="#寻找序列中出现次数最多的元素" class="headerlink" title="寻找序列中出现次数最多的元素"></a>寻找序列中出现次数最多的元素</h1><p>使用collections里面的Counter类，可以给该对象提供任何可哈希的对象序列作为输入，是一个字典，在元素和它们出现的次数之间做了映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">word_counts = Counter(words)</div><div class="line">top_three = word_counts.most_common(3)</div><div class="line">print(top_three)</div><div class="line">record = &quot;32323432435435235326253435436546547643&quot;</div><div class="line">from collections import Counter</div><div class="line">record = list(record)</div><div class="line">counts = Counter(record)</div><div class="line">top_five = counts.most_common(5)</div><div class="line">print(top_five)</div><div class="line">print(counts[&apos;3&apos;])</div><div class="line">more = list(&quot;43542354&quot;)</div><div class="line">counts.update(more)</div><div class="line">print(counts[&apos;3&apos;])</div><div class="line"># Counter对象支持数学运算</div><div class="line">counts1 = Counter(more)</div><div class="line">print(counts + counts1)</div></pre></td></tr></table></figure>
<h1 id="使用itemgetter来对字典列表排序"><a href="#使用itemgetter来对字典列表排序" class="headerlink" title="使用itemgetter来对字典列表排序"></a>使用itemgetter来对字典列表排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">rows = [</div><div class="line">	&#123;&apos;fname&apos;: &apos;Brian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1003&#125;,</div><div class="line">	&#123;&apos;fname&apos;: &apos;Kevin&apos;, &apos;lname&apos;: &apos;Du&apos;, &apos;uid&apos;: 1000&#125;</div><div class="line">]</div><div class="line">from operator import itemgetter</div><div class="line">＃ 类似一个方法，通过itemgetter的到rows的属性fname作为key，item表示项，和后面的attr属性有所区别，属性则用于类</div><div class="line">rows_by_fname = sorted(rows, key=itemgetter(&apos;fname&apos;))</div><div class="line">print(rows_by_fname)</div><div class="line">rows_by_lname = sorted(rows, key=itemgetter(&apos;lname&apos;))</div><div class="line">print(rows_by_lname)</div><div class="line">rows_by_nameid = sorted(rows, key=itemgetter(&apos;lname&apos;, &apos;uid&apos;))</div><div class="line">print(rows_by_nameid)</div><div class="line"># 也可以使用lambda表达式代替</div><div class="line">rows_by_fname = sorted(rows, key=lambda r: r[&apos;fname&apos;])</div><div class="line"># 但是使用itemgetter更快一些</div><div class="line">print(rows_by_fname)</div><div class="line"># 也适用于min和max函数</div></pre></td></tr></table></figure>
<h1 id="使用attrgetter来对类进行排序"><a href="#使用attrgetter来对类进行排序" class="headerlink" title="使用attrgetter来对类进行排序"></a>使用attrgetter来对类进行排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class User:</div><div class="line">	def __init__(self, user_id):</div><div class="line">		self.user_id = user_id</div><div class="line">	def __repr__(self):</div><div class="line">		return &apos;User(&#123;&#125;)&apos;.format(self.user_id)</div><div class="line"></div><div class="line">def sort_notcompare():</div><div class="line">	users = [User(23), User(3), User(99)]</div><div class="line">	print(users)</div><div class="line">	print(sorted(users, key=lambda a: a.user_id))</div><div class="line"></div><div class="line">from operator import attrgetter</div><div class="line">users = [User(23), User(3), User(99), User(43)]</div><div class="line">print(users)</div><div class="line">print(sorted(users, key=attrgetter(&apos;user_id&apos;)))</div><div class="line">sort_notcompare()</div></pre></td></tr></table></figure>
<h1 id="itertools的groupby函数对数据进行分组"><a href="#itertools的groupby函数对数据进行分组" class="headerlink" title="itertools的groupby函数对数据进行分组"></a>itertools的groupby函数对数据进行分组</h1><p>itertools.groupby()函数扫描整个序列并且查找连续相同的值的元素序列，每次迭代的时候返回一个值和一个迭代器对象，这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。但是必须根据指定的字段将数据排序，groupby函数仅仅检查连续的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">from itertools import groupby</div><div class="line">rows = [</div><div class="line">	&#123;&apos;date&apos;: &apos;01/01&apos;, &apos;item&apos;: 1&#125;,</div><div class="line">	&#123;&apos;date&apos;: &apos;02/01&apos;, &apos;item&apos;: 2&#125;,</div><div class="line">	&#123;&apos;date&apos;: &apos;01/01&apos;, &apos;item&apos;: 2&#125;</div><div class="line">]</div><div class="line"># 首先进行排序</div><div class="line"># 或者使用itemgetter, 用于字典</div><div class="line">rows.sort(key=itemgetter(&apos;date&apos;))</div><div class="line">print(rows)</div><div class="line">rows.sort(key=lambda x: x[&apos;item&apos;])</div><div class="line"># 返回值以及分组的组</div><div class="line">for date, item in groupby(rows, key=lambda x: x[&apos;item&apos;]):</div><div class="line">	print(date)</div><div class="line">	for i in item:</div><div class="line">		print(&quot; &quot;,i)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python基本的数据结构与算法&lt;/p&gt;
&lt;h1 id=&quot;collections-deque的用法&quot;&gt;&lt;a href=&quot;#collections-deque的用法&quot; class=&quot;headerlink&quot; title=&quot;collections.deque的用法&quot;&gt;&lt;/a&gt;co
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 部署</title>
    <link href="http://microndgt.github.io/2017/01/12/Effective-Python-%E9%83%A8%E7%BD%B2/"/>
    <id>http://microndgt.github.io/2017/01/12/Effective-Python-部署/</id>
    <published>2017-01-12T11:37:10.000Z</published>
    <updated>2017-01-27T05:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Effective Python 的最后部分。</p>
<h1 id="用适当的方式打破循环依赖关系"><a href="#用适当的方式打破循环依赖关系" class="headerlink" title="用适当的方式打破循环依赖关系"></a>用适当的方式打破循环依赖关系</h1><p>Python系统在执行import语句时的详细机制，引入模块时候，Python会按照深度优先的顺序执行下列操作</p>
<ol>
<li>在由sys.path所指定的路径中，搜寻待引入的模块</li>
<li>从模块中加载代码，并且保证这段代码能够正确编译</li>
<li>创建与该模块相对应的空对象</li>
<li>把这个空的模块对象，添加到sys.modules里面</li>
<li>运行模块对象中的代码，以定义其内容</li>
</ol>
<p>某些属性必须等Python系统把对应的代码执行完毕之后，才可以具有完整的定义，但是，包含该属性的模块，却只需要等Python系统执行完第四步，就可以用import语句引入并且添加到sys.modules</p>
<p>解决这个问题的最佳方案，就是重构代码，将要重复用到的数据结构定义出来，然后app与dialog模块都引入这个工具模块，这样以避免出现循环依赖关系。</p>
<p>三种解决办法：</p>
<ol>
<li>调整引入顺序</li>
<li><p>先引入，再配置，最后运行</p>
<p>只在模块中给出函数，类和常量的定义，而不要在引入的时候真正运行那些函数。在main模块中，分三个阶段来执行代码，首先引入所有的模块，然后配置他们，最后执行程序中的第一个动作。</p>
</li>
<li><p>动态引入</p>
<p>在函数或者方法内部使用import语句，程序会等到真正需要运行相关代码时候，才会触发模块的引入操作，所以称为动态引入。但是有可能重复引入，这样也不好。</p>
</li>
</ol>
<h1 id="用虚拟环境隔离项目，并重建其依赖关系"><a href="#用虚拟环境隔离项目，并重建其依赖关系" class="headerlink" title="用虚拟环境隔离项目，并重建其依赖关系"></a>用虚拟环境隔离项目，并重建其依赖关系</h1><p>使用pyvenv工具，提供了一套虚拟环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">which python</div><div class="line">python --version</div><div class="line"># 创建虚拟环境</div><div class="line">pyvenv /temp/myproject</div><div class="line">cd /tmp/myproject</div><div class="line">source bin/activate</div><div class="line">pip install pytz</div><div class="line">deactivate</div></pre></td></tr></table></figure>
<h2 id="重建项目的依赖关系"><a href="#重建项目的依赖关系" class="headerlink" title="重建项目的依赖关系"></a>重建项目的依赖关系</h2><p><code>pip freeze</code> 使用这个命令，生成<code>requirements.txt</code>将开发环境软件包的依赖关系，明确的保存到文件中。</p>
<p>然后<code>pip install -r /tmp/requirements.txt</code></p>
<h1 id="考虑使用模块级别的代码来配置不同的部署环境"><a href="#考虑使用模块级别的代码来配置不同的部署环境" class="headerlink" title="考虑使用模块级别的代码来配置不同的部署环境"></a>考虑使用模块级别的代码来配置不同的部署环境</h1><p>想让Python程序付诸使用，必须从开发环境部署到生产环境中，要将Python程序产品化，令其能够稳定的运行在实际环境中。</p>
<p>编写<code>__main__.py</code>文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Effective Python 的最后部分。&lt;/p&gt;
&lt;h1 id=&quot;用适当的方式打破循环依赖关系&quot;&gt;&lt;a href=&quot;#用适当的方式打破循环依赖关系&quot; class=&quot;headerlink&quot; title=&quot;用适当的方式打破循环依赖关系&quot;&gt;&lt;/a&gt;用适当的方式打破循环依赖关
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 并发与并行</title>
    <link href="http://microndgt.github.io/2017/01/11/Effective-Python-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
    <id>http://microndgt.github.io/2017/01/11/Effective-Python-并发与并行/</id>
    <published>2017-01-11T11:20:40.000Z</published>
    <updated>2017-01-27T05:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看书学习后对以前不懂的概念越发的清晰了.</p>
<p>并发是操作系统会在各程序之间迅速切换，使其都有机会运行在这一个处理器上，这种交错执行程序的方式，叫做并发。而并行是指，计算机是在同一时间做着不同的事情，多个核心的计算机，能够同时执行多个程序，使得这些程序能够在同一时刻向前推进。</p>
<h1 id="用subprocess管理子进程"><a href="#用subprocess管理子进程" class="headerlink" title="用subprocess管理子进程"></a>用subprocess管理子进程</h1><p>由Python所启动的多个子进程，是可以平行运作的。最简单的子进程管理模块就是subprocess模块</p>
<p>用Popen构造器来启动进程，然后使用communicate方法来读取子进程的输出信息，并等待其终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proc = subprocess.Popen([&apos;echo&apos;, &apos;Hello from the child!&apos;], stdout=subprocess.PIPE)</div><div class="line">out, err = proc.communicate()</div><div class="line">print(out.decode(&apos;utf-8&apos;))</div></pre></td></tr></table></figure>
<p>子进程会独立于父进程而运行，父进程就是Python解释器，把子进程从父进程中剥离，意味着父进程可以随意运行很多条平行的子进程。</p>
<p>并且也可以从Python程序向子进程中输送数据，然后获取子进程的输出信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">def run_openssl(data):</div><div class="line">    env = os.environ.copy()</div><div class="line">    env[&apos;passwd&apos;] = b&apos;\xe24U\n&apos;</div><div class="line">    proc = subprocess.Popen([&apos;openssl&apos;, &apos;enc&apos;, &apos;-des3&apos;, &apos;-pass&apos;, &apos;env:password&apos;],</div><div class="line">        env=env,</div><div class="line">        stdin=subprocess.PIPE</div><div class="line">        stdout=subprocess.PIPE)</div><div class="line">    proc.stdin.write(data)</div><div class="line">    proc.stdin.flush()</div><div class="line">    return proc</div><div class="line">procs = []</div><div class="line">for _ in range(3):</div><div class="line">    data = os.urandom(10)</div><div class="line">    proc = run_openssl(data)</div><div class="line">    procs.append(proc)</div><div class="line"># 这些子进程就可以平行的运作并且处理他们的输入信息</div><div class="line">for proc in procs:</div><div class="line">    out, err = proc.communicate()</div><div class="line">    print(out[-10:])</div></pre></td></tr></table></figure>
<h1 id="可以用线程来执行阻塞式I-O，但是不要用它做平行计算"><a href="#可以用线程来执行阻塞式I-O，但是不要用它做平行计算" class="headerlink" title="可以用线程来执行阻塞式I/O，但是不要用它做平行计算"></a>可以用线程来执行阻塞式I/O，但是不要用它做平行计算</h1><p>标准的Python实现叫做CPython，CPython分两步运行Python程序，首先，把文本形式的源代码解析并编译成字节码，然后用基于栈的解释器来运行这份字节码。执行Python程序时候，字节码解释器必须保持协调一致的状态，Python使用GIL全局解释器锁来确保这种协调性。</p>
<p>GIL防止CPython受到占先式多线程切换操作的干扰，是指某个线程可以通过打断另外一个线程的方式，来获取程序控制权。所以同一时刻，只有一条线程可以向前执行。</p>
<p>Python下的多线程有以下的好处，首先，多线程使得程序看上去好像能够在同一时间做许多事情。能够令Python程序自动以一种看似平行的方式，来执行这些函数。不过受到GIL限制，所以同一时刻实际上只能有一个线程得到执行。</p>
<p>另外一个好处是处理阻塞式I/O操作，可以借助线程，把Python程序与这些耗时的I/O操作隔离开。尽管受制于GIL，但是用多个Python线程来执行系统调用的时候，这些系统调用可以平行的执行，GIL虽然使得Python代码无法执行，但是它对系统调用却没有任何负面影响，由于Python线程在执行系统调用的时候回释放GIL，并且一直要等到执行完毕才会重新获取它，所以GIL是不会影响系统调用的。</p>
<h1 id="在线程中使用Lock来防止数据竞争"><a href="#在线程中使用Lock来防止数据竞争" class="headerlink" title="在线程中使用Lock来防止数据竞争"></a>在线程中使用Lock来防止数据竞争</h1><p>虽然同一时刻只有一个线程在运行，但是当这个线程正在操作某个数据结构的时候，其他线程可能会打断它，也就是说，Python解释器在执行两个连续的字节码时候，其他线程可能会在中途突然插进来。如果在多个线程中同时访问某个对象，那么中断现象就可能随时发生。一旦发生，就会破坏程序的状态，从而使相关的数据结构无法保持其一致性。</p>
<p>为了防止这种数据竞争，Lock类，也相当于互斥锁，就可以保护自己的数据结构不受破坏。同一时刻，只有一个线程能够获得这把锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class LockingCounter(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.lock = Lock()</div><div class="line">        self.count = 0</div><div class="line">    def increment(self, offset):</div><div class="line">        with self.lock:</div><div class="line">            self.count += offset</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看书学习后对以前不懂的概念越发的清晰了.&lt;/p&gt;
&lt;p&gt;并发是操作系统会在各程序之间迅速切换，使其都有机会运行在这一个处理器上，这种交错执行程序的方式，叫做并发。而并行是指，计算机是在同一时间做着不同的事情，多个核心的计算机，能够同时执行多个程序，使得这些程序能够在同一时刻
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python实用脚本系统管理</title>
    <link href="http://microndgt.github.io/2017/01/10/Python%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://microndgt.github.io/2017/01/10/Python实用脚本系统管理/</id>
    <published>2017-01-10T10:09:36.000Z</published>
    <updated>2017-01-27T05:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<p> 系统任务的自动化处理，解析命令行选项，操纵文件系统中的文件，获取有用的系统配置数据</p>
<h1 id="通过重定向，管道或者输入文件来作为脚本的输入"><a href="#通过重定向，管道或者输入文件来作为脚本的输入" class="headerlink" title=" 通过重定向，管道或者输入文件来作为脚本的输入"></a> 通过重定向，管道或者输入文件来作为脚本的输入</h1><p> 接受任意一种对用户来说最为方便的输入机制，从命令中产生输出给脚本，把文件重定向到脚本，或者是在命令行中传递一个或者一列文件名给脚本。</p>
<blockquote>
<p>是可以将需要传入部分文件的那个东西，只设置一个-p bool参数，然后为True的时候重定向有用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import fileinput</div><div class="line">with fileinput.input() as f_input:</div><div class="line">    for line in f_input:</div><div class="line">        print(line, end=&apos;&apos;)</div></pre></td></tr></table></figure>
<p>fileinput.input()创建并且返回一个FileInput类的实例，该实例可以用作上下文管理器使用</p>
<h1 id="终止程序并显示错误信息"><a href="#终止程序并显示错误信息" class="headerlink" title="终止程序并显示错误信息"></a>终止程序并显示错误信息</h1><p>发出一个SystemExit异常，提供错误信息作为参数</p>
<p><code>raise SystemExit(&#39;It failed&#39;)</code></p>
<h1 id="解析命令行选项"><a href="#解析命令行选项" class="headerlink" title="解析命令行选项"></a>解析命令行选项</h1><p>argparse模块解析命令行选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. parser = argparse.ArgumentParser()</div><div class="line">2. parser.add_argument()</div><div class="line">3. args = parser.parse_args()</div><div class="line">参数用法什么的参考文档</div></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="external">argparse模块使用指南</a></p>
<h1 id="执行外部命令并获取输出"><a href="#执行外部命令并获取输出" class="headerlink" title="执行外部命令并获取输出"></a>执行外部命令并获取输出</h1><p>执行一个外部命令并把输出保存为一个Python字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import subprocess</div><div class="line">out_bytes = subprocess.check_output([&apos;netstat&apos;, &apos;-a&apos;])</div></pre></td></tr></table></figure>
<p>输出结果以字节串形式返回，如果要以文本形式解读，可以再增加解码步骤</p>
<p><code>out_text = out_bytes.decode(&#39;utf-8&#39;)</code></p>
<p>该函数只会返回写入到标准输出中的结果，如果希望命令通过shell执行，可以将命令以简单的字符串形式提供并且指定参数shell=True</p>
<p><code>out_bytes = subprocess.check_output(&#39;grep python | wc &gt; output&#39;, shell=True)</code></p>
<p>如果需要实现自动向用户请求输入密码的任务，需要expect族的工具</p>
<h1 id="拷贝或者移动文件和目录"><a href="#拷贝或者移动文件和目录" class="headerlink" title="拷贝或者移动文件和目录"></a>拷贝或者移动文件和目录</h1><p>shutil模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import shutil</div><div class="line">shutil.copy(src, dst)</div><div class="line">shutil.copy2(src, dst) # preserve metadata</div><div class="line">shutil.copytree(src, dst)</div><div class="line">shutil.move(src, dst)</div></pre></td></tr></table></figure>
<p>当和文件名打交道的时候，尽量使用os.path模块获得最佳的移植性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">os.path.basename(path)</div><div class="line">os.path.dirname(path)</div><div class="line">os.path.split(filename)</div><div class="line">os.path.join(dir, filename)</div><div class="line">os.path.expanduser(path) # 把path中包含的&quot;~&quot;和&quot;~user&quot;转换成用户目录</div></pre></td></tr></table></figure>
<h1 id="创建和解包归档文件"><a href="#创建和解包归档文件" class="headerlink" title="创建和解包归档文件"></a>创建和解包归档文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import shutil</div><div class="line">shutil.unpack_archive(&apos;python.zip&apos;)</div><div class="line">shutil.make_archive(&apos;py33&apos;, &apos;zip&apos;, root_dir)</div></pre></td></tr></table></figure>
<h1 id="通过名称来查找文件"><a href="#通过名称来查找文件" class="headerlink" title="通过名称来查找文件"></a>通过名称来查找文件</h1><p>搜索文件可以使用<code>os.walk()</code>函数，将顶层目录提供给它即可，返回一个3元组，当前目录的相对路径，该目录包含的所有目录名的列表，以及该目录中所有文件名的列表</p>
<p>使用<code>os.path.join()</code>来组合路径的时候，使用<code>os.path.abspath()</code>和<code>os.path.normpath()</code>来修正路径成标准化形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import time</div><div class="line">def modified_within(top, seconds):</div><div class="line">    now = time.time()</div><div class="line">    for path, dirs, files in os.walk(top):</div><div class="line">        for name in files:</div><div class="line">            fullpath = os.path.join(path, name)</div><div class="line">            if os.path.exists(fullpath):</div><div class="line">                mtime = os.path.getmtime(fullpath)</div><div class="line">                if mtime &gt; (now - seconds):</div><div class="line">                    print(fullpath)</div></pre></td></tr></table></figure>
<h1 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h1><p>使用configparser模块来读取配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from configparser import ConfigParser</div><div class="line">cfg = ConfigParser()</div><div class="line">cfg.read(&apos;config.ini&apos;)</div><div class="line">cfg.sections()</div><div class="line">cfg.get(&apos;installation&apos;, &apos;library&apos;)</div><div class="line">cfg.getboolean(&apos;debug&apos;, &apos;log_errors&apos;)</div><div class="line">cfg.getint(&apos;server&apos;, &apos;port&apos;)</div><div class="line"># 写入</div><div class="line">cfg.set(&apos;server&apos;, &apos;port&apos;, &apos;9000&apos;)</div><div class="line">cfg.write(filename)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 系统任务的自动化处理，解析命令行选项，操纵文件系统中的文件，获取有用的系统配置数据&lt;/p&gt;
&lt;h1 id=&quot;通过重定向，管道或者输入文件来作为脚本的输入&quot;&gt;&lt;a href=&quot;#通过重定向，管道或者输入文件来作为脚本的输入&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python模块和包</title>
    <link href="http://microndgt.github.io/2017/01/08/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://microndgt.github.io/2017/01/08/Python模块和包/</id>
    <published>2017-01-08T14:49:13.000Z</published>
    <updated>2017-01-27T05:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>模块和包是任何大型项目的核心,本文核心是如何组织包,将大型的模块分解成多个文件,以及创建命名空间包.</p>
<h1 id="git问题处理"><a href="#git问题处理" class="headerlink" title="git问题处理"></a>git问题处理</h1><p>hexo d提交的时候出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git.exe pull --progress --no-rebase -v &quot;origin&quot;</div><div class="line">fatal: unable to access https://github.com/konsumer/arduinoscope.git/: error setting certificate verify locations:</div><div class="line">CAfile: D:\Program Files\Git\mingw64/bin/curl-ca-bundle.crt</div><div class="line">CApath: none</div></pre></td></tr></table></figure>
<p>输入<code>git config --system http.sslverify false</code>解决问题</p>
<h1 id="把模块按层次结构组织成包"><a href="#把模块按层次结构组织成包" class="headerlink" title="把模块按层次结构组织成包"></a>把模块按层次结构组织成包</h1><p>只要把代码按照所希望的方式在文件系统上进行组织，并且确保每个目录中都定义了一个<code>__init__.py</code>文件即可</p>
<p><code>__init__.py</code>文件的目的是包含可选的初始化代码，当遇到软件包中不同层次的模块时候会触发运行，比如<code>import graphics</code>文件<code>graphics/__init__.py</code>会被导入并形成graphics命名空间中的内容</p>
<p>一般情况该文件留空即可，但是某些情况下是需要包含代码的，比如可以使用<code>__init__.py</code>来自动加载子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from . import jpg</div><div class="line">from . import png</div></pre></td></tr></table></figure>
<p>这样只需要一句单独的<code>import graphics.formats</code>就可以导入jpg和png模块了</p>
<h1 id="对所有符号的导入进行精确控制"><a href="#对所有符号的导入进行精确控制" class="headerlink" title="对所有符号的导入进行精确控制"></a>对所有符号的导入进行精确控制</h1><p>在模块中定义一个变量<code>__all__</code>，用来显式列出可以导出的符号名，一般也不这么做。</p>
<h1 id="用相对名称来导入包中的子模块"><a href="#用相对名称来导入包中的子模块" class="headerlink" title="用相对名称来导入包中的子模块"></a>用相对名称来导入包中的子模块</h1><p>在软件包中的子模块中导入同一个包中其他的子模块，使用相对名称来导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from . import grok</div><div class="line">from ..B import bar</div></pre></td></tr></table></figure>
<p>也可以使用给出完整的绝对名称来导入<code>from mypackage.A import grok</code></p>
<p>使用相对导入会好一点，但是不允许跳出定义包的那个目录，另外使用相对导入必须模块位于一个合适的包中才可以，<strong><em>位于脚本顶层目录的模块不能使用相对导入，并且如果包的某个部分是直接以脚本形式执行的，这种情况也不能使用相对导入</em></strong></p>
<p>但是可以使用<code>-m</code>选项使得相对导入可以正常工作<code>python -m mypackage/A/spam.py</code></p>
<h1 id="将模块分解成多个文件"><a href="#将模块分解成多个文件" class="headerlink" title="将模块分解成多个文件"></a>将模块分解成多个文件</h1><p>将模块转换为包，这样就可以分解成多个单独的文件，将模块mymodule.py替换成目录mymodule，然后每个文件中包含一个类的定义，最后在<code>__init__.py</code>中将这些文件绑定在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from .a import A</div><div class="line">from .b import B</div></pre></td></tr></table></figure>
<p>这样mypackage包就在逻辑上成为了一个单独的模块</p>
<p>但是这样做会一次性将所有需要的组件都导入进来，所以采用一种惰性导入的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def A():</div><div class="line">    from .a import A</div><div class="line">    return A()</div><div class="line">def B():</div><div class="line">    from .b import B</div><div class="line">    return B()</div></pre></td></tr></table></figure>
<h1 id="让各个目录下的代码在统一的命名空间下"><a href="#让各个目录下的代码在统一的命名空间下" class="headerlink" title="让各个目录下的代码在统一的命名空间下"></a>让各个目录下的代码在统一的命名空间下</h1><p>定义一个顶层的Python包，把它作为命名空间来管理大量单独维护的子模块，对于打算合并在一起的组件，这些目录中的<code>__init__.py</code>文件需要忽略</p>
<p><code>foo-package/spam/blah.py</code>和<code>bar-package/spam/grok.py</code>在这两个目录里，spam作为公共的命名空间，并且不含有<code>__init__.py</code>文件，将这两个目录都加入Python的模块查询路径中，就可以把不同的包目录合并在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">sys.path.extend([&apos;foo-package&apos;, &apos;bar-package&apos;])</div><div class="line">import spam.blah.py</div><div class="line">import spam.grok.py</div></pre></td></tr></table></figure>
<p>这里使用了命名空间包的特性，就是用来合并不同目录下的代码，把他们放在统一的命名空间下进行管理，因为没有<code>__init__.py</code>，所以解释器开始创建一个列表，然后把所有包含有这个包名的目录都囊括在内，此时就创建除了一个特殊的命名空间包模块。</p>
<h1 id="重新加载模块"><a href="#重新加载模块" class="headerlink" title="重新加载模块"></a>重新加载模块</h1><p>使用<code>imp.reload()</code>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import spam</div><div class="line">import imp</div><div class="line">imp.load(spam)</div></pre></td></tr></table></figure>
<p>这样就会使得已经导入到程序中的模块得到更新，但是<code>from module import name</code>这样语句定义的是不会更新的。所以在生产环境中应该要避免重新加载模块。</p>
<h1 id="让目录或者zip文件成为可运行的脚本"><a href="#让目录或者zip文件成为可运行的脚本" class="headerlink" title="让目录或者zip文件成为可运行的脚本"></a>让目录或者zip文件成为可运行的脚本</h1><p>如果程序已经由很多文件组成了，则可以把他们放在专属目录下，然后添加一个<code>__main__.py</code>，这样就可以在顶层目录下运行Python解释器，解释器就会把<code>__main__.py</code>作为主程序来执行，在把代码打包成zip文件也是可以执行的<code>python3 myapp.zip</code>，这个方法是一种打包规模较大的Python应用程序的可行方法</p>
<h1 id="读取包中的数据文件"><a href="#读取包中的数据文件" class="headerlink" title="读取包中的数据文件"></a>读取包中的数据文件</h1><p>读取包中的一个数据文件，因为运行的时候无法知道Python解释器的当前工作目录在哪里，所以必须得用绝对路径来读取文件，这样就太麻烦了，所以使用<code>pkgutil</code>模块来读取文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import pkgutil</div><div class="line">data = pkgutil.get_data(__package__, &apos;somedata.dat&apos;)</div></pre></td></tr></table></figure>
<p>所以无论包以什么样的形式安装到了哪里，都可以使用这个函数来获取数据文件，第一个参数是包含有包名的字符串，可以直接提供这个字符串，或者使用<code>__package__</code>，第二个参数是获取的文件相对于包的名称</p>
<h1 id="添加目录到sys-path中"><a href="#添加目录到sys-path中" class="headerlink" title="添加目录到sys.path中"></a>添加目录到<code>sys.path</code>中</h1><h2 id="PYTHONPATH环境变量添加"><a href="#PYTHONPATH环境变量添加" class="headerlink" title="PYTHONPATH环境变量添加"></a>PYTHONPATH环境变量添加</h2><p><code>env PYTHONPATH=/some/dir:/other/dir python3</code></p>
<h2 id="创建-pth文件"><a href="#创建-pth文件" class="headerlink" title="创建.pth文件"></a>创建<code>.pth</code>文件</h2><p>放在Python的其中一个site-packages目录中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/some/dir</div><div class="line">/other/dir</div></pre></td></tr></table></figure>
<p>使用<code>__file__</code>变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">from os.path import abspath, join, dirname</div><div class="line">sys.path.insert(0, abspath(dirname(&apos;__file__&apos;), &apos;src&apos;))</div></pre></td></tr></table></figure>
<h1 id="使用字符串给定的名称来导入模块"><a href="#使用字符串给定的名称来导入模块" class="headerlink" title="使用字符串给定的名称来导入模块"></a>使用字符串给定的名称来导入模块</h1><p>使用<code>importlib.import_module()</code>函数手动导入模块，这个函数会把模块对象作为结果返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import importlib</div><div class="line">math = importlib.import_module(&apos;math&apos;)</div><div class="line">math.sin(2)</div></pre></td></tr></table></figure>
<p>同时也可以实现相对导入<code>b = importlib.import_module(&#39;.b&#39;, __package__)</code></p>
<p>也可以使用内建的<code>__import__()</code>函数进行导入，但是上面的方法更容易使用些</p>
<h1 id="安装只为自己使用的包"><a href="#安装只为自己使用的包" class="headerlink" title="安装只为自己使用的包"></a>安装只为自己使用的包</h1><p>在安装命令后面添加<code>--user</code>选项即可<code>python3 setup.py install --user</code></p>
<h1 id="发布自定义的包"><a href="#发布自定义的包" class="headerlink" title="发布自定义的包"></a>发布自定义的包</h1><p>编写setup.py文件</p>
<p>distutils - Python自带的基本安装工具<code>from distutils.core import setup</code></p>
<p>下来创建<code>MANIFEST.in</code>文件，列出包含在包中的非源代码文件</p>
<p>然后<code>python3 setup.py sdist</code>创建源代码级的分发包</p>
<p>另外一个包管理工具<code>setuptools</code></p>
<p><a href="http://blog.csdn.net/pfm685757/article/details/48651389#t3" target="_blank" rel="external">http://blog.csdn.net/pfm685757/article/details/48651389#t3</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块和包是任何大型项目的核心,本文核心是如何组织包,将大型的模块分解成多个文件,以及创建命名空间包.&lt;/p&gt;
&lt;h1 id=&quot;git问题处理&quot;&gt;&lt;a href=&quot;#git问题处理&quot; class=&quot;headerlink&quot; title=&quot;git问题处理&quot;&gt;&lt;/a&gt;git问题处理
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python</title>
    <link href="http://microndgt.github.io/2017/01/07/Effective-Python/"/>
    <id>http://microndgt.github.io/2017/01/07/Effective-Python/</id>
    <published>2017-01-07T01:41:57.000Z</published>
    <updated>2017-01-27T05:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python进阶之路～</p>
<h1 id="PEP8风格指南"><a href="#PEP8风格指南" class="headerlink" title="PEP8风格指南"></a>PEP8风格指南</h1><ul>
<li>使用空格来表示缩进，而不是制表符</li>
<li>占据多行的长表达式，除了首行之外的其余各行都应该在通常的缩进级别上再加4个空格</li>
<li>函数，变量，属性应该用小写字母来拼写，各单词之前以下划线相连</li>
<li>受保护的实例属性，用单个下划线开头</li>
<li>私有的实例属性，用两个下划线开头</li>
<li>类与异常，使用每个单词首字母大写的形式命名，<code>CatCat</code></li>
<li>采用内联形式的否定词，<code>if a is not b</code></li>
<li>通过<code>if not somelist</code> or <code>if somelist</code>来对是否为空值进行检测</li>
<li>如果以相对名称来编写import语句，<code>from . import foo</code></li>
<li>import顺序，标准库，第三方模块，自用模块，按字母排序</li>
</ul>
<h1 id="bytes-str与unicode的区别"><a href="#bytes-str与unicode的区别" class="headerlink" title="bytes, str与unicode的区别"></a>bytes, str与unicode的区别</h1><p>Python3有两种表示字符序列的类型，bytes和str，前者包含原始的8位值，后者实例包含Unicode字符</p>
<p>要想把Unicode字符转换成二进制数据，使用encode方法，想将二进制数据转换成Unicode字符，使用decode方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;&apos;€20&apos;.encode(&apos;iso-8859-15&apos;)</div><div class="line">b&apos;\xa420&apos;</div><div class="line">&gt;&gt;&gt; b&apos;\xa420&apos;.decode(&apos;iso-8859-15&apos;)</div><div class="line">&apos;€20&apos;</div></pre></td></tr></table></figure>
<p>程序的核心部分使用Unicode字符类型，外部进行解码编码操作</p>
<p>创建两个函数，切换字符类型，使得转换后的数据符合开发者的预期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def to_str(bytes_or_str):</div><div class="line">    if isinstance(bytes_or_str, bytes):</div><div class="line">        value = bytes_or_str.decode(&apos;utf-8&apos;)</div><div class="line">    else:</div><div class="line">        value = bytes_or_str</div><div class="line">    return value</div><div class="line">def to_bytes(bytes_or_str):</div><div class="line">    if isinstance(bytes_or_str, str):</div><div class="line">        value = bytes_or_str.encode(&apos;utf-8&apos;)</div><div class="line">    else:</div><div class="line">        value = bytes_or_str</div><div class="line">    return value</div></pre></td></tr></table></figure>
<p>在Python3中，str和bytes永远不会等价，另外通过内置的open函数获取了函数句柄，那么该句柄酒会采用默认的utf-8编码格式操作文件，而在Python2中默认编码格式是二进制形式，所以写入或者读取二进制数据使用<code>wb</code> or <code>rb</code>模式</p>
<blockquote>
<p>2016-12-18 12:00</p>
</blockquote>
<h1 id="用辅助函数来取代复杂的表达式"><a href="#用辅助函数来取代复杂的表达式" class="headerlink" title="用辅助函数来取代复杂的表达式"></a>用辅助函数来取代复杂的表达式</h1><p><code>red = int(my_values.get(&#39;red&#39;, [&#39;&#39;])[0] or 0)</code></p>
<p>这种写法过于复杂，可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">red = my_values.get(&apos;red&apos;, [&apos;&apos;])</div><div class="line">red = int(red[0]) if red[0] else 0</div></pre></td></tr></table></figure>
<p>但是还可以写成辅助函数，这样可以通用，如果频繁使用这种逻辑，那么更应该这么做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def get_first_int(values, key, default=0):</div><div class="line">    found = values.get(key, [&apos;&apos;])</div><div class="line">    if found[0]:</div><div class="line">        found = int(found[0])</div><div class="line">    else:</div><div class="line">        found = default</div><div class="line">    return found</div></pre></td></tr></table></figure>
<p>如果表达式变的比较复杂，那么就应该考虑将其拆成小块，并且把这些逻辑移入辅助函数中，让代码更加易读。</p>
<p>使用if/else表达式，要比or或者and这样的boolean表达式更加清晰。</p>
<h1 id="切割序列的方法"><a href="#切割序列的方法" class="headerlink" title="切割序列的方法"></a>切割序列的方法</h1><p>切割列表的时候，start或者end索引越界也不会出现问题，<code>first_twenty_items = a[:20]</code>或者<code>last_twenty_items = a[-20:]</code></p>
<p>对原列表进行切割之后，会产生另外一份全新的列表，在切割后得到的新列表上进行修改，不会影响原来列表，当然如果列表中含有可变元素，则除外。</p>
<p>在赋值的时候对左侧列表使用切割操作，会把该列表处在指定范围内的对象替换为新值。列表会根据新值的个数相应的扩张或者收缩。</p>
<p><code>a[2:7] = [99, 22, 14]</code></p>
<p>这样就将5个元素变成了3个元素</p>
<p><code>a[:] = [101, 102, 103]</code></p>
<p>这样会用右侧的新值复制一份，替换左侧列表全部内容，但是不会重新分配新的列表。</p>
<h1 id="单次切片操作内，不要同时指定start-end和stride"><a href="#单次切片操作内，不要同时指定start-end和stride" class="headerlink" title="单次切片操作内，不要同时指定start,end和stride"></a>单次切片操作内，不要同时指定start,end和stride</h1><p>常见技巧，把从字节形式存储的字符串反转过来，<code>x[::-1]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">w = &apos;谢谢&apos; # unicode字符</div><div class="line">x = w.encode(&apos;utf-8&apos;) # 编码成二进制数据</div><div class="line">y = x[::-1] # 反转</div><div class="line">z = y.decode(&apos;utf-8&apos;) # 解码成unicode字符</div><div class="line"># 会出现错误</div></pre></td></tr></table></figure>
<p>尽量使用stride为正数，且不带start或者end索引的切割操作，尽量避免使用负数做stride</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 可以多次切割</div><div class="line">b = a[::2]</div><div class="line">c = b[1:-1]</div></pre></td></tr></table></figure>
<h1 id="用列表推导来取代map和filter"><a href="#用列表推导来取代map和filter" class="headerlink" title="用列表推导来取代map和filter"></a>用列表推导来取代map和filter</h1><p><code>even_squares = [x**2 for x in a if x % 2 == 0]</code></p>
<p>也可以使用map和filter</p>
<p><code>alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))</code></p>
<p>字典推导式</p>
<p><code>rank_dict = {rank: name for name, rank in chile_ranks.item()}</code></p>
<h1 id="使用生成器表达式来改写数据量较大的列表推导"><a href="#使用生成器表达式来改写数据量较大的列表推导" class="headerlink" title="使用生成器表达式来改写数据量较大的列表推导"></a>使用生成器表达式来改写数据量较大的列表推导</h1><p>比如在这种情况，文件特别大或者网络传输中，列表推导就会出现问题，所以使用生成器表达式，对列表推导和生成器的一种泛化，生成一个迭代器，每次可以根据生成器表达式产生一项数据。</p>
<p>对生成器表达式求值的时候，会立刻返回一个迭代器，而不会深入处理文件中的内容。</p>
<p><code>it = (len(x) for x in open(filename))</code></p>
<p>以迭代器为参数，逐次调用内置的next函数，可以按照生成器表达式输出下一个值，可以多次命令迭代器根据生成器表达式来生成新值。</p>
<p><code>print(next(it))</code></p>
<p>如果操作大批量数据，最好是使用生成器表达式来实现，生成器表达式返回的迭代器是有状态的，不能反复使用。</p>
<h1 id="尽量使用enumerate代替range"><a href="#尽量使用enumerate代替range" class="headerlink" title="尽量使用enumerate代替range"></a>尽量使用enumerate代替range</h1><p>enumerate可以把各种迭代器包装成生成器，以便产生输出值，生成器每次产生一对输出值，前者表示循环下标，后者表示从迭代器中获取到的下一个序列元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i, ele in enumerate(range(5)):</div><div class="line">    print(&quot;%d %d&quot; % (i + 1, ele))</div></pre></td></tr></table></figure>
<p>enumerate第二个参数指定函数开始计数使用的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i, ele in enumerate(range(5), 1):</div><div class="line">    print(&quot;%d %d&quot; % (i, ele))</div></pre></td></tr></table></figure>
<h1 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h1><p>python3中的zip函数，可以把两个或者两个以上的迭代器封装成生成器，以便稍后求值，zip生成器会从每个迭代器中获取该迭代器的下一个值，然后把这些值汇聚成元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">max_letters = 0</div><div class="line">for name, count in zip(names, letters):</div><div class="line">    if count &gt; max_letters:</div><div class="line">        longest_name = name</div><div class="line">        max_letters = count</div></pre></td></tr></table></figure>
<p>只要有一个序列耗尽，zip就不会产生元组了。Python2中zip是直接把这些元组完全生成好，一次性的返回整份列表。</p>
<blockquote>
<p>2017-1-4 22:47</p>
</blockquote>
<h1 id="for和while循环后面的else块"><a href="#for和while循环后面的else块" class="headerlink" title="for和while循环后面的else块"></a>for和while循环后面的else块</h1><p>在循环里用break语句跳出，会导致程序不执行else块</p>
<p>写成辅助函数更好，有两种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def coprime(a, b):</div><div class="line">    for i in range(2, min(a, b) + 1):</div><div class="line">        if a % i == 0:</div><div class="line">            return False</div><div class="line">    return True</div></pre></td></tr></table></figure>
<p>另外一种是实用变量来记录参数是否符合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def coprime2(a, b):</div><div class="line">    is_coprime = True</div><div class="line">    for i in range(2, min(a, b) + 1):</div><div class="line">        if a % i == 0:</div><div class="line">            is_coprime = False</div><div class="line">            break</div><div class="line">    return is_coprime</div></pre></td></tr></table></figure>
<p>当整个循环主体都没有遇到break语句的时候，循环后面的else块才会被执行</p>
<h1 id="合理使用try-except-else-finally"><a href="#合理使用try-except-else-finally" class="headerlink" title="合理使用try/except/else/finally"></a>合理使用try/except/else/finally</h1><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>既要将异常向上传播，又要在异常发生的时候执行清理工作，try/finally结构，可以确保程序可靠的关闭文件句柄</p>
<h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><p>try没有发生异常，就执行else块，有了else块，就可以缩减try块内的代码量，使其易读，并且明确try中的内容，使得异常传播更加清晰，把没有发生异常所要执行的语句和try/except隔开</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">UNDEFINED = object()</div><div class="line">def divide_json(path):</div><div class="line">    handle = open(path, &apos;r+&apos;)</div><div class="line">    try:</div><div class="line">        data = handle.read()</div><div class="line">        op = json.loads(data)</div><div class="line">        value = (</div><div class="line">            op[&apos;numerator&apos;] /</div><div class="line">            op[&apos;denominator&apos;])</div><div class="line">    except ZeroDivisionError as e:</div><div class="line">        return UNDEFINED</div><div class="line">    else:</div><div class="line">        op[&apos;result&apos;] = value</div><div class="line">        result = json.dumps(op)</div><div class="line">        handle.seek(0)</div><div class="line">        handle.write(result)</div><div class="line">        return value</div><div class="line">    finally:</div><div class="line">        handle.close()</div></pre></td></tr></table></figure>
<h1 id="尽量用异常来表示特殊情况，而不是返回None"><a href="#尽量用异常来表示特殊情况，而不是返回None" class="headerlink" title="尽量用异常来表示特殊情况，而不是返回None"></a>尽量用异常来表示特殊情况，而不是返回None</h1><p>因为None和空值，0都属于False，但是None产生的原因比较特殊，所以不要直接返回None，而是说明产生这种情况的原因，或者表示操作是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def divide(a, b):</div><div class="line">    try:</div><div class="line">        return True, a / b</div><div class="line">    except ZeroDivisionError:</div><div class="line">        return False, None</div></pre></td></tr></table></figure>
<p>另外一种方法就是不返回None，而是将异常抛给上一级，这样没有异常，则返回值正常，否则处理异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def divide(a, b):</div><div class="line">    try:</div><div class="line">        return a / b</div><div class="line">    except ZeroDivisionError:</div><div class="line">        raise ValueError(&apos;Invalid inputs&apos;) from e</div></pre></td></tr></table></figure>
<h1 id="用super初始化父类"><a href="#用super初始化父类" class="headerlink" title="用super初始化父类"></a>用super初始化父类</h1><blockquote>
<p>2016-1-7 9:32</p>
</blockquote>
<p>初始化父类的传统方式，是在子类里用子类实例直接调用父类的<code>__init__</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class MyBaseClass(object):</div><div class="line">    def __init__(self, value):</div><div class="line">        self.value = value</div><div class="line">class MyChildClass(MyBaseClass):</div><div class="line">    def __init__(self):</div><div class="line">        MyBaseClass.__init__(self, 5)</div></pre></td></tr></table></figure>
<p>但是如果子类受到了多重继承的影响，那么直接调用超类的<code>__init__</code>方法，那么可能会产生无法预知的行为，还有一个问题就是它的调用顺序并不固定</p>
<p>还有一个问题是菱形继承中，子类继承自两个单独的超类，那两个超类又继承自同一个公共基类，这种继承会使得公共基类多次执行其<code>__init__</code>方法</p>
<p>super函数，定义了方法解析顺序MRO，MRO以标准的流程来安排超类之间的初始化顺序，保证钻石顶部的公共基类的方法只会运行一次。</p>
<p>Python 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class TimesFiveClass(MyBaseClass):</div><div class="line">    def __init__(self, value):</div><div class="line">        super(TimesFiveClass, self).__init__(value)</div><div class="line">        self.value *= 5</div><div class="line">class PlusTwoClass(MyBaseClass):</div><div class="line">    def __init__(self, value):</div><div class="line">        super(PlusTwoClass, self).__init__(value)</div><div class="line">        self.value += 2</div><div class="line">class GoodWay(TimesFiveClass, PlusTwoClass):</div><div class="line">    def __init__(self, value):</div><div class="line">        super(GoodWay, self).__init__(value)</div></pre></td></tr></table></figure>
<p>程序的运行顺序会与GoodWay类的MRO保持一致，这个MRO可以通过名为mro的类方法来查询 <code>pprint(GoodWay.mro())</code></p>
<p>Python 3提供了不带参数的super调用方式，或者Python3可以在方法中通过<code>__class__</code>变量准确的引用当前类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class GoodWay(TimesFiveClass, PlusTwoClass):</div><div class="line">    def __init__(self, value):</div><div class="line">        super(__class__, self).__init__(value)</div><div class="line">class GoodWay(TimesFiveClass, PlusTwoClass):</div><div class="line">    def __init__(self, value):</div><div class="line">        super().__init__(value)</div></pre></td></tr></table></figure>
<h1 id="继承collections-abc以实现自定义的容器类型"><a href="#继承collections-abc以实现自定义的容器类型" class="headerlink" title="继承collections.abc以实现自定义的容器类型"></a>继承collections.abc以实现自定义的容器类型</h1><p>Python中的每一个类，从某种程度上来说都是容器，它们都封装了属性和功能。如果要设计用法比较简单的序列，那么我们可以直接继承Python内置的list类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class FrequencyList(list):</div><div class="line">    def __init__(self, members):</div><div class="line">        super().__init__(members)</div><div class="line">    def frequency(self):</div><div class="line">        counts = &#123;&#125;</div><div class="line">        for item in self:</div><div class="line">            counts.setdefault(item, 0)</div><div class="line">            counts[item] += 1</div><div class="line">        return counts</div></pre></td></tr></table></figure>
<p>如果有这种类，本身不属于list子类，但是可以通过特殊方法来加入序列类型的功能，Python会使用名称比较特殊的实例方法，来实现与容器有关的行为。</p>
<p>比如<code>__getitem__</code>，<code>__len__</code>，这样就需要编写大量的特殊方法</p>
<p>所以可以使用内置的collections.abc模块，该模块定义了一系列的抽象基类，提供了每一种容器类型所应具备的常用方法，如果子类已经实现了抽象基类所要求的每一个方法，那么基类就会自动提供剩下的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from collections.abc import Sequence</div><div class="line">class test(Sequence):</div><div class="line">   pass</div></pre></td></tr></table></figure>
<h1 id="在重视精确度的场合，应该使用decimal"><a href="#在重视精确度的场合，应该使用decimal" class="headerlink" title="在重视精确度的场合，应该使用decimal"></a>在重视精确度的场合，应该使用decimal</h1><p>Decimal类默认提供28个小数位，以进行定点数学计算。其提供了一个内置函数，可以按照开发者要求的精度和舍入方式，来准确的调整数值。</p>
<p><code>rounded = cost.quantize(Decimal(&#39;0.01&#39;), rounding=ROUND_UP)</code></p>
<p>但是它在精确度方面仍然有局限，如果要用精度不受限制的方式来表达有理数，那么可以考虑使用Fraction类，在内置的fractions模块中。</p>
<h1 id="为每个函数，类和模块编写文档字符串"><a href="#为每个函数，类和模块编写文档字符串" class="headerlink" title="为每个函数，类和模块编写文档字符串"></a>为每个函数，类和模块编写文档字符串</h1><p>使用文档生成工具，Sphinx将纯文本转换成HTML等更友好的格式。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>第一行，描述本模块内容</p>
<p>第二行，细节信息，本模块的操作有关的内容，告诉模块的使用者，可以在模块的docstring中，强调模块里面比较重要的类和函数</p>
<p>如果模块是一个命令行工具，那么可以把工具的用法，写在docstring里面</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>第一行，类的用途</p>
<p>第二行，类的操作方式</p>
<p>类中比较重要的属性和方法，public，在此加以强调，另外，还要告诉子类的实现者，如何才能正确的与protected属性以及超类方法相交互。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>第一行，本函数功能</p>
<p>第二行，描述函数具体行为，然后是函数的参数，返回值，函数出现的异常也应该解释</p>
<h1 id="用包来安排模块，并提供稳固的API"><a href="#用包来安排模块，并提供稳固的API" class="headerlink" title="用包来安排模块，并提供稳固的API"></a>用包来安排模块，并提供稳固的API</h1><p>模块数量过多的时候，需要在程序之中引入一种抽象层，使得代码更加便于理解，包，一种含有其它模块的模块。</p>
<p>在目录中放入<code>__init__.py</code>的空文件，来定义包，只要目录里有这个文件，我们就可以采用相对该目录的路径，来引用目录中的其它Python文件。</p>
<p><code>from mypackage import utils</code></p>
<p>使用as子句，给引入当前作用域的属性重新起名字，<code>import pandas as pd</code></p>
<p>python包的第二种用途，是为外部使用者提供严谨而稳固的API，使用<code>__all__</code>属性</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python进阶之路～&lt;/p&gt;
&lt;h1 id=&quot;PEP8风格指南&quot;&gt;&lt;a href=&quot;#PEP8风格指南&quot; class=&quot;headerlink&quot; title=&quot;PEP8风格指南&quot;&gt;&lt;/a&gt;PEP8风格指南&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用空格来表示缩进，而不是制表符&lt;/li&gt;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>群体性孤独</title>
    <link href="http://microndgt.github.io/2017/01/05/%E7%BE%A4%E4%BD%93%E6%80%A7%E5%AD%A4%E7%8B%AC/"/>
    <id>http://microndgt.github.io/2017/01/05/群体性孤独/</id>
    <published>2017-01-05T10:52:38.000Z</published>
    <updated>2017-01-27T05:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>you will rock!</code> 网易公开课</p>
<p>Along Together</p>
<p>Hiding from each other</p>
<p>Goldilocks effect: not too close, not too far, just right</p>
<p>let us present the self as we want to be</p>
<p>I’m thinking about you</p>
<p>No one is listening</p>
<p>we expect more from technology and less from each other</p>
<p>technology appeals to us most where we are most vulnerable</p>
<p>we’re lonely but we’re afraid of intimacy</p>
<p>the illusion of companionship without the demands of friendship</p>
<p>being alone feels like a problem that needs to be solved</p>
<p>i share therefore i am</p>
<p>isolation</p>
<p>you end up isolated if you don’t cultivate the capacity for solitude, the ability to be seperate to gather yourself.</p>
<p>if we don’t teach our children to be alone, they will only know how to be lonely.</p>
<p>time to talk.</p>
<p>start thinking of solitude as a good thing make room for it.</p>
<p>conversation talk</p>
<p>we all really need to listen to each other, including to the boring bits.</p>
<p>Finally, love your friends, love your body, love your life.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;you will rock!&lt;/code&gt; 网易公开课&lt;/p&gt;
&lt;p&gt;Along Together&lt;/p&gt;
&lt;p&gt;Hiding from each other&lt;/p&gt;
&lt;p&gt;Goldilocks effect: not too close, not too fa
    
    </summary>
    
      <category term="公开课" scheme="http://microndgt.github.io/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="TED" scheme="http://microndgt.github.io/tags/TED/"/>
    
      <category term="笔记" scheme="http://microndgt.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSDB使用笔记</title>
    <link href="http://microndgt.github.io/2017/01/05/SSDB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://microndgt.github.io/2017/01/05/SSDB使用笔记/</id>
    <published>2017-01-05T06:10:00.000Z</published>
    <updated>2017-01-27T05:27:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>ssdb是工作要使用到的一个数据库，记录一下安装步骤以及常用用法。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://github.com/ideawu/ssdb/archive/master.zip</div><div class="line">unzip master</div><div class="line">cd ssdb-master</div><div class="line">make</div></pre></td></tr></table></figure>
<p>这时报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ERROR! autoconf required! install autoconf first</div><div class="line"></div><div class="line">Makefile:4: build_config.mk: No such file or directory</div><div class="line">make: *** No rule to make target `build_config.mk&apos;.  Stop.</div></pre></td></tr></table></figure>
<p>安装<code>autoconf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install autoconf</div></pre></td></tr></table></figure>
<p>安装完成后继续编译</p>
<p><code>make &amp;&amp; make install</code></p>
<p>然后启动ssdb服务，<code>-d</code>是deamon模式，服务后台运行</p>
<p><code>./ssdb-server -d ./ssdb.conf</code></p>
<p>使用ssdb数据库</p>
<p><code>./tools/ssdb-cli -h localhost -p 8888</code></p>
<p>关闭数据库</p>
<p><code>./ssdb-server ./ssdb.conf -s stop</code></p>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>字符串类型<code>s</code>，列表类型<code>q</code>，哈希类型<code>h</code>，有序集合类型<code>z</code></p>
<p>数据库存在哪些键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keys 字符串类型</div><div class="line">qlist 列表类型</div><div class="line">hlist 哈希类型</div><div class="line">zlist 有序集合类型</div></pre></td></tr></table></figure>
<p>前两个参数用于确定键的范围，第三个参数用于返回最大个数，为必需参数。<code>keys &#39;&#39; &#39;&#39; 10</code></p>
<h1 id="使用pyssdb"><a href="#使用pyssdb" class="headerlink" title="使用pyssdb"></a>使用pyssdb</h1><p>在PyCharm中安装pyssdb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c = pyssdb.Client()</div><div class="line">print(c.hgetall(&apos;logasset_10005050&apos;))</div><div class="line">print(c.hget(&apos;logasset_10005050&apos;, &apos;20160102&apos;))</div></pre></td></tr></table></figure>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>qpush_front name item1 item2...</code></p>
<p><code>qpush_back name item1 item2...</code></p>
<p><code>qpush name item1 item2...</code></p>
<p><code>qpop_front name size</code> pop out one or more elements from the head of a queue</p>
<p><code>qpop_back name size</code> pop out one or more elements from the tail of a queue</p>
<p><code>qfront name</code> return the first element of a queue</p>
<p><code>qback name</code> return the last element of a queue</p>
<p><code>qget name index</code> return the element a the specified index</p>
<p><code>qrange name offset limit</code> returns a portion of elements from the queue at the specified range[offset, offset+limit]</p>
<p><code>qlist name_start name_end limit</code> list names in range(name_start, name_end)</p>
<p><code>qslice name begin end</code> returns a portion of elements from the queue at the specified range[begin,end]</p>
<h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><p><code>hset name key value</code> set the string value in argument as value of the key of a hashmap</p>
<p><code>hget name key</code> get the value related to the specified key of a hashmap</p>
<p><code>hexists name key</code> verify if the specified key exists in a hashmap</p>
<p><code>hsize name</code> return the number of key-value pairs in the hashmap</p>
<p><code>hkeys name key_start key_end</code> list keys of a hashmap in range(key_start, key_end)</p>
<p><code>hgetall name</code> returns the whole hash, as an array of strings indexed by strings</p>
<p><code>hscan name key_start key_end limit</code> list key-value pairs of a hashmap with keys in range(key_start, key_end)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ssdb是工作要使用到的一个数据库，记录一下安装步骤以及常用用法。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="http://microndgt.github.io/categories/NoSQL/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://microndgt.github.io/2016/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://microndgt.github.io/2016/12/15/数据结构与算法/</id>
    <published>2016-12-15T13:56:38.000Z</published>
    <updated>2017-01-27T05:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>线性表</p>
<h1 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h1><p>事后统计方法: 利用计时器进行比较，需要事先编制测试程序</p>
<p>事前分析估算: 依据统计方法对算法进行估算</p>
<p>所耗时间取决以下因素:算法的好坏与问题的输入规模</p>
<p>算法复杂度侧重研究算法随着输入规模扩大增长量的一个抽象，不计那些循环索引的递增和循环终止条件，变量声明，打印结果的操作，重要的是把基本操作的数量和输入模式相关联起来。</p>
<p>函数的渐进增长: n&gt;N时候，总有f(n)&gt;g(n)，说明f(n)增长渐进快于g(n)</p>
<p>判断算法效率时候，主要关注主项的阶数</p>
<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><p>分析语句总执行次数T(n)随n的变化并确定T(n)的数量级，算法的时间复杂度，就是算法的时间量度，T(n)=O(f(n))，表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度。</p>
<p>大O记法，O(1),O(n),O(n^2)</p>
<p><strong>分析一个算法的时间复杂度</strong></p>
<ul>
<li>用常数1取代运行时间中所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>
<li>得到最后结果就是大O阶</li>
</ul>
<p>常数阶。线性阶，一般是非嵌套循环。平方阶，嵌套循环。</p>
<p>对数阶，假设x个2相乘可以等于100，退出循环，所以2^x = n得x=log(2)n，所以循环时间复杂度是O(logn)，x相当于执行次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 1, n = 100;</div><div class="line">while(i &lt; n)&#123;</div><div class="line">	i = i * 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>nlogn阶，立方阶，指数阶。</p>
<p>1 &lt; logn &lt; n &lt; nlogn &lt; n2 &lt; n3 &lt; 2^n &lt; n! &lt; n^n</p>
<p>计算总的执行次数～主要是数列的相对运算</p>
<h2 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h2><p>平均运行时间是期望的运行时间，最坏运行时间是一种保证，一般提到的运行时间都是最坏情况的运行时间。</p>
<h1 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h1><p>空间换取时间</p>
<p>空间复杂度通过计算算法所需要的存储空间实现，S(n)=O(f(n))，其中n为问题的规模，f(n)是语句关于n所占存储空间的函数</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><blockquote>
<p>2016-11-29 16:38</p>
</blockquote>
<p>0个或者多个数据元素组成的有限序列</p>
<p>线性关系的条件是如果存在多个元素，则<strong>第一个元素舞前驱，最后一个元素无后继，其它元素都有且只有一个前驱和后继</strong></p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称，如整型，浮点型，字符型</p>
<p>多钟数据类型适合不同的计算条件差异</p>
<p>ADT指在一个数据模型及定义在该模型上的一组操作，定义仅取决于它的一组逻辑特性。在于数据类型的数学抽象特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ADT 抽象数据类型名</div><div class="line">Data</div><div class="line">	数据元素之间逻辑关系的定义</div><div class="line">Operation</div><div class="line">	操作</div><div class="line">endADT</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-1 20:56:21</p>
</blockquote>
<h1 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h1><p>两种物理存储结构，顺序存储结构和链式存储结构</p>
<p>顺序存储结构，类似于数组，但是这里是物理结构，在内存空间中，依次存放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXSIZE 20</div><div class="line">typedef int ElemType;</div><div class="line">typedef struct&#123;</div><div class="line">	ElemType data[MAXSIZE];</div><div class="line">	int length;</div><div class="line">&#125; Sqlist;//将结构体类型用Sqlist别名代替</div></pre></td></tr></table></figure>
<p>封装需要三个属性：</p>
<ul>
<li>存储空间的起始位置 data数组</li>
<li>线性表的最大存储容量 MAXSIZE</li>
<li>线性表的当前长度 length</li>
</ul>
<p>可以随时计算出线性表的任意位置的地址，存储时间性能为O(1)，为随机存储结构</p>
<h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><p>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置，将要插入的元素填入位置i处，线性表长度＋1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int ListInsert(Sqlist *L, int i, ElemType e)&#123;</div><div class="line">	int k;</div><div class="line">	if(L-&gt;length == MAXSIZE || i &lt; 1)&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	if(i &lt;= L-&gt;length)&#123;//数组是0开始，线性表是1开始。。。</div><div class="line">		for(k=L-&gt;length-1; k&gt;=i-1;k--)&#123;</div><div class="line">			L-&gt;data[k+1] = L-&gt;data[k];</div><div class="line">		&#125;</div><div class="line">	&#125;//另一种情况就不需要考虑，直接插入</div><div class="line">	L-&gt;data[i-1] = e;</div><div class="line">	L-&gt;length++;</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><ul>
<li>删除位置不合理或者表长为0，抛出异常</li>
<li>取出删除元素</li>
<li>删除元素位置遍历到最后一个元素位置，分别将其向前移动一个位置。</li>
<li>表长减一</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int ListDelete(Sqlist *L, int i, ElemType *e)&#123;</div><div class="line">	if(L-&gt;length == 0 || i&lt;1 || i&gt;L-&gt;length)&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	*e = L-&gt;data[i-1];</div><div class="line">	if(i&lt;L-&gt;length)&#123;</div><div class="line">		for(;i&lt;L-&gt;length;i++)&#123;</div><div class="line">			L-&gt;data[i-1] = L-&gt;data[i];</div><div class="line">		&#125;</div><div class="line">	&#125;//另外一种情况只需要将表长减一</div><div class="line">	L-&gt;length--;</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最坏情况的时间复杂度是O(n)</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>存和读的时候时间复杂度是O(1)，插入或者删除的时候是O(n)</p>
<p>适合元素个数比较稳定，不经常插入和删除元素的应用。</p>
<ul>
<li>无须为表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速存取表中的任意位置的元素</li>
<li>插入和删除需要移动大量元素</li>
<li>线性表长度变化较大的时候，难以确定存储空间的容量</li>
<li>容易造成存储空间的碎片</li>
</ul>
<h1 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h1><blockquote>
<p>2016-12-05 20:33</p>
</blockquote>
<p>任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。除了存储数据元素信息外，还要存储它的后继元素的存储地址。</p>
<p>n个结点链接成一个链表，线性表的链式存储结构，每个结点中只包含一个指针域，单链表。</p>
<h2 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h2><p>头指针是指链表指向第一个结点的指针，如果链表有头结点，则是指向头结点的指针。</p>
<p>头指针是链表的必要元素</p>
<p>头结点是放在第一个元素结点之前，其数据域一般无意义。</p>
<p>有了头结点，对第一个元素前插入结点和删除第一个结点操作与其他结点的操作就统一了。</p>
<h2 id="单链表存储结构"><a href="#单链表存储结构" class="headerlink" title="单链表存储结构"></a>单链表存储结构</h2><p>使用结构指针来描述单链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//Node类型</div><div class="line">typedef struct Node&#123;</div><div class="line">	ElemType data;</div><div class="line">	struct Node *Next;//指向该结点类型的指针</div><div class="line">&#125;Node;</div><div class="line">//指针类型</div><div class="line">typedef struct Node* LinkList;</div></pre></td></tr></table></figure>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>核心思想是 <strong>工作指针后移</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int getElem(LinkList L, int i, ElemType *e)&#123;</div><div class="line">	int j;</div><div class="line">	LinkList p;</div><div class="line">	p = L-&gt;next;</div><div class="line">	j = 1;</div><div class="line">	while(p &amp;&amp; j&lt;i)&#123;</div><div class="line">		p = p-&gt;next;</div><div class="line">		++j;</div><div class="line">	&#125;</div><div class="line">	if(!p || j &gt; i)&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	*e = p-&gt;data;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int ListInsert(LinkList *L, int i, ElemType e)&#123;</div><div class="line">	int j;</div><div class="line">	LinkList p, s;</div><div class="line">	p = *L;</div><div class="line">	j = 1;</div><div class="line">	//寻找第i个结点</div><div class="line">	while(p &amp;&amp; j &lt; i)&#123;</div><div class="line">		p = p-&gt;next;</div><div class="line">		j++;</div><div class="line">	&#125;</div><div class="line">	if (!p || j&gt;i)&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	s = (LinkList)malloc(sizeof(Node));</div><div class="line">	s-&gt;data = e;</div><div class="line">	s-&gt;next = p-&gt;next;</div><div class="line">	p-&gt;next = s;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int ListDelete(LinkList *L, int i, ElemType *e)&#123;</div><div class="line">	int j;</div><div class="line">	LinkList p, q;</div><div class="line">	p = *L;</div><div class="line">	j = 1;</div><div class="line">	//p是删除前的一个元素</div><div class="line">	while(p-&gt;next &amp;&amp; j&lt;i)&#123;</div><div class="line">		p = p-&gt;next;</div><div class="line">		++j;</div><div class="line">	&#125;</div><div class="line">	if (!(p-&gt;next) || j&gt;i)&#123;</div><div class="line">		return -1;</div><div class="line">	&#125;</div><div class="line">	q = p-&gt;next;</div><div class="line">	p-&gt;next = q-&gt;next;</div><div class="line">	*e = q-&gt;data;</div><div class="line">	free(q);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>首先遍历查找第i个元素，然后实现插入和删除，时间复杂度是O(n)</p>
<p>对于插入或者删除数据越频繁的操作，单链表的效率优势就越明显</p>
<blockquote>
<p>2016-12-06 20:34</p>
</blockquote>
<h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>从空表的初始状态起，依次建立各个元素结点并逐个插入链表。</p>
<ul>
<li>声明结点p和计数器变量i</li>
<li>初始化空链表L</li>
<li>L的头结点的指针指向NULL</li>
<li>循环实现后继结点的赋值和插入</li>
</ul>
<h2 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h2><p>将新结点插入到当前链表的表头上，直到结束，表头的第一个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void CreateListHead(LinkList *L, int n)&#123;</div><div class="line">	//指针的指针</div><div class="line">	LinkList p;</div><div class="line">	int i;</div><div class="line">	*L = (LinkList)malloc(sizeof(Node));</div><div class="line">	(*L)-&gt;next = NULL;</div><div class="line">	for(i = 0;i&lt;n; i++)&#123;</div><div class="line">		p = (LinkList)malloc(sizeof(Node)):</div><div class="line">		p-&gt;data = 1;</div><div class="line">		p-&gt;next = (*L)-&gt;next;</div><div class="line">		(*L)-&gt;next = p;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h2><p>有一个指向最后一个结点的指针r</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void CreateListTail(LinkList *L, int n)&#123;</div><div class="line">	LinkList p, r;</div><div class="line">	int i;</div><div class="line">	*L = (LinkList)malloc(sizeof(Node));</div><div class="line">	r = *L; //r指向最后一个元素</div><div class="line">	for(i = 0; i &lt; n; i++)&#123;</div><div class="line">		p = (LinkList)malloc(sizeof(Node));</div><div class="line">		p-&gt;data = 0;</div><div class="line">		r-&gt;next = p;</div><div class="line">		r = p;</div><div class="line">	&#125;</div><div class="line">	r-&gt;next = NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-9 23:56</p>
</blockquote>
<h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><ul>
<li>声明结点p，q</li>
<li>第一个结点赋值给p，下一个结点赋值给q</li>
<li>循环执行释放p和将q赋值给p的操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int ClearList(LinkList *L)&#123;</div><div class="line">    LinkList p, q;</div><div class="line">    p = (*L)-&gt;next;</div><div class="line">    while(p)&#123;</div><div class="line">        q = p-&gt;next;</div><div class="line">        free(p);</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">    (*L)-&gt;next = NULL;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><ul>
<li>分配方式</li>
</ul>
<p>顺序存储结构使用一段连续的存储单元依次存储线性表的数据元素</p>
<p>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</p>
<ul>
<li>时间性能</li>
</ul>
<p>查找，顺序存储结构为O(1),单链表是O(n)</p>
<p>插入和删除，顺序存储结构是O(n),单链表在计算出某位置的指针后，时间为O(1)</p>
<ul>
<li>空间性能</li>
</ul>
<p>顺序存储结构可能溢出或者空间浪费，产生碎片</p>
<p>单链表可以随时分配内存空间</p>
<ul>
<li>所以</li>
</ul>
<p>如果线性表需要频繁查找，很少进行插入和删除操作，宜采用顺序存储结构</p>
<p>如果频繁插入，宜采用单链表结构</p>
<blockquote>
<p>2016-12-11 00:45</p>
</blockquote>
<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>数组代替指针来描述单链表，用游标实现的</p>
<p>数组第一个下标0的游标指向第一个没有元素的下标，备用链表的第一个结点的下标。最后一个元素的游标指向第一个有元素的下标，相当于单链表中的头结点作用，其data不存放数据</p>
<p>未使用的数组元素称为备用链表</p>
<ul>
<li>线性表的静态链表存储结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define MAXSIZE 1000</div><div class="line">typedef struct&#123;</div><div class="line">    ElemType data;</div><div class="line">    int cur;</div><div class="line">&#125;Component, StaticLinkList[MAXSIZE];</div><div class="line">//结构体数组别名</div></pre></td></tr></table></figure>
<ul>
<li>对静态链表进行初始化相当于初始化数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int InitList(StaticLinkList space)&#123;</div><div class="line">    int i;</div><div class="line">    for(i=0; i&lt;MAXSIZE-1; i++)&#123;</div><div class="line">        space[i].cur = i + 1;</div><div class="line">    &#125;</div><div class="line">    space[MAXSIZE - 1].cur = 0;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>静态链表的插入操作</li>
</ul>
<p>使用静态模拟动态链表结构的存储空间分配，需要时候申请，不需要时候释放</p>
<blockquote>
<p>2016-12-11 09:00</p>
</blockquote>
<p>为了辨明数组中哪些分量未被使用，解决的方法是将所有未被使用过的以及已经被删除的分量用游标链成一个备用链表，起始地址在数组的第一个元素</p>
<p>每当进行插入，从备用链表上取得第一个结点作为待插入的新结点</p>
<ul>
<li>获取空闲分量的下标</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int Malloc_SLL(StaticLinkList space)&#123;</div><div class="line">    int i = space[0].cur;</div><div class="line">    if(space[0].cur)&#123;</div><div class="line">        space[0].cur = space[i].cur;</div><div class="line">    &#125;</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>插入操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int ListInsert(StaticLinkList L, int i, ElemType e)&#123;</div><div class="line">    int j, k, l;</div><div class="line">    k = MAXSIZE - 1;</div><div class="line">    if (i &lt; 1 || i &gt; ListLength(L) + 1)&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    //返回空闲元素</div><div class="line">    j = Malloc_SLL(L);</div><div class="line">    if(j)&#123;</div><div class="line">        L[j].data = e;</div><div class="line">        //从最后一个元素开始索引</div><div class="line">        for(l = 1; l &lt;= i-1; l++)&#123;</div><div class="line">            //找到插入位置前的游标</div><div class="line">            k = L[k].cur;</div><div class="line">        &#125;</div><div class="line">        //插入元素的下一个位置</div><div class="line">        L[j].cur = L[k].cur;</div><div class="line">        //改变插入位置前元素的游标</div><div class="line">        L[k].cur = j;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-11 10:57</p>
</blockquote>
<h2 id="静态链表的删除"><a href="#静态链表的删除" class="headerlink" title="静态链表的删除"></a>静态链表的删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">int ListDelete(StaticLinkList L, int i)&#123;</div><div class="line">    int j, k;</div><div class="line">    if(i&lt;1 || i&gt;ListLength(L))&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    k = MAXSIZE - 1;</div><div class="line">    //找到要删除的前一个元素</div><div class="line">    for(j = 1; j &lt;= i -1; j++)&#123;</div><div class="line">        k = L[k].cur;</div><div class="line">    &#125;</div><div class="line">    //取得要删除的元素数组下标</div><div class="line">    j = L[k].cur;</div><div class="line">    //将删除的后一个元素游标赋给前一个元素游标</div><div class="line">    L[k].cur = L[j].cur;</div><div class="line">    Free_SLL(L, j);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Free_SLL(StaticLinkList space, int k)&#123;</div><div class="line">    space[k].cur = space[0].cur;</div><div class="line">    space[0].cur = k;</div><div class="line">&#125;</div><div class="line">int ListLength(StaticLinkList L)&#123;</div><div class="line">    int j = 0;</div><div class="line">    int i = L(MAXSIZE-1).cur;</div><div class="line">    //最后一个元素指向数组0位置</div><div class="line">    while(i)&#123;</div><div class="line">        i = L(i).cur;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">    return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上对链表操作，都要找到要操作位置的前一个元素</p>
<h2 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h2><ul>
<li>优点</li>
</ul>
<p>插入和删除操作，只需要修改游标，不需要移动元素</p>
<ul>
<li>缺点</li>
</ul>
<p>没有解决连续存储分配数组带来表长难以确定的问题，失去了顺序存储结构随机存取的特性</p>
<p>只是为了给没有指针的编程语言实现单链表功能的方法</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>快速找到未知长度单链表的中间结点</p>
<ul>
<li>首先遍历单链表确定单链表长度L，再次从头结点出发循环L/2找到单链表的中间结点</li>
<li>使用快慢指针</li>
</ul>
<p>设置两个指针，一个指针是另外一个指针的两倍，当一个指针指向末尾结点的时候，另一个指针就指向中间结点了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int GetMidNode(LinkList L, ElemType *e)&#123;</div><div class="line">    LinkList search, mid;</div><div class="line">    mid = search = L;</div><div class="line">    while(search-&gt;next != NULL)&#123;</div><div class="line">        if (search-&gt;next-&gt;next != NULL)&#123;</div><div class="line">            search = search-&gt;next-&gt;next;</div><div class="line">            mid = mid-&gt;next;</div><div class="line">        &#125;else&#123;</div><div class="line">            //说明总长度为奇数,mid也需要加一</div><div class="line">            search = search-&gt;next;</div><div class="line">            mid = mid-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    *e = mid-&gt;data;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-13 21:54</p>
</blockquote>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>将单链表中终端结点的指针从空指针改为指向头结点，形成一个循环链表</p>
<p>非空表，空表，next指向head</p>
<p>和单链表的主要差异在于判断空链表的条件上，原来判断<code>head-&gt;next</code>是否为null，现在则是<code>head-&gt;next</code>是否等于head</p>
<p>终端结点用尾指针<code>rear</code>指示，查找终端结点是<code>O(1)</code>，开始结点则为<code>rear-&gt;next-&gt;next</code></p>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">typedef struct CLinkList&#123;</div><div class="line">    int data;</div><div class="line">    struct CLinkList *next;</div><div class="line">&#125;node;</div><div class="line">//初始化循环链表</div><div class="line">void ds_init(node **pNode)&#123;</div><div class="line">    int item;</div><div class="line">    node *temp;</div><div class="line">    node *target;</div><div class="line">    while(1)&#123;</div><div class="line">        scanf(&quot;%d&quot;, &amp;item);</div><div class="line">        fflush(stdin);</div><div class="line"></div><div class="line">        if(item == 0)</div><div class="line">            return;</div><div class="line">        //*pNode是指向结点的指针</div><div class="line">        if((*pNode) == NULL)&#123;</div><div class="line">            //循环链表中什么都没有，分配一个头结点</div><div class="line">            *pNode = (node*)malloc(sizeof(struct CLinkList));</div><div class="line">            //未分配成功</div><div class="line">            if(!(*pNode))</div><div class="line">                exit(0);</div><div class="line">            (*pNode)-&gt;data = item;</div><div class="line">            (*pNode)-&gt;next = *pNode;</div><div class="line">        &#125;else&#123;</div><div class="line">            for(target = (*pNode); target-&gt;next != (*pNode); target = target-&gt;next)</div><div class="line">                ;</div><div class="line">            temp = (node *)malloc(sizeof(struct CLinkList));</div><div class="line">            if(!temp)</div><div class="line">                exit(0);</div><div class="line">            temp-&gt;data = item;</div><div class="line">            temp-&gt;next = *pNode;</div><div class="line">            target-&gt;next = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void ds_insert(node **pNode, int i)&#123;</div><div class="line">    node *temp;</div><div class="line">    node *target;</div><div class="line">    int item;</div><div class="line">    int j = 1;</div><div class="line"></div><div class="line">    scanf(&quot;%d&quot;, &amp;item);</div><div class="line"></div><div class="line">    if(i == 1)&#123;</div><div class="line">        //插入到第一个位置，找到尾结点进行插入</div><div class="line">        temp = (node *)malloc(sizeof(struct CLinkList));</div><div class="line">        if(!temp)</div><div class="line">            exit(0);</div><div class="line">        temp-&gt;data = item;</div><div class="line">        //找到最后一个结点</div><div class="line">        for(target=(*pNode); target-&gt;next!=(*pNode); target=target-&gt;next)</div><div class="line">            ;</div><div class="line">        temp-&gt;next = *pNode;</div><div class="line">        target-&gt;next = temp;</div><div class="line">        //将首结点重置</div><div class="line">        *pNode = temp;</div><div class="line">    &#125;else&#123;</div><div class="line">        //其他位置，就放在结点之后即可</div><div class="line">        temp = (node *)malloc(sizeof(struct CLinkList));</div><div class="line">        if(!temp)</div><div class="line">            exit(0);</div><div class="line">        temp-&gt;data = item;</div><div class="line">        target = *pNode;</div><div class="line">        //保证target最多在循环链表尾部</div><div class="line">        for(j; j&lt;i-1 &amp;&amp; target-&gt;next != (*pNode); j++)&#123;</div><div class="line">            target = target-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = target-&gt;next;</div><div class="line">        target-&gt;next = temp;</div><div class="line">    &#125;        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">void ds_delete(node **pNode, int i)&#123;</div><div class="line">    node *target;</div><div class="line">    node *temp;</div><div class="line">    int j = 1;</div><div class="line">    if(i == 1)&#123;</div><div class="line">        //删除第一个结点，首结点需要特殊处理</div><div class="line">        //首先要找到最后一个结点，因为其指向了头结点</div><div class="line">        //在target-&gt;next == *pNode停止，说明到尾结点了</div><div class="line">        for(target=(*pNode); target-&gt;next != (*pNode); target=target-&gt;next)</div><div class="line">            ;</div><div class="line">        temp = *pNode;</div><div class="line">        //更新尾结点指针</div><div class="line">        target-&gt;next = temp-&gt;next;</div><div class="line">        *pNode = temp-&gt;next;</div><div class="line">        free(temp);</div><div class="line">    &#125;else&#123;</div><div class="line">        //如果不是第一个结点，那么找到其前一个结点</div><div class="line">        //删除的元素的前一个元素，所以若是尾结点，那么需要定位到尾结点的前一个结点</div><div class="line">        for(j; j&lt;i-1 &amp;&amp; target-&gt;next-&gt;next != *pNode; j++)&#123;</div><div class="line">            target = target-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp = target-&gt;next;</div><div class="line">        target-&gt;next = temp-&gt;next;</div><div class="line">        temp-&gt;next = NULL;</div><div class="line">        free(temp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回结点所在位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">int ds_search(node **pNode, int elem)&#123;</div><div class="line">    node *target;</div><div class="line">    int i = 1;</div><div class="line">    //首先定位到所在位置,到尾结点停止</div><div class="line">    for(target=(*pNode);target-&gt;data != elem &amp;&amp; target-&gt;next != (*pNode); i++)&#123;</div><div class="line">        target = target-&gt;next;</div><div class="line">    &#125;</div><div class="line">    if(target-&gt;next = *pNode)</div><div class="line">        return 0;</div><div class="line">    else</div><div class="line">        return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-14 22:16</p>
</blockquote>
<h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p>循环链表，删除经历符合条件的链表结点就行了</p>
<p>建立链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">typedef struct node&#123;</div><div class="line">    int data;</div><div class="line">    struct node *next;</div><div class="line">&#125;node;</div><div class="line"></div><div class="line">node *create(int n)&#123;</div><div class="line">    node *p = NULL;</div><div class="line">    node *head;</div><div class="line">    head = (node *)malloc(sizeof(node));</div><div class="line">    p = head;</div><div class="line">    node *s = NULL;</div><div class="line">    int i = 1;</div><div class="line"></div><div class="line">    if (0 != n)&#123;</div><div class="line">        while(i &lt;= n)&#123;</div><div class="line">            s = (node*)malloc(sizeof(node));</div><div class="line">            s-&gt;data = i++;</div><div class="line">            p-&gt;next = s;</div><div class="line">            p = s;</div><div class="line">        &#125;</div><div class="line">        s-&gt;next = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    free(head);</div><div class="line">    // 返回头结点，也就是1位置</div><div class="line">    return s-&gt;next;</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">    int n = 41;</div><div class="line">    int m = 3;</div><div class="line">    int i;</div><div class="line">    node *p = create(n);</div><div class="line">    node *temp;</div><div class="line"></div><div class="line">    //直到剩下最后一个</div><div class="line">    while(p != p-&gt;next)&#123;</div><div class="line">        for(i=1;i&lt;m-1;i++)&#123;</div><div class="line">            //找到要删除的前一个结点</div><div class="line">            p = p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;%d-&gt;&quot;, p-&gt;next-&gt;data);</div><div class="line">        //要删除的结点</div><div class="line">        temp = p-&gt;next;</div><div class="line">        p-&gt;next = temp-&gt;next;</div><div class="line"></div><div class="line">        free(temp);</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    printf(&quot;%d\n&quot;, p-&gt;data);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016-12-15 21:24</p>
</blockquote>
<h2 id="循环链表的特点"><a href="#循环链表的特点" class="headerlink" title="循环链表的特点"></a>循环链表的特点</h2><p>使用指向终端结点的尾指针来表示循环链表，这样查找开始结点和终端结点都很方便。</p>
<p>判断是否为空链表，<code>rear-&gt;next != rear</code>，只剩下一个头结点</p>
<p>循环链表的特点是无须增加存储量，仅对链接方式稍作改变，即可使得链表表处理更加方便灵活</p>
<p>将两个链表链接在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkList Connect(LinkList A, LinkList B)&#123;</div><div class="line">    //A，B都是尾指针</div><div class="line">    //A头结点位置</div><div class="line">    LinkList p = A-&gt;next;</div><div class="line">    //B开始结点链接到A表尾</div><div class="line">    A-&gt;next = B-&gt;next-&gt;next;</div><div class="line">    //释放B的头结点</div><div class="line">    free(B-&gt;next);</div><div class="line">    //B尾指针下一个指向A头结点</div><div class="line">    B-&gt;next = p;</div><div class="line">    return B;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="判断单链表是否有环"><a href="#判断单链表是否有环" class="headerlink" title="判断单链表是否有环"></a>判断单链表是否有环</h2><p>有环：链表的尾节点指向了链表中的某个节点</p>
<p>检测方法：双指针法，判断步数是否一致，快慢指针法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表&lt;/p&gt;
&lt;h1 id=&quot;算法效率&quot;&gt;&lt;a href=&quot;#算法效率&quot; class=&quot;headerlink&quot; title=&quot;算法效率&quot;&gt;&lt;/a&gt;算法效率&lt;/h1&gt;&lt;p&gt;事后统计方法: 利用计时器进行比较，需要事先编制测试程序&lt;/p&gt;
&lt;p&gt;事前分析估算: 依据统计方法对
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://microndgt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LinkList Practice</title>
    <link href="http://microndgt.github.io/2016/12/11/LinkList-Practice/"/>
    <id>http://microndgt.github.io/2016/12/11/LinkList-Practice/</id>
    <published>2016-12-11T08:44:34.000Z</published>
    <updated>2017-01-27T05:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>单链表的练习，另外有一个查找链表中间元素的算法!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div></pre></td><td class="code"><pre><div class="line">/*************************************************************************</div><div class="line">	&gt; File Name: LinkList.c</div><div class="line">	&gt; Author:</div><div class="line">	&gt; Mail:</div><div class="line">	&gt; Created Time: 日 12/11 11:34:10 2016</div><div class="line"> ************************************************************************/</div><div class="line"></div><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;time.h&gt;</div><div class="line"></div><div class="line">typedef struct Node&#123;</div><div class="line">    int data;</div><div class="line">    struct Node *next;</div><div class="line">&#125;Node,*pNode;</div><div class="line"></div><div class="line">void showLinkList(pNode LinkList);</div><div class="line">int createLinkList(pNode LinkList, int n);</div><div class="line">int lengthLinkList(pNode LinkList);</div><div class="line">int midLinkList(pNode LinkList);</div><div class="line">int destroyLinkList(pNode LinkList);</div><div class="line">int insertLinkList(pNode LinkList, int pos, int ele);</div><div class="line">int deleteLinkList(pNode LinkList, int pos, int *ele);</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    printf(&quot;0 - check LinkList\n1 - create LinkList\n2 - length of LinkList\n3 - mid data\n4 - destroy LinkList\n5 - insert element\n6 - delete element\n9 - exit\n&quot;);</div><div class="line">    int choose;</div><div class="line">    int pos;</div><div class="line">    int length;</div><div class="line">    int midData;</div><div class="line">    int insert_ele;</div><div class="line">    int ele;</div><div class="line">    int n;</div><div class="line">    //头结点</div><div class="line">    pNode LinkList = (pNode)malloc(sizeof(Node));</div><div class="line">    LinkList-&gt;next = NULL;</div><div class="line">    srand((unsigned)time(NULL));</div><div class="line">    printf(&quot;please choose one:&quot;);</div><div class="line">    scanf(&quot;%d&quot;, &amp;choose);</div><div class="line">    while(choose != 9)&#123;</div><div class="line">        switch(choose)&#123;</div><div class="line">            case 0:</div><div class="line">                showLinkList(LinkList);</div><div class="line">                break;</div><div class="line">            case 1:</div><div class="line">                printf(&quot;enter in how many links do you want:&quot;);</div><div class="line">                scanf(&quot;%d&quot;, &amp;n);</div><div class="line">                createLinkList(LinkList, n);</div><div class="line">                showLinkList(LinkList);</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                length = lengthLinkList(LinkList);</div><div class="line">                printf(&quot;length of LinkList is %d\n&quot;, length);</div><div class="line">                break;</div><div class="line">            case 3:</div><div class="line">                midData = midLinkList(LinkList);</div><div class="line">                printf(&quot;mid data of LinkList is %d\n&quot;, midData);</div><div class="line">                break;</div><div class="line">            case 4:</div><div class="line">                destroyLinkList(LinkList);</div><div class="line">                printf(&quot;already destroy\n&quot;);</div><div class="line">                showLinkList(LinkList);</div><div class="line">                break;</div><div class="line">            case 5:</div><div class="line">                printf(&quot;enter ele to insert and pos:&quot;);</div><div class="line">                scanf(&quot;%d %d&quot;, &amp;insert_ele, &amp;pos);</div><div class="line">                insertLinkList(LinkList, pos, insert_ele);</div><div class="line">                showLinkList(LinkList);</div><div class="line">                break;</div><div class="line">            case 6:</div><div class="line">                printf(&quot;enter pos to delete:&quot;);</div><div class="line">                scanf(&quot;%d&quot;, &amp;pos);</div><div class="line">                deleteLinkList(LinkList, pos, &amp;ele);</div><div class="line">                showLinkList(LinkList);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                printf(&quot;enter an number 0-6 and 9 to exit!\n&quot;);</div><div class="line">        &#125;</div><div class="line">    printf(&quot;0 - check LinkList\n1 - create LinkList\n2 - length of LinkList\n3 - mid data\n4 - destroy LinkList\n5 - insert element\n6 - delete element\n9 - exit\n&quot;);</div><div class="line">    printf(&quot;please choose one:&quot;);</div><div class="line">    scanf(&quot;%d&quot;, &amp;choose);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void showLinkList(pNode LinkList)&#123;</div><div class="line">    //LinkList指向第一个结点</div><div class="line">    printf(&quot;start-&gt;&quot;);</div><div class="line">    pNode p = LinkList;</div><div class="line">    while(p-&gt;next != NULL)&#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        printf(&quot;data:%d&quot;, p-&gt;data);</div><div class="line">        printf(&quot;-&gt;&quot;);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;end\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int createLinkList(pNode LinkList, int n)&#123;</div><div class="line">    if (n &lt;= 0 )&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    pNode p = LinkList;</div><div class="line">    pNode q = NULL;</div><div class="line">    int i;</div><div class="line">    int data;</div><div class="line">    printf(&quot;creating...\n&quot;);</div><div class="line">    for(i = 0; i &lt;n; i++)&#123;</div><div class="line">        printf(&quot;creating %d Node\n&quot;, i+1);</div><div class="line">        q = (pNode)malloc(sizeof(Node));</div><div class="line">        data = rand() % 101;</div><div class="line">        q-&gt;data = data;</div><div class="line">        q-&gt;next = NULL;</div><div class="line">        p-&gt;next = q;</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int lengthLinkList(pNode LinkList)&#123;</div><div class="line">    if(LinkList-&gt;next == NULL)&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    pNode p = LinkList;</div><div class="line">    int count;</div><div class="line">    while(p-&gt;next != NULL)&#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">        count ++;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int midLinkList(pNode LinkList)&#123;</div><div class="line">    //快慢指针</div><div class="line">    pNode p = LinkList;</div><div class="line">    pNode q = LinkList;</div><div class="line">    while(p-&gt;next != NULL)&#123;</div><div class="line">        if (p-&gt;next-&gt;next != NULL)&#123;</div><div class="line">            p = p-&gt;next-&gt;next;</div><div class="line">            q = q-&gt;next;</div><div class="line">        &#125;else&#123;</div><div class="line">            p = p-&gt;next;</div><div class="line">            q = q-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return q-&gt;data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int destroyLinkList(pNode LinkList)&#123;</div><div class="line">    pNode p = LinkList;</div><div class="line">    if(p == NULL || p-&gt;next == NULL)&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    p = p-&gt;next;</div><div class="line">    pNode q = NULL;</div><div class="line">    while(p-&gt;next != NULL)&#123;</div><div class="line">        q = p-&gt;next;</div><div class="line">        free(p);</div><div class="line">        p = q;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int insertLinkList(pNode LinkList, int pos, int ele)&#123;</div><div class="line">    if(pos &lt; 0 || pos &gt; lengthLinkList(LinkList))&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    pNode p = LinkList;</div><div class="line">    int i;</div><div class="line">    //首先获取到插入位置前一个元素</div><div class="line">    for(i=1;i&lt;pos;i++)&#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    pNode q = (pNode)malloc(sizeof(Node));</div><div class="line">    q-&gt;data = ele;</div><div class="line">    q-&gt;next = p-&gt;next;</div><div class="line">    p-&gt;next = q;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int deleteLinkList(pNode LinkList, int pos, int *ele)&#123;</div><div class="line">    if(pos &lt; 0 || pos &gt; lengthLinkList(LinkList))&#123;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    //同样获取到前一个元素</div><div class="line">    pNode p = LinkList;</div><div class="line">    int i;</div><div class="line">    for(i=1; i&lt;pos; i++)&#123;</div><div class="line">        p = p-&gt;next;</div><div class="line">    &#125;</div><div class="line">    pNode q = p-&gt;next;</div><div class="line">    *ele = q-&gt;data;</div><div class="line">    p-&gt;next = p-&gt;next-&gt;next;</div><div class="line">    free(q);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单链表的练习，另外有一个查找链表中间元素的算法!&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://microndgt.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C语言总结</title>
    <link href="http://microndgt.github.io/2016/12/11/C%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93/"/>
    <id>http://microndgt.github.io/2016/12/11/C语言总结/</id>
    <published>2016-12-11T03:43:04.000Z</published>
    <updated>2017-01-27T05:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>没有搞清楚的C语言概念总结!</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct Node&#123;</div><div class="line">    int data;</div><div class="line">    struct Node *next;</div><div class="line">&#125;mNode, *pNode;</div></pre></td></tr></table></figure>
<p><code>Node</code>是结构名，这个名字主要是为了在结构体中包含自己为成员变量的时候使用</p>
<p><code>mNode</code>是<code>struct Node</code>的别名，两者名字可以相同</p>
<p><code>pNode</code>是<code>struct Node *</code>的别名</p>
<p>等价于<code>typedef struct Node mNode</code>和<code>typedef struct Node *pNode</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有搞清楚的C语言概念总结!&lt;/p&gt;
&lt;h1 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
      <category term="C" scheme="http://microndgt.github.io/categories/C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据分析</title>
    <link href="http://microndgt.github.io/2016/12/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://microndgt.github.io/2016/12/09/数据分析/</id>
    <published>2016-12-08T23:10:26.000Z</published>
    <updated>2017-01-27T05:22:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用Python进行数据分析!</p>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>结构化数据，包括</p>
<ul>
<li>多维数组</li>
<li>表格型数据</li>
<li>关键列互相联系的多个表</li>
<li>间隔平均或者不平均的时间序列</li>
<li>也可以将数据集的特征提取为某种结构化形式</li>
</ul>
<p>计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from collections import defaultdict</div><div class="line">def get_counts(sequence):</div><div class="line">    counts = defaultdict(int)</div><div class="line">    for x in sequence:</div><div class="line">        counts[x] += 1</div><div class="line">    return counts</div></pre></td></tr></table></figure>
<p>Series对象有一个value_counts方法,<code>tz_counts = frame[&#39;tz&#39;].value_counts()</code></p>
<p>给记录中未知或者缺失的值填上一个替代值，fillna函数可以替换缺失值NA，未知值(空字符串)可以通过布尔型数组索引加以替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean_tz = frame[&apos;tz&apos;].fillna(&apos;Missing&apos;)</div><div class="line">clean_tz[clean_tz == &apos;&apos;] = &apos;Unknow&apos;</div></pre></td></tr></table></figure>
<p>按Windows和非Windows用户对时区统计信息进行分解，因为agent有缺失，所以首先进行移除工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cframe = frame[frame.a.notnull()]</div><div class="line">operating_system = np.where(cframe[&apos;a&apos;].str.contains(&apos;Windows&apos;), &apos;Windows&apos;, &apos;Not Windows&apos;)</div></pre></td></tr></table></figure>
<p>接下来使用时区和新得到的操作系统列表对数据进行分组</p>
<p><code>by_tz_os = cframe.groupby([&#39;tz&#39;, operating_system])</code></p>
<p>通过size对分组结果进行计数，利用unstack对计数结果进行重塑</p>
<p><code>agg_counts = by_tz_os.size().unstack().fillna(0)</code></p>
<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>N维数组对象，一个通用的同构数据多维容器，所有元素必须是相同类型，每一个数组有一个shape和一个dtype说明类型</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p><code>data1 = [6, 7, 8]</code> <code>arr1 = np.array(data1)</code></p>
<p><code>arr1 = np.array([1, 2, 3], dtype=np.float64)</code></p>
<p><code>arr.astype(np.float64)</code></p>
<blockquote>
<p>浮点数只能表示近似的分数值，在复杂计算中，由于可能会积累一些浮点错误，因此比较操作只能在一定小数位以内有效</p>
</blockquote>
<h2 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h2><p>类似R语言的核心思想，大小相等的数组之间的任何算术运算都会将运算应用到元素级</p>
<p>不同大小的数组之间的运算称为广播</p>
<h2 id="基本索引和切片"><a href="#基本索引和切片" class="headerlink" title="基本索引和切片"></a>基本索引和切片</h2><p>数组切片是原始数组的视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr_slice = arr[5:8]</div><div class="line">arr_slice[:] = 64</div><div class="line">#这里就会改变原始数组,而列表不会</div></pre></td></tr></table></figure>
<p>因为Numpy设计目的是处理大数据，因此会尽量不要复制数据，如果要副本的话<code>arr[5:8].copy()</code></p>
<p>二维数组的索引方式<code>arr2d[0][2]</code> or <code>arr2d[0, 2]</code></p>
<h2 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h2><p>数组的比较运算也是矢量化的，因此对数组和字符串的比较运算会产生一个布尔型数组</p>
<p>布尔型数组的长度必须跟被索引的轴长度一致</p>
<p>可以使用<code>!=</code>或者使用符号<code>-</code>进行否定</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用Python进行数据分析!&lt;/p&gt;
&lt;h1 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h1&gt;&lt;p&gt;结构化数据，包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;li&gt;表格型数据&lt;/li&gt;

    
    </summary>
    
      <category term="数据分析" scheme="http://microndgt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
