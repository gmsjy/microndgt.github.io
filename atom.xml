<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyRover</title>
  <subtitle>做我的仲夏夜之梦～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://microndgt.github.io/"/>
  <updated>2017-02-27T01:44:21.000Z</updated>
  <id>http://microndgt.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解RESTful架构</title>
    <link href="http://microndgt.github.io/2017/02/27/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/"/>
    <id>http://microndgt.github.io/2017/02/27/理解RESTful架构/</id>
    <published>2017-02-27T01:43:24.000Z</published>
    <updated>2017-02-27T01:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解RESTful架构"><a href="#理解RESTful架构" class="headerlink" title="理解RESTful架构"></a>理解RESTful架构</h1><p>Representational State Transfer 表现层状态转化</p>
<p>表现层其实是指的是资源的表现层，所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。URI只代表资源的实体，不代表它的形式。而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。所以设计API的URI时候，去除表现层，只保留资源的位置。</p>
<p>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h2><ol>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层，比如json</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ol>
<h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol>
<li>最常见的一种设计错误，就是URI包含动词。资源表示一种实体，应该是名词，URI不应该有动词，动词应该放在HTTP协议中。资源不能是动词，但是可以是一种服务。</li>
<li>在URI中加入版本号，不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Accept: vnd.example-com.foo+json; version=1.0</div><div class="line">Accept: vnd.example-com.foo+json; version=1.1</div></pre></td></tr></table></figure>
<h1 id="RESTful-API-设计指南"><a href="#RESTful-API-设计指南" class="headerlink" title="RESTful API 设计指南"></a>RESTful API 设计指南</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径又称”终点”（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<h2 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回完整的资源对象</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解RESTful架构&quot;&gt;&lt;a href=&quot;#理解RESTful架构&quot; class=&quot;headerlink&quot; title=&quot;理解RESTful架构&quot;&gt;&lt;/a&gt;理解RESTful架构&lt;/h1&gt;&lt;p&gt;Representational State Transfer 表现
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Using Mix-Ins With Python</title>
    <link href="http://microndgt.github.io/2017/02/24/Using%20Mix-ins%20with%20Python/"/>
    <id>http://microndgt.github.io/2017/02/24/Using Mix-ins with Python/</id>
    <published>2017-02-24T04:10:49.000Z</published>
    <updated>2017-02-24T07:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Mixins扩展类功能"><a href="#利用Mixins扩展类功能" class="headerlink" title="利用Mixins扩展类功能"></a>利用Mixins扩展类功能</h1><p>扩展其他类的功能，但是这些类没有任何继承的关系。因此你不能简单的将这些方法放入一个基类,然后被其他类继承。所以就有了这个Mixins。</p>
<p>也可能是某个库提供了基础类，可以利用其构造自己的类。</p>
<p>扩展映射对象，添加日志，唯一性设置，类型检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class LoggedMappingMixin:</div><div class="line">    __slots__ = () # 混入类没有实例变量，因为直接实例化混入类没有意义</div><div class="line">    def __getitem__(self, key):</div><div class="line">        print(&apos;Getting &apos; + str(key))</div><div class="line">        return super().__getitem__(key)</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        print(&apos;Setting &#123;&#125; = &#123;!r&#125;&apos;.format(key, value))</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">    def __delitem__(self, key):</div><div class="line">        print(&apos;Deleting &apos; + str(key))</div><div class="line">        return super().__delitem__(key)</div><div class="line">class SetOnceMappingMixin:</div><div class="line">    __slots__ = ()</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        if key in self:</div><div class="line">            raise KeyError(str(key) + &apos; already set&apos;)</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">class StringKeysMappingMixin:</div><div class="line">    __slots__ = ()</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        if not isinstance(key, str):</div><div class="line">            raise TypeError(&apos;keys must be strings&apos;)</div><div class="line">        return super().__setitem__(key, value)</div></pre></td></tr></table></figure>
<p>通过多继承和其他映射对象混入使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class LoggedDict(LoggedMappingMixin, dict):</div><div class="line">    pass</div><div class="line">d = LoggedDict()</div><div class="line">d[&apos;x&apos;] = 23</div><div class="line">print(d[&apos;x&apos;])</div><div class="line">del d[&apos;x&apos;]</div><div class="line">from collections import defaultdict</div><div class="line">class SetOnceDefaultDict(SetOnceMappingMixin, defaultdict):</div><div class="line">    pass</div><div class="line">d = SetOnceDefaultDict(list)</div><div class="line">d[&apos;x&apos;].append(2)</div><div class="line">d[&apos;x&apos;].append(3)</div><div class="line">d[&apos;x&apos;] = 32 # wrong</div></pre></td></tr></table></figure>
<p>在一些大型库和框架中也会发现混入类的使用,用途同样是增强已存在的类的功能和一些可选特征,对于混入类,有几点需要记住。首先是,混入类不能直接被实例化使用。其次,混入类没有自己的态信息,也就是说它们并没有定义<code>__init__()</code>方法,并且没有实例属性。这也是为什么我们在上面明确定了<code>__slots__=()</code>。</p>
<p>还有一种实现混入类的方式就是使用类装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def LoggedMapping(cls):</div><div class="line">    cls_getitem = cls.__getitem__</div><div class="line">    cls_setitem = cls.__setitem__</div><div class="line">    cls_delitem = cls.__delitem__</div><div class="line">    def __getitem__(self, key):</div><div class="line">        print(&apos;Getting &apos; + str(key))</div><div class="line">        return super().__getitem__(key)</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        print(&apos;Setting &#123;&#125; = &#123;!r&#125;&apos;.format(key, value))</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">    def __delitem__(self, key):</div><div class="line">        print(&apos;Deleting &apos; + str(key))</div><div class="line">        return super().__delitem__(key)</div><div class="line">    cls.__getitem__ = __getitem__</div><div class="line">    cls.__setitem__ = __setitem__</div><div class="line">    cls.__delitem__ = __delitem__</div><div class="line">    return cls</div><div class="line">@LoggedMapping</div><div class="line">class LoggedDict(dict):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="理解2"><a href="#理解2" class="headerlink" title="理解2"></a>理解2</h1><p>Mixin模式是一种在python里经常使用的模式，适当合理的应用能够达到复用代码，合理组织代码结构的目的。</p>
<p>Python的Mixin模式可以通过多继承的方式来实现, 举例来说，我们自定义一个简单的具有嵌套结构的数据容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class SimpleItemContainer(object):</div><div class="line">    def __init__(self, id, item_containers):</div><div class="line">        self.id = id</div><div class="line">        self.data = &#123;&#125;</div><div class="line">        for item in item_containers:</div><div class="line">            self.data[item.id] = item</div></pre></td></tr></table></figure>
<p>这时候利用python内置的<code>UserDict.DictMixin</code>来实现一个像原生字典的一样来访问数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from collections import MutableMapping as DictMixin</div><div class="line">class SimpleItemContainer(object):</div><div class="line">    def __init__(self, id, item_containers):</div><div class="line">        self.id = id</div><div class="line">        self.data = &#123;&#125;</div><div class="line">        for item in item_containers:</div><div class="line">            self.data[item[&apos;id&apos;]] = item[&apos;item&apos;]</div><div class="line">class BetterSimpleItemContainer(SimpleItemContainer, DictMixin):</div><div class="line">    def __getitem__(self, id):</div><div class="line">        return self.data[id]</div><div class="line">    def __setitem__(self, id, value):</div><div class="line">        self.data[id] = value</div><div class="line">    def __delitem__(self, id):</div><div class="line">        del self.data[id]</div><div class="line">    def __iter__(self):</div><div class="line">        return iter(self.data)</div><div class="line">    def __len__(self):</div><div class="line">        return len(self.data)</div><div class="line">    def keys(self):</div><div class="line">        return self.data.keys()</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    b = BetterSimpleItemContainer(1, [&#123;&apos;id&apos;:1,&apos;item&apos;:&apos;item&apos;&#125;])</div><div class="line">    print(b[1])</div><div class="line">    print(b)</div></pre></td></tr></table></figure>
<p>是一种特殊的多继承，而是在继承了一个基类的基础上，顺带利用多重继承的功能给这个子类添点料，增加一些其他的功能。保证Mixin的类功能单一具体，混入之后，新的类的MRO树其实也会相对很简单，并不会引起混乱。通常混入 Mixin 的类和 Mixin 类本身不是 is-a 的关系，混入 Mixin 类是为了添加某些（可选的）功能。自由地混入 Mixin 类就可以灵活地为被混入的类添加不同的功能。</p>
<p>python支持多继承后，但能否支持动态继承性质?在程序运行过程中，重定义类的继承，python是支持这种动态继承性质的。这也就是python中 的mixin，在定义类过程中改变类的继承顺序，继承类。当某个模块不能修改时，通过mixin方式可以动态添加该类的方法，动态改变类的原有继承体系。 弄懂了多继承，mixin特性就简单多了。 但需要注意mixin后的具体继承体系的改变。</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">import types</div><div class="line">def MixIn(pyClass,mixInClass,makeAncestor=0):</div><div class="line">    if makeAncestor:</div><div class="line">        pyClass.__bases__ = (mixInClass,) + pyClass.__bases__</div><div class="line">    elif mixInClass not in pyClass.__bases__:</div><div class="line">        pyClass.__bases__ = pyClass.__bases__ + (mixInClass,)</div><div class="line">    else:</div><div class="line">        pass</div><div class="line">class C1(object):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C1&apos;</div><div class="line">class C0MixIn(object):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C0MixIn&apos;</div><div class="line">class C2(C1,C0MixIn):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C2&apos;</div><div class="line">class C0(C1):</div><div class="line">    pass</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    print C0.__mro__</div><div class="line">    c1 = C0()</div><div class="line">    c1.test()</div><div class="line">    MixIn(C0,C0MixIn,1)</div><div class="line">    c0 = C0()</div><div class="line">    c0.test()</div><div class="line">    print C0.__mro__</div><div class="line">    print C2.__mro__</div><div class="line">    MixIn(C2,C0MixIn)</div><div class="line">    print C2.__mro__</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(&lt;class &apos;__main__.C0&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">test in C1</div><div class="line">test in C0MixIn</div><div class="line">(&lt;class &apos;__main__.C0&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">(&lt;class &apos;__main__.C2&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">(&lt;class &apos;__main__.C2&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div></pre></td></tr></table></figure>
<h1 id="Using-Mix-ins-with-Python"><a href="#Using-Mix-ins-with-Python" class="headerlink" title="Using Mix-ins with Python"></a>Using Mix-ins with Python</h1><p>翻译自<a href="http://www.linuxjournal.com/node/4540/print" target="_blank" rel="external">http://www.linuxjournal.com/node/4540/print</a></p>
<p>应用在Python中的mix-in编程风格的解释。</p>
<p>Mix-in编程是一种软件开发风格，其功能单元在一个类中创建然后在其他类中混入。可能这听起来像简单的继承，但是mix-in有别与传统的类。大多情况下mix-in不是任何一个给定类”主要的”父类，不关心它将用于什么类，被用于贯穿类继承体系的多数类，并且可以动态载入。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;利用Mixins扩展类功能&quot;&gt;&lt;a href=&quot;#利用Mixins扩展类功能&quot; class=&quot;headerlink&quot; title=&quot;利用Mixins扩展类功能&quot;&gt;&lt;/a&gt;利用Mixins扩展类功能&lt;/h1&gt;&lt;p&gt;扩展其他类的功能，但是这些类没有任何继承的关系。因此
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Mixin" scheme="http://microndgt.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter详解</title>
    <link href="http://microndgt.github.io/2017/02/24/Jupyter%E8%AF%A6%E8%A7%A3/"/>
    <id>http://microndgt.github.io/2017/02/24/Jupyter详解/</id>
    <published>2017-02-24T03:08:24.000Z</published>
    <updated>2017-02-24T03:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="import"><a href="#import" class="headerlink" title="__import__"></a><code>__import__</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def import_item(name):</div><div class="line">    parts = name.rsplit(&apos;.&apos;, 1)</div><div class="line">    if len(parts) == 2:</div><div class="line">        # called with &apos;foo.bar....&apos;</div><div class="line">        package, obj = parts</div><div class="line">        module = __import__(package, fromlist=[obj])</div><div class="line">        try:</div><div class="line">            pak = getattr(module, obj)</div><div class="line">        except AttributeError:</div><div class="line">            raise ImportError(&apos;No module named %s&apos; % obj)</div><div class="line">        return pak</div><div class="line">    else:</div><div class="line">        # called with un-dotted string</div><div class="line">        return __import__(parts[0])</div></pre></td></tr></table></figure>
<p><code>name.rsplit(&#39;.&#39;, 1)</code>表示从右边开始切分，只切分一次</p>
<p><code>__import__(package, fromlist=[obj])</code>:这里是当name是类似这种名字<code>foo.bar</code>才会运行，所以<code>package=foo</code>,fromlist不论填什么都会返回package，最后返回的module就是<code>foo</code>，然后在<code>foo</code>获取<code>bar</code>属性,如果没有这个的话，产生异常，否则返回获取的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;import&quot;&gt;&lt;a href=&quot;#import&quot; class=&quot;headerlink&quot; title=&quot;__import__&quot;&gt;&lt;/a&gt;&lt;code&gt;__import__&lt;/code&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Jupyter" scheme="http://microndgt.github.io/tags/Jupyter/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Zmq</title>
    <link href="http://microndgt.github.io/2017/02/24/Python-%E4%B8%8E-zmq/"/>
    <id>http://microndgt.github.io/2017/02/24/Python-与-zmq/</id>
    <published>2017-02-24T01:58:21.000Z</published>
    <updated>2017-02-24T02:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>zmq是一个云时代极速消息通信库，励志要写入Linux内核。这东西简单实用，完成同样的功能，如果是用socket，那恐怕要写出一大堆的代码，但用zmq，只需要简单的几行代码就可以了。</p>
<p>zmq的版本和pyzmq的版本:<code>zmq.zmq_version()</code>和<code>zmq.pyzmq_version()</code></p>
<h2 id="一个使用示例"><a href="#一个使用示例" class="headerlink" title="一个使用示例"></a>一个使用示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-13</div><div class="line">服务端，发布模式</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">from random import randrange</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.PUB)</div><div class="line">socket.bind(&quot;tcp://*:5556&quot;)</div><div class="line">while True:</div><div class="line">    zipcode = randrange(1, 100000)</div><div class="line">    temperature = randrange(-80, 135)</div><div class="line">    relhumidity = randrange(10, 60)</div><div class="line">    socket.send_string(&quot;%i %i %i&quot; % (zipcode,temperature , relhumidity))</div><div class="line"># 客户端</div><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-13</div><div class="line">订阅模式，如果设置了过滤条件，那么只会接收到以过滤条件开头的消息</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import sys</div><div class="line">import zmq</div><div class="line">#  Socket to talk to server</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.SUB)</div><div class="line">print(&quot;Collecting updates from weather server...&quot;)</div><div class="line">socket.connect(&quot;tcp://localhost:5556&quot;)</div><div class="line"># Subscribe to zipcode, default is NYC, 10001</div><div class="line">zip_filter = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;10002&quot;</div><div class="line"># 此处设置过滤条件，只有以 zip_filter 开头的消息才会被接收</div><div class="line">socket.setsockopt_string(zmq.SUBSCRIBE, zip_filter)</div><div class="line"># Process 5 updates</div><div class="line">total_temp = 0</div><div class="line">for update_nbr in range(5):</div><div class="line">    string = socket.recv().decode(&apos;utf-8&apos;)</div><div class="line">    print(string)</div><div class="line">    zipcode, temperature, relhumidity = string.split()</div><div class="line">    total_temp += int(temperature)</div><div class="line">print(&quot;Average temperature for zipcode &apos;%s&apos; was %dF&quot; % (zip_filter, total_temp / update_nbr))</div></pre></td></tr></table></figure>
<ul>
<li>zmq的程序，也是要分清服务端和客户端的，服务端也是要绑定ip和端口的</li>
<li>如果我们先启动客户端，后启动服务端，那么程序是可以正常运行的，换成socket，就不行，socket只能先启动服务端，后启动客户端</li>
<li>这是一个消息通信库，它自己实现了一些协议，使得我们可以非常轻松的在节点间，进程间，线程间传递消息</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>不论是服务端还是客户端，都需要获得zmq上下文<code>context = zmq.Context()</code></p>
<p>然后获得socket，每一个socket都是有自己的类型的，示例中，服务端的socket的类型是<code>zmq.PUB</code>，客户端的socket的类型是<code>zmq.SUB</code>，pub是发布，sub是订阅。说的通俗点，就是有一个pub节点，可以有多个sub节点，pub节点发出去的消息，如果sub节点没有设置过滤条件，那么就会接收所有的消息，如果有过滤条件，就只接收满足过滤条件的消息。</p>
<p>设置过滤条件很简单<code>socket.setsockopt(zmq.SUBSCRIBE, zip_filter)</code>第二个参数就是期望的过滤条件，只有那些以这个过滤条件开头的消息才会被接收</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>一个上下文可以创建任意多个socket，完全不受限制</li>
<li>先启动了客户端，服务端pub出去的一些消息也还是可能没有被收到，因为你启动服务端时，服务端与客户端要建立连接，而这个时候，消息其实已经发出去了，所以你没收到</li>
<li>客户端断开连接，没有影响。如果是服务端断开了呢，比如程序死掉了，那么客户端不会发生崩溃，只是阻塞在<code>socket.recv()</code>这条语句上，并且客户端有缓存，所以有可能客户端还在运行，只是收的数据是缓存中的数据。</li>
</ol>
<h2 id="zmq应答模式"><a href="#zmq应答模式" class="headerlink" title="zmq应答模式"></a>zmq应答模式</h2><ol>
<li>必须先提问，后回答</li>
<li>对于一个提问，只能回答一次</li>
<li>在没有收到回答前不能再次提问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-10</div><div class="line">回复请求</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">import time</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.REP)</div><div class="line">socket.bind(&apos;tcp://*:5555&apos;)</div><div class="line">while True:</div><div class="line">    message = socket.recv()</div><div class="line">    print(&apos;received request: &apos;, message)</div><div class="line">    time.sleep(1)</div><div class="line">    socket.send_string(&apos;World&apos;)</div><div class="line"># 客户端</div><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-10</div><div class="line">你无法连续向服务器发送数据，必须发送一次，接收一次</div><div class="line">REQ和REP模式中，客户端必须先发起请求</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">context = zmq.Context()</div><div class="line">print(&apos;connect to hello world server&apos;)</div><div class="line">socket = context.socket(zmq.REQ)</div><div class="line">socket.connect(&apos;tcp://localhost:5555&apos;)</div><div class="line">for request in range(1, 10):</div><div class="line">    print(&apos;send &apos;, request, &apos;...&apos;)</div><div class="line">    socket.send_string(&apos;hello&apos;)</div><div class="line">    message = socket.recv()</div><div class="line">    print(&apos;received reply &apos;, request, &apos;[&apos;, message, &apos;]&apos;)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zmq是一个云时代极速消息通信库，励志要写入Linux内核。这东西简单实用，完成同样的功能，如果是用socket，那恐怕要写出一大堆的代码，但用zmq，只需要简单的几行代码就可以了。&lt;/p&gt;
&lt;p&gt;zmq的版本和pyzmq的版本:&lt;code&gt;zmq.zmq_version(
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>WireShark 抓包</title>
    <link href="http://microndgt.github.io/2017/02/21/WireShark-%E6%8A%93%E5%8C%85/"/>
    <id>http://microndgt.github.io/2017/02/21/WireShark-抓包/</id>
    <published>2017-02-21T04:05:10.000Z</published>
    <updated>2017-02-21T09:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h1><h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p>直接抓包本机网卡进出流量</p>
<h3 id="集线器环境"><a href="#集线器环境" class="headerlink" title="集线器环境"></a>集线器环境</h3><p>物理层，流量防洪，统一冲突域</p>
<h3 id="交换机环境"><a href="#交换机环境" class="headerlink" title="交换机环境"></a>交换机环境</h3><p>网络层产品，所以使用路由表或者Mac地址来通信的</p>
<p><strong>端口镜像SPAN</strong></p>
<p>将交换机流量copy过来，设置混杂模式，网络监控</p>
<p><strong>ARP欺骗</strong></p>
<p><code>Cain&amp;Abel</code> ARP攻击软件，ARP请求，广播，ARP回复，ARP欺骗。ARP表，后到优先，改掉了交换机的MAC表。最后决定是否将流量转出来。局域网攻击。</p>
<p><strong>MAC泛洪</strong></p>
<p>攻击交换机中抓包，泛洪垃圾包，产生大量的MAC地址，交换机的表会被爆表，如果没有MAC地址，会对外放洪。</p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul>
<li>GTK 1/2 图形化处理界面</li>
<li>Core</li>
<li>Wiretap 格式支持引擎</li>
<li>Capture 抓包引擎</li>
<li>Win-/libpcap</li>
</ul>
<h2 id="快速抓包"><a href="#快速抓包" class="headerlink" title="快速抓包"></a>快速抓包</h2><ul>
<li>选择网卡</li>
<li>停止抓包</li>
<li>保存数据包</li>
</ul>
<p>RTT 往返时延<br>TTL TTL的作用是限制IP数据包在计算机网络中的存在的时间</p>
<h2 id="名字解析"><a href="#名字解析" class="headerlink" title="名字解析"></a>名字解析</h2><ul>
<li>Mac地址解析</li>
<li>IP地址解析，网络名字解析</li>
<li>传输名字解析</li>
</ul>
<h2 id="数据包操作"><a href="#数据包操作" class="headerlink" title="数据包操作"></a>数据包操作</h2><ul>
<li>标记数据包，标记，配色方案</li>
<li>注释数据包</li>
<li>合并数据包</li>
<li>打印数据包</li>
<li>输出数据包</li>
</ul>
<h2 id="抓包选项设置"><a href="#抓包选项设置" class="headerlink" title="抓包选项设置"></a>抓包选项设置</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抓包原理&quot;&gt;&lt;a href=&quot;#抓包原理&quot; class=&quot;headerlink&quot; title=&quot;抓包原理&quot;&gt;&lt;/a&gt;抓包原理&lt;/h1&gt;&lt;h2 id=&quot;网络原理&quot;&gt;&lt;a href=&quot;#网络原理&quot; class=&quot;headerlink&quot; title=&quot;网络原理&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="WireShark" scheme="http://microndgt.github.io/tags/WireShark/"/>
    
  </entry>
  
  <entry>
    <title>BAIDU的DNS解析</title>
    <link href="http://microndgt.github.io/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://microndgt.github.io/2017/02/19/BAIDU的DNS解析/</id>
    <published>2017-02-19T09:31:18.000Z</published>
    <updated>2017-02-20T02:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天用<code>nslookup</code>命令解析查看了<code>www.baidu.com</code>的IP地址，却意外发现百度的<code>CNAME</code>居然是<code>www.a.shifen.com</code></p>
<h1 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">nslookup www.baidu.com</div><div class="line">&gt;&gt;&gt;</div><div class="line">Server:		119.29.29.29</div><div class="line">Address:	119.29.29.29#53</div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">www.baidu.com	canonical name = www.a.shifen.com.</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.111.188</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.112.244</div></pre></td></tr></table></figure>
<p>接下来看看一个详细的baidu的dns解析过程</p>
<p>理论上，目前我的电脑通过ISP接入互联网，ISP就会分配一个本地DNS服务器（非权威服务器），然后我的电脑向这个ISP DNS服务器发起请求，查询<code>www.baidu.com</code>的IP地址。</p>
<p>首先DNS会检查自己的缓存里面有没有这个地址，如果有的话直接返回，没有的话，ISP会把请求发送给根DNS服务器（13台），然后根DNS服务器发现是<code>.com</code>结尾，是<code>.com</code>这个顶级域名下的，就告诉请求者负责解析<code>.com</code>的DNS服务器，ISP DNS再次向baidu.com这个域的权威服务器发起请求，服务器收到之后，查一下www这台主机，然后把IP返回给IPS DNS，然后把地址返回给PC，并且存入缓存中，以便再次访问。</p>
<p>使用dig命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+trace 表示将显示从根域逐级查询的过程，追踪dns解析中的问题</div><div class="line">+tcp dig默认使用udp协议，使用tcp方式</div></pre></td></tr></table></figure>
<p><code>dig www.baidu.com</code>的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">kevin:~ $ dig www.baidu.com</div><div class="line"># 版本信息和全局设置选项</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line"># DNS返回的技术信息</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20158</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"># 问题，查询的名字和类型字段，A记录</div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.baidu.com.			IN	A</div><div class="line"># 回答，对查询的响应中的RR</div><div class="line">;; ANSWER SECTION:</div><div class="line">www.baidu.com.		1014	IN	CNAME	www.a.shifen.com.</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.111.188</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.112.244</div><div class="line"># 查询的统计数据</div><div class="line">;; Query time: 60 msec</div><div class="line">;; SERVER: 119.29.29.29#53(119.29.29.29)</div><div class="line">;; WHEN: Sun Feb 19 15:07:00 2017</div><div class="line">;; MSG SIZE  rcvd: 90</div></pre></td></tr></table></figure>
<p>然后使用trace功能，从头显示dns解析过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace www.baidu.com</div><div class="line"># 查询根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line">.			335103	IN	NS	m.root-servers.net.</div><div class="line">.			335103	IN	NS	a.root-servers.net.</div><div class="line">.			335103	IN	NS	j.root-servers.net.</div><div class="line">.			335103	IN	NS	e.root-servers.net.</div><div class="line">.			335103	IN	NS	c.root-servers.net.</div><div class="line">.			335103	IN	NS	i.root-servers.net.</div><div class="line">.			335103	IN	NS	b.root-servers.net.</div><div class="line">.			335103	IN	NS	g.root-servers.net.</div><div class="line">.			335103	IN	NS	h.root-servers.net.</div><div class="line">.			335103	IN	NS	k.root-servers.net.</div><div class="line">.			335103	IN	NS	l.root-servers.net.</div><div class="line">.			335103	IN	NS	d.root-servers.net.</div><div class="line">.			335103	IN	NS	f.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 3126 ms</div><div class="line"># 查询到的com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">;; Received 503 bytes from 198.41.0.4#53(198.41.0.4) in 5139 ms</div><div class="line"># 查询到的baidu.com权威dns服务器</div><div class="line">baidu.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns7.baidu.com.</div><div class="line">;; Received 201 bytes from 192.52.178.30#53(192.52.178.30) in 1697 ms</div><div class="line"># 查询到的别名</div><div class="line">www.baidu.com.		1200	IN	CNAME	www.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 228 bytes from 61.135.165.235#53(61.135.165.235) in 123 ms</div></pre></td></tr></table></figure>
<p>首先获取13个根服务器的13个IP和主机名，然后向其中一个<code>198.41.0.4</code>发送<code>www.baidu.com</code>请求，返回<code>.com</code>顶级域的服务器IP，接着向<code>.com</code>域的一台服务器<code>192.52.178.30</code>请求，返回<code>baidu.com</code>域名服务器IP和名称，向百度的顶级域名服务器<code>dns.baidu.com</code>请求<code>www.baidu.com</code>，他发现这个www有别名叫<code>www.a.shifen.com</code>。</p>
<p>一般来讲，dns请求到别名的时候，查询就会终止，然后重新发起查询别名的请求，所以应该返回<code>www.a.shifen.com</code>，但是其实它返回了<code>a.shifen.com</code>的NS</p>
<p>再使用dig工具来查询一下<code>shifen.com</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace shifen.com</div><div class="line"># 查询的根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace shifen.com</div><div class="line">;; global options: +cmd</div><div class="line">.			188674	IN	NS	a.root-servers.net.</div><div class="line">.			188674	IN	NS	b.root-servers.net.</div><div class="line">.			188674	IN	NS	h.root-servers.net.</div><div class="line">.			188674	IN	NS	d.root-servers.net.</div><div class="line">.			188674	IN	NS	g.root-servers.net.</div><div class="line">.			188674	IN	NS	l.root-servers.net.</div><div class="line">.			188674	IN	NS	m.root-servers.net.</div><div class="line">.			188674	IN	NS	f.root-servers.net.</div><div class="line">.			188674	IN	NS	j.root-servers.net.</div><div class="line">.			188674	IN	NS	c.root-servers.net.</div><div class="line">.			188674	IN	NS	i.root-servers.net.</div><div class="line">.			188674	IN	NS	e.root-servers.net.</div><div class="line">.			188674	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 1573 ms</div><div class="line"># com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">;; Received 488 bytes from 192.33.4.12#53(192.33.4.12) in 2454 ms</div><div class="line"># shifen.com 权威dns服务器</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 170 bytes from 192.33.14.30#53(192.33.14.30) in 430 ms</div><div class="line"># 最终的A记录和NS记录</div><div class="line">shifen.com.		7200	IN	A	202.108.250.218</div><div class="line">shifen.com.		86400	IN	NS	ns4.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns1.baidu.com.</div><div class="line">;; Received 186 bytes from 61.135.165.235#53(61.135.165.235) in 24 ms</div></pre></td></tr></table></figure>
<p>从这里可以看出来<code>shifen.com</code>和<code>baidu.com</code>的域名服务器是同一台，当拿到别名<code>www.a.shifen.com</code>的时候，本来要重新到com域查找<code>shifen.com</code>的NS，又因为两个域在同一台NS上，所以直接本机发起了<code>shifen.com</code>请求，发现<code>www.a.shifen.com</code>是属于<code>a.shifen.com</code>这个域的，所以直接访问<code>shifen.com</code>所返回的IP地址，结果是<code>403 Forbidden</code>，所以应该去到<code>a.shifen.com</code>这个域获取，于是把<code>a.shifen.com</code>这个NS和IP返回，然后在<code>a.shifen.com</code>这个域的域名服务器上查询<code>www.a.shifen.com</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~/Desktop/work/capacity $ dig www.a.shifen.com +trace</div><div class="line"># 根dns服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.a.shifen.com +trace</div><div class="line">;; global options: +cmd</div><div class="line">.			174188	IN	NS	a.root-servers.net.</div><div class="line">.			174188	IN	NS	b.root-servers.net.</div><div class="line">.			174188	IN	NS	h.root-servers.net.</div><div class="line">.			174188	IN	NS	d.root-servers.net.</div><div class="line">.			174188	IN	NS	g.root-servers.net.</div><div class="line">.			174188	IN	NS	l.root-servers.net.</div><div class="line">.			174188	IN	NS	m.root-servers.net.</div><div class="line">.			174188	IN	NS	f.root-servers.net.</div><div class="line">.			174188	IN	NS	j.root-servers.net.</div><div class="line">.			174188	IN	NS	c.root-servers.net.</div><div class="line">.			174188	IN	NS	i.root-servers.net.</div><div class="line">.			174188	IN	NS	e.root-servers.net.</div><div class="line">.			174188	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 39 ms</div><div class="line"># com域</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">;; Received 494 bytes from 192.203.230.10#53(192.203.230.10) in 523 ms</div><div class="line"># 先查的是shifen.com</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 176 bytes from 192.33.14.30#53(192.33.14.30) in 27 ms</div><div class="line"># 发现是属于 a.shifen.com这个域的</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">;; Received 204 bytes from 61.135.165.235#53(61.135.165.235) in 82 ms</div><div class="line"># 在a.shifen.com这个域上查找</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.125</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.121</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 236 bytes from 61.135.162.215#53(61.135.162.215) in 38 ms</div></pre></td></tr></table></figure>
<p>直接访问之，正是百度的页面。</p>
<h1 id="彩蛋-shifen-com由来"><a href="#彩蛋-shifen-com由来" class="headerlink" title="彩蛋-shifen.com由来"></a><code>彩蛋-shifen.com由来</code></h1><p><code>http://shifen.com</code>是百度当年为了竞价排名这个广告系统注册的，这个后台系统被命名为Shifen竞价排名，以前的销售系统现在还叫shifen销售系统。因为当年百度那个广告最低点击10分起价。为什么有这么一个奇怪的名字呢？在《相信中国》中，梁冬先生这样写道：“这个将来成就了百度80%收入的商业模式，最初的管理平台是由一个叫刘子正的实习生主持开发的。这也是唯一一个除<code>http://baidu.com</code>以外，外人所知的百度公司所拥有的国际域名。</p>
<p>另外：大公司都跟“十分”有关系啊，比如腾讯——TenCent⋯⋯</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用&lt;code&gt;nslookup&lt;/code&gt;命令解析查看了&lt;code&gt;www.baidu.com&lt;/code&gt;的IP地址，却意外发现百度的&lt;code&gt;CNAME&lt;/code&gt;居然是&lt;code&gt;www.a.shifen.com&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;解析过
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 应用层</title>
    <link href="http://microndgt.github.io/2017/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://microndgt.github.io/2017/02/19/计算机网络-应用层/</id>
    <published>2017-02-19T03:06:16.000Z</published>
    <updated>2017-02-20T08:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>网络体系结构是固定的，为应用程序提供了特定的服务集合，应用程序体系结构主要有一下：客户－服务器体系结构或者对等P2P体系结构</p>
<p>客户－服务器体系结构有一个打开的主机作为服务器，服务于来自其他客户的主机请求，客户通过向该服务器的IP地址发送分组来与其联系。</p>
<p>P2P体系结构中，应用程序在间断链接的主机对之间使用直接通信，这些主机对被称为对等方，通信不必经过专门的服务器，在即时讯息应用，服务器被用于跟踪用户的IP地址，用户和用户的报文在用户主机之间直接发送。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进行通信的实际上是进程而不是程序，进程运行在相同的端系统上时，他们使用进程间通信机制相互通信，进程间通信规则由端系统上的操作系统确定。两个不同端系统上的进行，通过跨越计算机网络交换报文而相互通信。</p>
<p>进程通过一个被称为套接字的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口。开发者可以控制套接字在应用层端的一切，但是对套接字在运输层端几乎没有控制权。</p>
<p>为了标识接收进程，需要定义两种信息，主机的地址和接收进程标识符。IP地址和目的端口号。</p>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>主要有可靠运输服务，吞吐量，定时和安全性。</p>
<p>可靠运输：确保数据交付服务，进程到进程之间的可靠数据传输</p>
<p>吞吐量：发送进程能够向接收进程交付比特的速率，运输层协议能够以某种特定的速率提供确保的可用吞吐量，使用这种服务，应用程序能够请求r比特/s的确保吞吐量</p>
<p>定时：提供定时保证</p>
<p>安全性，运输协议能够为应用程序提供一种或者多种安全性服务。</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
<p>SSL：安全套接字层，是对TCP的加强，这种强化是在应用层上实现的。</p>
<p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
<p>当前互联网能够为时间敏感应用提供服务，但是不能提供定时或者带宽保证。</p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>定义了运行在不同端系统的应用程序进程如何相互传递报文，定义了</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<p>web的应用层协议是HTTP，定义了在浏览器和web服务器之间传输的报文格式和序列</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>超文本传输协议，HTTP，web的核心，HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<p>每个URL地址由两部分组成，存放对象的服务器主机名和对象的路径名</p>
<p>web浏览器实现了HTTP的客户端，web服务器实现了HTTP的服务器端，存储web对象，每个对象由URL寻址。</p>
<p>HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。HTTP使用TCP作为他的支撑运输协议。</p>
<p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议。</p>
<h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h2><p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器能够配置成使用非持续连接。每个请求响应对是经一个单独的TCP连接发送，非持续连接。所有请求和响应经过相同的TCP链接发送，持续连接。</p>
<p>往返时间RTT，指一个短分组从客户到服务器然后再返回客户所花费的时间。因此一个TCP连接总的响应时间是两个RTT加上服务传输HTML文件的时间，三次握手及传输。</p>
<p>采用持续连接，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。如果经过一定时间间隔没有使用，HTTP服务器就关闭该链接。</p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /somedir/sth.html HTTP/1.1</div><div class="line">Host: www.someschool.edu</div><div class="line">Connection: close</div><div class="line">User-agent: Mozilla/5.0</div><div class="line">Accept-language: fr</div></pre></td></tr></table></figure>
<p>每行由一个回车和换行符结束，最后一行再附加一个回车换行符。第一行是请求行，其后继行叫做首部行，对于POST请求，后面还附有实体体。Connection close说明服务器不希望使用持续连接。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Connection: close</div><div class="line">Date: Tue, 09 Aug 2016 15:44:04 GMT</div><div class="line">Server: Apache/2.2.3 (CentOS)</div><div class="line">Last-Modified:</div><div class="line">Content-Length: 6821</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">(data...)</div></pre></td></tr></table></figure>
<p>初始状态行，首部行和实体体，Date是服务器产生并且发送该响应报文的日期和时间。</p>
<h2 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h2><p>HTTP使用cookie允许站点对用户进行跟踪</p>
<p>HTTP响应报文中一个cookie首部行，HTTP请求报文中一个cookie首部行，用户端系统保留有一个cookie文件，并有用户的浏览器进行管理，后端Web站点有一个后端数据库。</p>
<p>cookie用于标识一个用户，用户首次访问一个站点需要一个用户标识，cookie可以在无状态的HTTP上建立了一个用户会话层。</p>
<h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体，具体内容见书74页。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<p>通过使用内容分发网络，CDN，web缓存器，CDN公司安装了地理上分散的缓存器，使得大量流量本地化。</p>
<h2 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h2><p>http协议有一种机制，允许缓存器证实它的对象是最新的，就是条件get方法，请求报文使用get方法， 有一个<code>If-Modified-Since</code>首部，其内容是日期，指当指定日期之后该对象被修改过，才发送该对象。作为对条件get方法的响应，web服务器仍然发送一个响应报文，但是没有在响应报文中包含所请求的对象，如果没有修改过的话。<code>304 Not Modified</code>表示缓存器可以使用该对象，能向请求的浏览器转发它缓存的该对象副本。</p>
<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>FTP与HTTP都是运行在TCP上，FTP用了两个并行的TCP来传输文件，一个是控制链接，一个是数据连接。控制链接用于在两主机上传输控制信息，数据连接用于实际发送文件数据，HTTP是在同一个TCP连接内发送请求和响应的，HTTP是带内发送控制信息的，FTP是带外发送控制信息的。</p>
<p>FTP的客户首先在服务器21号端口发起一个用于控制的TCP连接。对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话的每次文件传输都需要建立一个新的数据连接，数据连接是非持续的。</p>
<p>FTP服务器将对每个进行中的用户会话状态信息进行追踪，大大限制了FTP同时维护的会话总数。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。&lt;/p&gt;
&lt;h1 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;heade
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python后台开发工程师面试指南</title>
    <link href="http://microndgt.github.io/2017/02/17/Python%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://microndgt.github.io/2017/02/17/Python后台开发工程师面试指南/</id>
    <published>2017-02-17T09:15:39.000Z</published>
    <updated>2017-02-23T10:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者得天下。。万一有面试者提前看了这篇文章，那就偷着乐吧，啊哈哈哈哈。</p>
<h1 id="Python篇"><a href="#Python篇" class="headerlink" title="Python篇"></a>Python篇</h1><h2 id="序列倒序"><a href="#序列倒序" class="headerlink" title="序列倒序"></a>序列倒序</h2><p>这个问题是我乐此不疲的问题之一，方法有好多种。。。另外，记住拼写，<code>reverse</code>，好多面试者写错了= =</p>
<ol>
<li><code>a[::-1]</code></li>
<li>对于列表<code>a.reverse()</code>,原地倒序</li>
<li>对于字符串不可变对象，<code>&#39;&#39;.join(list(reversed(a)))</code></li>
</ol>
<h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>这个主要有两种常用方法一种套路</p>
<ol>
<li><code>sorted(a.items(), key=lambda x: x[0])</code></li>
<li>使用itemgetter</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">sorted(a.items(), key=itemgetter(0))</div></pre></td></tr></table></figure>
<p>对列表字典等结构排序也很容易。</p>
<h2 id="寻找序列中次数最多的元素"><a href="#寻找序列中次数最多的元素" class="headerlink" title="寻找序列中次数最多的元素"></a>寻找序列中次数最多的元素</h2><p>这个问题在leetcode刷题的时候遇到过，当时是用字典手动实现的，但是用<code>collections</code>模块的<code>Counter</code>类更简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">word_counts = Counter(word)</div><div class="line">top_three = word_counts.most_common(3)</div></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>实现一个简单的闭包，以及阐述其特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def func(name):</div><div class="line">    def inner_func(age):</div><div class="line">        print &apos;name:&apos;, name, &apos;age:&apos;, age</div><div class="line">    return inner_func</div></pre></td></tr></table></figure>
<p>在python中很重要也很常见的一个使用场景就是装饰器，Python为装饰器提供了一个很友好的“语法糖”——<code>@</code>，让我们可以很方便的使用装饰器</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>实现一个简单的生成器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def odd():</div><div class="line">    n = 1</div><div class="line">    while True:</div><div class="line">        yield n</div><div class="line">        n += 2</div><div class="line">odd_num = odd()</div><div class="line">count = 0</div><div class="line">for o in odd_num:</div><div class="line">    if count &gt;= 5: break</div><div class="line">    print(o)</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h2 id="静态方法，类方法，实例方法的区别"><a href="#静态方法，类方法，实例方法的区别" class="headerlink" title="静态方法，类方法，实例方法的区别"></a>静态方法，类方法，实例方法的区别</h2><p>实例方法就是类的实例能够使用的方法。</p>
<p>静态方法是一种普通函数，就位于类定义的命名空间中，它不会对任何实例类型进行操作。使用装饰器<code>@staticmethod</code>定义静态方法。</p>
<p>类方法是将类本身作为对象进行操作的方法。类方法使用<code>@classmethod</code>装饰器定义，其第一个参数是类，约定写为<code>cls</code>。类对象和实例都可以调用类方法</p>
<h2 id="Python中有哪几种导入方法"><a href="#Python中有哪几种导入方法" class="headerlink" title="Python中有哪几种导入方法"></a>Python中有哪几种导入方法</h2><ul>
<li><code>import modname</code></li>
<li><code>from modname import a</code></li>
<li>内建函数<code>__import__()</code></li>
</ul>
<h2 id="一个使用上下文管理器的例子"><a href="#一个使用上下文管理器的例子" class="headerlink" title="一个使用上下文管理器的例子"></a>一个使用上下文管理器的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with open(filename, mode) as writer:</div><div class="line">    writer.write(&quot;hello&quot;)</div><div class="line">    writer.write(&quot;world&quot;)</div></pre></td></tr></table></figure>
<h2 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Celsius:</div><div class="line">    def __init__(self, temperature = 0):</div><div class="line">        self._temperature = temperature</div><div class="line">    def to_fahrenheit(self):</div><div class="line">        return (self.temperature * 1.8) + 32</div><div class="line">    @property</div><div class="line">    def temperature(self):</div><div class="line">        print(&quot;Getting value&quot;)</div><div class="line">        return self._temperature</div><div class="line">    @temperature.setter</div><div class="line">    def temperature(self, value):</div><div class="line">        if value &lt; -273:</div><div class="line">            raise ValueError(&quot;Temperature below -273 is not possible&quot;)</div><div class="line">        print(&quot;Setting value&quot;)</div><div class="line">        self._temperature = value</div></pre></td></tr></table></figure>
<h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><h2 id="简述Python全局锁问题"><a href="#简述Python全局锁问题" class="headerlink" title="简述Python全局锁问题"></a>简述Python全局锁问题</h2><p>线程安全: 在多线程环境中，当各线程不共享数据的时候，那么一定是线程安全的。问题是这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。</p>
<p>Python全局锁问题: 解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="因特网的协议栈由哪几个层次组成？"><a href="#因特网的协议栈由哪几个层次组成？" class="headerlink" title="因特网的协议栈由哪几个层次组成？"></a>因特网的协议栈由哪几个层次组成？</h2><ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<h2 id="运输层有哪两种主要的协议，有什么特点"><a href="#运输层有哪两种主要的协议，有什么特点" class="headerlink" title="运输层有哪两种主要的协议，有什么特点."></a>运输层有哪两种主要的协议，有什么特点.</h2><ul>
<li><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
</li>
<li><p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<h2 id="简述web缓存器（代理服务器）的作用和特点。"><a href="#简述web缓存器（代理服务器）的作用和特点。" class="headerlink" title="简述web缓存器（代理服务器）的作用和特点。"></a>简述web缓存器（代理服务器）的作用和特点。</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支的原理</p>
<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h2 id="REST表现层状态迁移"><a href="#REST表现层状态迁移" class="headerlink" title="REST表现层状态迁移"></a>REST表现层状态迁移</h2><p>如何理解web service</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统的本质是什么？"><a href="#操作系统的本质是什么？" class="headerlink" title="操作系统的本质是什么？"></a>操作系统的本质是什么？</h2><p>对计算机资源的调度</p>
<h2 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h2><p>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。</p>
<p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="Reverse-a-singly-linked-list"><a href="#Reverse-a-singly-linked-list" class="headerlink" title="Reverse a singly linked list."></a>Reverse a singly linked list.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Definition for singly-linked list.</div><div class="line"># class ListNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution(object):</div><div class="line">    def reverseList(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        &quot;&quot;&quot;</div></pre></td></tr></table></figure>
<h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>Given two binary trees, write a function to check if they are equal or not.<br>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># Definition for a binary tree node.</div><div class="line"># class TreeNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution(object):</div><div class="line">    def isSameTree(self, p, q):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type p: TreeNode</div><div class="line">        :type q: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        #判断结构和值，并且注意空节点的判断</div><div class="line">        if p is None and q is None:</div><div class="line">            return True</div><div class="line">        elif p is None or q is None:</div><div class="line">            return False</div><div class="line">        else:</div><div class="line">            if p.val == q.val:</div><div class="line">                #值相同的时候，比较左子树</div><div class="line">                if self.isSameTree(p.left,q.left):</div><div class="line">                    #如果左子树相同，比较右子树</div><div class="line">                    return self.isSameTree(p.right,q.right)</div><div class="line">            #如果值不相同</div><div class="line">            return False</div></pre></td></tr></table></figure>
<h1 id="web（flask）"><a href="#web（flask）" class="headerlink" title="web（flask）"></a>web（flask）</h1><h2 id="web程序的结构，开发模式"><a href="#web程序的结构，开发模式" class="headerlink" title="web程序的结构，开发模式"></a>web程序的结构，开发模式</h2><h2 id="蓝本的作用"><a href="#蓝本的作用" class="headerlink" title="蓝本的作用"></a>蓝本的作用</h2><p>蓝本中定义的路由处于休眠状态，直到蓝本注册到程序中后，路由才真正成为程序的一部分。蓝本可以在单个文件定义，也可以用结构化的方式在包中的多个模块中构建。</p>
<h2 id="如何理解restful"><a href="#如何理解restful" class="headerlink" title="如何理解restful"></a>如何理解restful</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者
    
    </summary>
    
      <category term="面试" scheme="http://microndgt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>密钥加解密</title>
    <link href="http://microndgt.github.io/2017/02/17/%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://microndgt.github.io/2017/02/17/密钥加解密/</id>
    <published>2017-02-17T08:03:45.000Z</published>
    <updated>2017-02-17T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用不同的加密算法与加密模式进行加密"><a href="#使用不同的加密算法与加密模式进行加密" class="headerlink" title="使用不同的加密算法与加密模式进行加密"></a>使用不同的加密算法与加密模式进行加密</h1><p><code>openssl enc</code>加密解密文件,<code>openssl enc ciphertype -e -in plain.txt -out cipher.bin -K 00112233445566778899aabbccddeeff -iv 0102030405060708</code></p>
<p>cipher 密码，密码(cipher):指 bf, cast, des, aes, rs2 等 加密模式(encryption mode):指 cbc, ecb, cfb, ofb 等。两者组合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-K/-iv 十六进制密钥与初始向量</div><div class="line">-e 加密</div><div class="line">-d 解密</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;a href=&quot;#使用不同的加密算法与加密模式进行加密&quot; class=&quot;headerlink&quot; title=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;/a&gt;使用不同的加密算法与加密模式进行加密&lt;/h1&gt;&lt;p&gt;&lt;code&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://microndgt.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://microndgt.github.io/2017/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://microndgt.github.io/2017/02/17/计算机网络/</id>
    <published>2017-02-17T06:03:41.000Z</published>
    <updated>2017-02-18T11:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><h2 id="网络的具体构成"><a href="#网络的具体构成" class="headerlink" title="网络的具体构成"></a>网络的具体构成</h2><p>设备：主机或端系统，端系统通过通信链路和分组交换机链接在一起，链路的速率是bps度量，数据发送是，发送端将数据分段，每段加上首部字节。这样的信息包称为分组。两种分组交换机是路由器和链路层交换机。分组交换机类似于立交桥。</p>
<p>端系统通过因特网服务提供商ISP接入互联网，每个ISP是一个由多个分组交换机和多段通信链路组成的网络。地层ISP通过国家的，国际的高层ISP互联起来，高层ISP是由通过高速光纤链路互联的高速路由器组成的。</p>
<p>信息接收和发送的协议：TCP传输控制协议,IP网际协议。</p>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><p>从为应用程序提供服务的基础设施的角度来描述互联网，互联网是一种基础设施，新应用程序正在其上不断的发明和设置。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>完成一项工作，要求两个通信实体运行相同的协议。一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和接收或其他事件方面所采取的动作。</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>端系统连接到器边缘路由器的物理链路，边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>通过网络链路和交换机移动数据有两种方法，电路交换和分组交换。电路交换需要的资源在通信会话期间会被预留。分组交换网络，这些资源不被预留。电话网络是电路交换网络。因特网是分组交换网络。因特网尽力而为的以适时的方式传递分组。</p>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>存储转发传输，当路由器已经接收完了该分组的所有比特后，它才能开始向出链路传输，即转发该分组</p>
<p>排队时延和分组丢失，对于每条相连的链路，该分组交换机有一个输出缓存，缓存空间是有限的，网络拥塞程度越大，排队时延越大，还有可能出现分组丢失。</p>
<p>转发表和路由选择协议，源在该分组的首部包含了目的地的IP地址，每台路由器具有一个转发表，用于将目的地址映射城输出链路。路由器使用分组的目的地址来索引转发表并决定适当的出链路，因特网具有一些特殊的路由选择协议，用于自动的设置这些转发表，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>在端系统间通话会话期间，预留了端系统间通信沿路径所需要的资源，缓存，链路传输速率，传统的电话网络是电路交换网络的例子，建立链接后，沿着发送方和接收方之间路径上的交换机都将为该链接维护链接状态，当网络创建这种电路时候，他也在链接期间在该网络链路上预留了恒定的传输速率，表示为每条链路传输容量的一部分。</p>
<h2 id="分组交换网中的时延"><a href="#分组交换网中的时延" class="headerlink" title="分组交换网中的时延"></a>分组交换网中的时延</h2><p>分组在每个节点经受了以下几种不同类型的时延，节点处理时延，排队时延，传输时延和传播时延，加起来是节点总时延。</p>
<p>处理时延，检查分组首部和决定将分组导向何处所需要的时间是处理时延的一部分。处理之后，路由器将该分组引向通往路由器B链路之前的队列。</p>
<p>排队时延，在队列中，当分组在链路上等待传输的时候，经受排队时延。到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数。</p>
<p><strong><em>传输时延</em></strong>,传输时延L/R是将所有分组的比特推向链路所需要的时间</p>
<p>传播时延，从链路的起点到路由器B传播所需要的时间是传播时延</p>
<h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>到达路由器队列的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，丢包现象是一个分组已经传输到网络核心，绝不会从网络发送到目的地，分组丢失的份额随着流量强度增加而增加，因此，一个节点的性能也需要根据分组丢失的概率来度量。</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>除了时延和丢包，另外一个性能指标是端到端吞吐量，在任何时间瞬时吞吐量是主机B接受到该文件的速率。对于简单的两链路的网络，吞吐量是最小的链路速率，它是瓶颈链路的传输速率。吞吐量取决于数据流过的链路的传输速率，近似于沿着源和目的地之间路径的最小传输速率。</p>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>分层只要每个层次的接口不变，实现的功能不变，那么怎么实现它，改变服务的实现而不影响该系统其他组件是分层的优点。每层通过在该层中执行某些动作或使用直接下层的服务来提供服务。因特网的协议栈由5个层次组成，物理层，链路层，网络层，运输层和应用层。</p>
<p>应用层，HTTP，SMTP，FTP，DNS，位于应用层的信息分组称为报文</p>
<p>运输层，在应用程序端点之间传送应用层报文。TCP，面向连接的服务，确保传递和流量控制。UDP提供无连接服务，运输层分组称为报文段</p>
<p>网络层，负责将数据报的网络层分组从一台主机移动到另一台主机，IP协议，协议定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段，也包括决定路由的路由选择协议，IP是将因特网链接在一起的</p>
<p>链路层，一个数据报可能被沿途不同链路上的不同链路层协议处理，网络层将受到来自每个不同的链路层协议的不同服务，链路层分组称为帧</p>
<p>物理层，将帧中的一个个比特从一个节点移动到下一个节点，这层的协议是链路相关的，进一步和链路的实际传输媒体相关。</p>
<p>OSI模型中多了两层，表示层和会话层，在应用层和运输层之间，表示层的作用是使得通信的应用程序能够解释交换数据的含义，会话层提供了数据交换定界功能，应用程序开发者决定一个服务是否重要，在应用程序中构建该功能。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>路由器和链路层交换机以多层次的方式组织他们的网络硬件和软件，链路层交换机实现了物理层和链路层，路由器实现了物理层，链路层和网络层，能够实现IP协议，链路层交换机不能识别IP地址，但是能够识别第二层地址，以太网地址。</p>
<p>应用层报文传到运输层，加上运输层首部信息形成运输层报文段，然后向网路层传递报文段，网路层增加源和目的端系统地址等网路层首部信息，产生了网路层数据报，然后传给链路层，链路层增加自己的链路层首部信息并且创建链路层帧。所以一个分组具有两种类型的字段，首部字段和有效载荷字段。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。&lt;/p&gt;
&lt;h1 id=&quot;因特网&quot;&gt;&lt;a href=&quot;#因特网&quot; class=&quot;headerlink&quot; title=&quot;因特网&quot;&gt;&lt;/a&gt;因特网&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 元编程2</title>
    <link href="http://microndgt.github.io/2017/02/17/Python-%E5%85%83%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/17/Python-元编程2/</id>
    <published>2017-02-17T02:16:05.000Z</published>
    <updated>2017-02-17T03:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器为被包装函数增加参数"><a href="#装饰器为被包装函数增加参数" class="headerlink" title="装饰器为被包装函数增加参数"></a>装饰器为被包装函数增加参数</h1><p>在装饰器中给被包装函数增加额外的参数,可以使用关键字参数来给被包装函数增加额外参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def optional_debug(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=True, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def spam(a, b, c):</div><div class="line">    print(a, b, c)</div><div class="line">spam(1, 2, 3)</div><div class="line">spam(1, 2, 3, debug=True)</div></pre></td></tr></table></figure>
<p>可以避免一些重复代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def a(x, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling a&apos;)</div><div class="line">def b(x, y, z, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling b&apos;)</div><div class="line">from functools import wraps</div><div class="line">import inspect</div><div class="line">def optional_debug(func):</div><div class="line">    if &apos;debug&apos; in inspect.getargspec(func).args:</div><div class="line">        raise TypeError(&apos;debug argument already defined&apos;)</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=False, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def a(x):</div><div class="line">    pass</div><div class="line">@optional_debug</div><div class="line">def b(x, y, z):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="使用装饰器扩充类的功能"><a href="#使用装饰器扩充类的功能" class="headerlink" title="使用装饰器扩充类的功能"></a>使用装饰器扩充类的功能</h1><p>通过反省或者重写类定义的某部分来修改它的行为，这种情况是类装饰器最好的使用场景了，下面是重写了特殊方法<code>__getattribute__</code>的类装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def log_getattribute(cls):</div><div class="line">    orig_getattribute = cls.__getattribute__</div><div class="line">    def new_getattribute(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return orig_getattribute(self, name)</div><div class="line">    cls.__getattribute__ = new_getattribute</div><div class="line">    return cls</div><div class="line">@log_getattribute</div><div class="line">class A:</div><div class="line">    def __init__(self, x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>类装饰器通常可以作为其他高级技术比如混入或元类的一种非常简洁的替代方案。</p>
<p>使用继承的方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class LoggedGetattribute:</div><div class="line">    def __getattribute__(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return super().__getattribute__(name)</div><div class="line"># Example:</div><div class="line">class A(LoggedGetattribute):</div><div class="line">    def __init__(self,x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<h1 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h1><p>通过改变实例创建方式来实现单例，缓存等。自定义创建实例的方式，可以定义一个元类并自己实现<code>__call__()</code>方法。继承type的类叫做元类，元类是创建类的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class NoInstance(type):</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        raise TypeError(&apos;can not instantiate directly&apos;)</div><div class="line">class Spam(metaclass=NoInstance):</div><div class="line">    @staticmethod</div><div class="line">    def grok(x):</div><div class="line">        print(&apos;Spam.grok&apos;)</div></pre></td></tr></table></figure>
<p>所以只能调用静态方法，不能创建它的实例。下面是实现单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Singleton(type):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        self.__instance = None</div><div class="line">        super().__init__(*args, **kwargs)</div><div class="line"></div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        if self.__instance is None:</div><div class="line">            self.__instance = super().__call__(*args, **kwargs)</div><div class="line">            return self.__instance</div><div class="line">        else:</div><div class="line">            return self.__instance</div><div class="line">class Spam(metaclass=Singleton):</div><div class="line">    def __init__(self):</div><div class="line">        print(&apos;Creating Spam&apos;)</div></pre></td></tr></table></figure>
<p>利用元类实现多种实例创建模式通常要比不使用元类的方式优雅得多。</p>
<h1 id="定义有可选参数的元类"><a href="#定义有可选参数的元类" class="headerlink" title="定义有可选参数的元类"></a>定义有可选参数的元类</h1><p>定义类的时候，使用<code>metaclass</code>参数来指定特定的元类：元类是用来控制类的创建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxsize=None):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>在自定义元类中我们还可以提供其他的关键字参数,为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code> , <code>__new__()</code> 和 <code>__init__()</code> 方法中都使用强制关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Spam(metaclass=MyMeta, debug=True, synchronize=True):</div><div class="line">    pass</div><div class="line">class MyMeta(type):</div><div class="line">    # Optional</div><div class="line">    @classmethod</div><div class="line">    def __prepare__(cls, name, bases, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__prepare__(name, bases)</div><div class="line">    # Required</div><div class="line">    def __new__(cls, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__new__(cls, name, bases, ns)</div><div class="line">    # Required</div><div class="line">    def __init__(self, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        super().__init__(name, bases, ns)</div></pre></td></tr></table></figure>
<p><code>__prepare__()</code>方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code>方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code> 方法最后被调用，用来执行其他的一些初始化工作。通过使用强制关键字参数，在类的创建过程中我们必须通过关键字来指定这些参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;a href=&quot;#装饰器为被包装函数增加参数&quot; class=&quot;headerlink&quot; title=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;/a&gt;装饰器为被包装函数增加参数&lt;/h1&gt;&lt;p&gt;在装饰器中给被包装函数增加额外的参数,可以使用关键字
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式</title>
    <link href="http://microndgt.github.io/2017/02/15/Python-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://microndgt.github.io/2017/02/15/Python-设计模式/</id>
    <published>2017-02-15T07:56:20.000Z</published>
    <updated>2017-02-15T08:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式-The-Factory-Pattern"><a href="#工厂模式-The-Factory-Pattern" class="headerlink" title="工厂模式 The Factory Pattern"></a>工厂模式 The Factory Pattern</h1><p>解决对象创建问题，处理对象创建，客户端可以申请一个对象而不用知道对象被哪个class创建。可以方便地解耦对象的使用和创建。有两种实现，工厂方法和抽象工厂.</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>执行单独的函数，通过传参提供需要的对象的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line">import xml.etree.ElementTree as etree</div><div class="line">class JSONConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.data = dict()</div><div class="line">        with open(filepath, mode=&apos;r&apos;, encoding=&apos;utf8&apos;) as f:</div><div class="line">            self.data = json.load(f)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.data</div><div class="line">class XMLConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.tree = etree.parse(filepath)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.tree</div><div class="line">def connection_factory(filepath):</div><div class="line">    &quot;&quot;&quot; 工厂方法 &quot;&quot;&quot;</div><div class="line">    if filepath.endswith(&apos;json&apos;):</div><div class="line">        connector = JSONConnector</div><div class="line">    elif filepath.endswith(&apos;xml&apos;):</div><div class="line">        connector = XMLConnector</div><div class="line">    else:</div><div class="line">        raise ValueError(&apos;Cannot connect to &#123;&#125;&apos;.format(filepath))</div><div class="line">    return connector(filepath)</div></pre></td></tr></table></figure>
<h2 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h2><p>工厂方法适合对象种类较少的情况，如果有多种不同类型对象需要创建，使用抽象工厂模式。在一个抽象工厂类里实现多个关联对象的创建。也就是这些关联对象都实现了相同的方法，因此可以直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Frog:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        &quot;&quot;&quot; 不同类型玩家遇到的障碍不同 &quot;&quot;&quot;</div><div class="line">        print(&apos;&#123;&#125; the Frog encounters &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Bug:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;a bug&apos;</div><div class="line"></div><div class="line">    def action(self):</div><div class="line">        return &apos;eats it&apos;</div><div class="line">class FrogWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t----Frog World -----&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Frog(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Bug()</div><div class="line">class Wizard:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        print(&apos;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Ork:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;an evil ork&apos;</div><div class="line">    def action(self):</div><div class="line">        return &apos;kill it&apos;</div><div class="line">class WizardWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t------ Wizard World -------&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Wizard(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Ork()</div><div class="line">class GameEnvironment:</div><div class="line">    &quot;&quot;&quot; 抽象工厂，根据不同的玩家类型创建不同的角色和障碍 (游戏环境)</div><div class="line">    这里可以根据年龄判断，成年人返回『巫师』游戏，小孩返回『青蛙过河』游戏&quot;&quot;&quot;</div><div class="line">    def __init__(self, factory):</div><div class="line">        self.hero = factory.make_character()</div><div class="line">        self.obstacle = factory.make_obstacle()</div><div class="line">    def play(self):</div><div class="line">        self.hero.interact_with(self.obstacle)</div><div class="line">GameEnvironment(WizardWorld(&quot;kevin&quot;)).play()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式-The-Factory-Pattern&quot;&gt;&lt;a href=&quot;#工厂模式-The-Factory-Pattern&quot; class=&quot;headerlink&quot; title=&quot;工厂模式 The Factory Pattern&quot;&gt;&lt;/a&gt;工厂模式 The Facto
    
    </summary>
    
      <category term="设计模式" scheme="http://microndgt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程2</title>
    <link href="http://microndgt.github.io/2017/02/14/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/14/Python并发编程2/</id>
    <published>2017-02-14T04:23:49.000Z</published>
    <updated>2017-02-15T04:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程第二部分,并没有深入研究</p>
<h1 id="给关键部分加锁"><a href="#给关键部分加锁" class="headerlink" title="给关键部分加锁"></a>给关键部分加锁</h1><p>一次仅允许一个进程使用的资源称为临界资源。临界区内放的一般是被1个以上的进程或线程（以下只说进程）共用的数据。临界区内的数据一次只能同时被一个进程使用，当一个进程使用临界区内的数据时，其他需要使用临界区数据的进程进入等待状态。</p>
<p>在多线程程序中安全使用可变对象，使用threading库中的Lock对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value -= delta</div></pre></td></tr></table></figure>
<p>线程调度本质上是不稳定的。RLock可重入锁，可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下,当锁被持有时,只有一个线程可以使用完整 的函数或者类中的方法。一个被所 有实例共享的类级锁。这个锁用来同步类方法,具体来说就是,这个锁可以保证一次 只有一个线程可以调用这个类方法。不过,与一个标准的锁不同的是,已经持有这个 锁的方法在调用同样使用这个锁的方法时,无需再次获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    _lock = threading.RLock()</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self.incr(-delta)</div></pre></td></tr></table></figure>
<h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>死锁是由于线程同时获取多个锁造成的，一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。原来是这个意思，因为获得了第一个锁，所以该线程一直占用资源，但是阻塞又无法释放锁，所以造成死锁。阻塞的原因也可能是别的线程将这个锁占有，同时又需要上一个线程已经占用的锁。</p>
<p><strong><em>解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁</em></strong></p>
<p>使用上下文管理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">from contextlib import contextmanager</div><div class="line"># Thread-local state to stored information on locks already acquired，保存线程的状态信息</div><div class="line">_local = threading.local()</div><div class="line">@contextmanager</div><div class="line">def acquire(*locks):</div><div class="line">    # Sort locks by object identifier</div><div class="line">    locks = sorted(locks, key=lambda x: id(x))</div><div class="line">    # Make sure lock order of previously acquired locks is not violated</div><div class="line">    acquired = getattr(_local,&apos;acquired&apos;,[])</div><div class="line">    # 保证已经获得的锁最大值不大于新获得的锁的id值</div><div class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</div><div class="line">        raise RuntimeError(&apos;Lock Order Violation&apos;)</div><div class="line">    acquired.extend(locks)</div><div class="line">    _local.acquired = acquired</div><div class="line">    try:</div><div class="line">        for lock in locks:</div><div class="line">            lock.acquire()</div><div class="line">        yield</div><div class="line">    finally:</div><div class="line">        # Release locks in reverse order of acquisition</div><div class="line">        ＃ 由大到小释放锁</div><div class="line">        for lock in reversed(locks):</div><div class="line">            lock.release()</div><div class="line">        del acquired[-len(locks):]</div></pre></td></tr></table></figure>
<p>使用这个上下文管理器，不管用户以什么顺序来请求锁，这些锁都会按照固定的顺序被获取。因此不会发生死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">x_lock = threading.Lock()</div><div class="line">y_lock = threading.Lock()</div><div class="line">def thread_1():</div><div class="line">    while True:</div><div class="line">        with acquire(x_lock, y_lock):</div><div class="line">            print(&apos;Thread-1&apos;)</div><div class="line">def thread_2():</div><div class="line">    while True:</div><div class="line">        with acquire(y_lock, x_lock):</div><div class="line">            print(&apos;Thread-2&apos;)</div><div class="line">t1 = threading.Thread(target=thread_1)</div><div class="line">t1.daemon = True</div><div class="line">t1.start()</div><div class="line">t2 = threading.Thread(target=thread_2)</div><div class="line">t2.daemon = True</div><div class="line">t2.start()</div></pre></td></tr></table></figure>
<p>尽可能保证每一个线程只能同时保持一个锁，这样就不会产生死锁。一个常用的死锁检测方案是看门狗计数器，线程正常运行的时候会每隔一段时间重置计数器，一旦发生死锁，无法重置计数器导致定时器超时，这样程序会重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>哲学家进餐问题死锁避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line"># The philosopher thread</div><div class="line">def philosopher(left, right):</div><div class="line">    while True:</div><div class="line">        with acquire(left,right):</div><div class="line">             print(threading.currentThread(), &apos;eating&apos;)</div><div class="line"># The chopsticks (represented by locks)</div><div class="line">NSTICKS = 5</div><div class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</div><div class="line"># Create all of the philosophers</div><div class="line">for n in range(NSTICKS):</div><div class="line">    t = threading.Thread(target=philosopher,</div><div class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</div><div class="line">    t.start()</div></pre></td></tr></table></figure>
<h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><p>使用<code>thread.local()</code>创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">import threading</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = AF_INET</div><div class="line">        self.type = SOCK_STREAM</div><div class="line">        self.local = threading.local()</div><div class="line">    def __enter__(self):</div><div class="line">        if hasattr(self.local, &apos;sock&apos;):</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.local.sock = socket(self.family, self.type)</div><div class="line">        self.local.sock.connect(self.address)</div><div class="line">        return self.local.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.local.sock.close()</div><div class="line">        del self.local.sock        </div><div class="line">from functools import partial</div><div class="line">def test(conn):</div><div class="line">    with conn as s:</div><div class="line">        s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;)</div><div class="line">        s.send(b&apos;Host: www.python.org\r\n&apos;)</div><div class="line"></div><div class="line">        s.send(b&apos;\r\n&apos;)</div><div class="line">        resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;))</div><div class="line"></div><div class="line">    print(&apos;Got &#123;&#125; bytes&apos;.format(len(resp)))</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    conn = LazyConnection((&apos;www.python.org&apos;, 80))</div><div class="line"></div><div class="line">    t1 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t2 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div></pre></td></tr></table></figure>
<p>每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
<p>比如一个套接字或文件。你不能让所有线程贡献一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。所以之前传递什么文件的时候，会出现问题。</p>
<h1 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h1><p>你应该避免编写线程数量可以无限制增长的程序。</p>
<p>服务器端程序也应该这样做，至少要限制进程创建的数目，最大应该是8，然后使用Condition对象或者event，等到一个进程结束运行后，然后再将阻塞的创建进程的函数解除阻塞。</p>
<p>不过进程与线程区别是，线程可以无限制创造，但是进程与硬件，处理器核心数有关。</p>
<h1 id="Python的全局锁问题"><a href="#Python的全局锁问题" class="headerlink" title="Python的全局锁问题"></a>Python的全局锁问题</h1><p>Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<p>依赖CPU的程序，优化底层算法要比使用多线程运行快得多。由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，并且函数参数和返回值必须要兼容pickle。</p>
<h1 id="定义一个Actor任务"><a href="#定义一个Actor任务" class="headerlink" title="定义一个Actor任务"></a>定义一个Actor任务</h1><p>actor最简单的并行和分布式计算解决方案，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。</p>
<p>结合使用一个线程和一个队列可以很容易的定义actor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line"></div><div class="line"># Sentinel used for shutdown</div><div class="line">class ActorExit(Exception):</div><div class="line">    pass</div><div class="line"></div><div class="line">class Actor:</div><div class="line">    def __init__(self):</div><div class="line">        self._mailbox = Queue()</div><div class="line">    def send(self, msg):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Send a message to the actor</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._mailbox.put(msg)</div><div class="line">    def recv(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Receive an incoming message</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        msg = self._mailbox.get()</div><div class="line">        if msg is ActorExit:</div><div class="line">            raise ActorExit()</div><div class="line">        return msg</div><div class="line">    def close(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Close the actor, thus shutting it down</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self.send(ActorExit)</div><div class="line">    def start(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Start concurrent execution</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._terminated = Event()</div><div class="line">        t = Thread(target=self._bootstrap)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def _bootstrap(self):</div><div class="line">        try:</div><div class="line">            self.run()</div><div class="line">        except ActorExit:</div><div class="line">            pass</div><div class="line">        finally:</div><div class="line">            self._terminated.set()</div><div class="line">    def join(self):</div><div class="line">        self._terminated.wait()</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run method to be implemented by the user</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line"># Sample ActorTask</div><div class="line">class PrintActor(Actor):</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line">            print(&apos;Got:&apos;, msg)</div><div class="line"># Sample use</div><div class="line">p = PrintActor()</div><div class="line"># 开启了一个线程，轮询</div><div class="line">p.start()</div><div class="line">p.send(&apos;Hello&apos;)</div><div class="line">p.send(&apos;World&apos;)</div><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure>
<h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>使用生成器（协程）替代系统线程来实现并发。这个有时又被称为用户级线程或绿色线程。yield 语句会让一个生成器挂起它的执行，这样就可以编写一个调度器， 将生成器当做某种“任务”并使用任务协作切换来替换它们的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Two simple generator functions</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;T-minus&apos;, n)</div><div class="line">        yield</div><div class="line">        n -= 1</div><div class="line">    print(&apos;Blastoff!&apos;)</div><div class="line">def countup(n):</div><div class="line">    x = 0</div><div class="line">    while x &lt; n:</div><div class="line">        print(&apos;Counting up&apos;, x)</div><div class="line">        yield</div><div class="line">        x += 1</div></pre></td></tr></table></figure>
<p>下面是一个简单任务调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">class TaskScheduler:</div><div class="line">    def __init__(self):</div><div class="line">        self._task_queue = deque()</div><div class="line">    def new_task(self, task):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Admit a newly started task to the scheduler</div><div class="line"></div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._task_queue.append(task)</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run until there are no more tasks</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while self._task_queue:</div><div class="line">            task = self._task_queue.popleft()</div><div class="line">            try:</div><div class="line">                # Run until the next yield statement</div><div class="line">                next(task)</div><div class="line">                self._task_queue.append(task)</div><div class="line">            except StopIteration:</div><div class="line">                # Generator is no longer executing</div><div class="line">                pass</div><div class="line"># Example use</div><div class="line">sched = TaskScheduler()</div><div class="line">sched.new_task(countdown(10))</div><div class="line">sched.new_task(countdown(5))</div><div class="line">sched.new_task(countup(15))</div><div class="line">sched.run()</div></pre></td></tr></table></figure>
<p> 生成器函数就是认为，而yield语句是任务挂起的信号。调度器循环检查任务列表直到没有任务要执行为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程第二部分,并没有深入研究&lt;/p&gt;
&lt;h1 id=&quot;给关键部分加锁&quot;&gt;&lt;a href=&quot;#给关键部分加锁&quot; class=&quot;headerlink&quot; title=&quot;给关键部分加锁&quot;&gt;&lt;/a&gt;给关键部分加锁&lt;/h1&gt;&lt;p&gt;一次仅允许一个进程使用的资源称为临界资源。临界区内放
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/13/Python并发编程/</id>
    <published>2017-02-13T04:49:52.000Z</published>
    <updated>2017-02-14T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，调用子进程，生成器函数，并行计算</p>
<h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p>threading库可以在单独的线程中执行任何的在Python中可以调用的对象，可以创建一个Thread对象并且将要执行的对象以target参数的形式提供给该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">t = Thread(target=countdown, args=(10, ))</div><div class="line">t.start()</div></pre></td></tr></table></figure>
<p>线程会在一个单独的系统级线程中执行，这些线程由操作系统全权管理，一旦启动，独立执行到目标函数返回。查询线程状态<code>t.is_alive()</code>，将一个线程加入到当前线程，等待它终止<code>t.join()</code></p>
<p>Python解释器在所有线程都终止后才继续执行代码，所以长时间运行的线程或者需要一直运行的后台任务，使用后台线程。<code>t = Thread(target=countdown, args=(10, ), daemon=True)</code></p>
<p>后台线程无法等待，但是这些线程会在主线程终止时候自动销毁，但是无法结束线程，必须自己写一个调度类来实现这些功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class CountdownTask:</div><div class="line">    def __init__(self):</div><div class="line">        self.running = True</div><div class="line">    def terminate(self):</div><div class="line">        self.running = False</div><div class="line">    def run(self, n):</div><div class="line">        while self.running and n &gt; 0:</div><div class="line">            print(&quot;T-minus&quot;, n)</div><div class="line">            n -= 1</div><div class="line">            time.sleep(5)</div><div class="line">c = CountdownTask()</div><div class="line">t = Thread(target=c.run, args=(10,))</div><div class="line">t.start()</div><div class="line">c.terminate()</div><div class="line">t.join()</div></pre></td></tr></table></figure>
<p>如果线程执行I/O阻塞操作，name就应该使用超时循环来操作线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class IOTask:</div><div class="line">    def terminate(self):</div><div class="line">        self._running = False</div><div class="line">    def run(self, sock):</div><div class="line">        sock.settimeout(5)</div><div class="line">        while self._running:</div><div class="line">            try:</div><div class="line">                data = sock.recv(8192)</div><div class="line">                break</div><div class="line">            except socket.timeout:</div><div class="line">                continue</div><div class="line">        return</div></pre></td></tr></table></figure>
<p>Python线程被限制到同一时刻只允许一个线程执行，所以Python线程更适用于I/O和其他需要并发执行的阻塞操作，而不是需要多处理器并行的计算密集型任务。</p>
<p>以下的实现的线程也可以工作，但是依赖于threading库，所以只能在线程上下文中使用，但是上面的与threading库无关，所以可以被用在其他上下文中，比如在multiprocessing单独进程中执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">class CountdownTask(Thread):</div><div class="line">    def __init__(self, n):</div><div class="line">        super().__init__()</div><div class="line">        self.n = 0</div><div class="line">    def run(self):</div><div class="line">        while self.n &gt; 0:</div><div class="line">            self.n -= 1</div><div class="line">            time.sleep(5)</div></pre></td></tr></table></figure>
<h1 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h1><p>程序其他线程判断某个线程的状态来确定下一步，使用threading的Event来设置一个信号标志来协调线程的启动。初始状态为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from threading import Thread, Event</div><div class="line">import time</div><div class="line">def countdown(n, started_evt):</div><div class="line">    print(&quot;starting&quot;)</div><div class="line">    # 在此设置event对象为真</div><div class="line">    started_evt.set()</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;t-minus&apos;)</div><div class="line">        n -= 1</div><div class="line">        time.sleep(2)</div><div class="line">started_evt = Event()</div><div class="line">print(&apos;launching countdown&apos;)</div><div class="line">t = Thread(target=countdown, args=(10, started_evt))</div><div class="line">t.start()</div><div class="line"># 为真后执行继续执行主线程</div><div class="line">started_evt.wait()</div><div class="line">print(&apos;running&apos;)</div></pre></td></tr></table></figure>
<p>event对象最好单次使用，一旦对象设置为真，就应该丢弃它。如果需要多次使用，则使用Condition对象代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line">class PeriodcTimer:</div><div class="line">    def __init__(self, interval):</div><div class="line">        self._interval = interval</div><div class="line">        self._flag = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def start(self):</div><div class="line">        t = threading.Thread(target=self.run)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            time.sleep(self._interval)</div><div class="line">            with self._cv:</div><div class="line">                self._flag ^= 1</div><div class="line">                self._cv.notify_all()</div><div class="line">    def wait_for_tick(self):</div><div class="line">        with self._cv:</div><div class="line">            last_flag = self._flag</div><div class="line">            while last_flag == self._flag:</div><div class="line">                # 当每次有notify_all时候结束循环,开始计数</div><div class="line">                self._cv.wait()</div><div class="line">ptiemr = PeriodcTimer(5)</div><div class="line">ptiemr.start()</div><div class="line">def countdown(nticks):</div><div class="line">    while nticks &gt; 0:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;T-minus&quot;, nticks)</div><div class="line">        nticks -= 1</div><div class="line">def countup(last):</div><div class="line">    n = 0</div><div class="line">    while n &lt; last:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;counting&quot;, n)</div><div class="line">        n += 1</div><div class="line">threading.Thread(target=countdown, args=(10, )).start()</div><div class="line">threading.Thread(target=countup, args=(5, )).start()</div></pre></td></tr></table></figure>
<p>event当它设置为真的时候会唤醒所有等待它的线程，如果只想唤醒单个线程，最好使用信号量或者Condition对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def worker(n, sema):</div><div class="line">    sema.acquire()</div><div class="line">    print(&quot;working &quot;, n)</div><div class="line">sema = threading.Semaphore(0)</div><div class="line">nworkers = 10</div><div class="line">for n in range(nworkers):</div><div class="line">    # 会启动一个线程池，但是所有线程都在等待获取信号量</div><div class="line">    t = threading.Thread(target=worker, args=(n, sema, ))</div><div class="line">    t.start()</div><div class="line"># 每次释放信号量的时候，只有一个线程会唤醒并且执行</div><div class="line">sema.release()</div></pre></td></tr></table></figure>
<p>使用队列来进行线程间通信或者把每个线程当成一个Actor，使用Actor模型控制并发。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式是使用queue库中的队列。创建一个被多个线程共享的Queue对象，这些线程通过使用put()和get()方法来向队列中添加或者删除元素。Queue中含有了必要的锁，可以在多个线程中安全地共享数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line"># 哨兵</div><div class="line">_sentinel = object()</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">    out_q.put(_sentinel)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        if data is _sentinel:</div><div class="line">            # 再放回去，这样所有监听这个队列的消费者线程就可以都关闭了。</div><div class="line">            in_q.put(_sentinel)</div><div class="line">            break</div></pre></td></tr></table></figure>
<p>使用Condition变量来包装数据结构，创建一个线程安全的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">import threading</div><div class="line">class PriorityQueue:</div><div class="line">    def __init__(self):</div><div class="line">        self._queue = []</div><div class="line">        self._count = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def put(self, item, priority):</div><div class="line">        with self._cv:</div><div class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</div><div class="line">            self._count += 1</div><div class="line">            self._cv.notify()</div><div class="line">    def get(self):</div><div class="line">        with self._cv:</div><div class="line">            while len(self._queue) == 0:</div><div class="line">                # 在这里阻塞,而不是循环，直到添加元素后解除阻塞</div><div class="line">                self._cv.wait()</div><div class="line">            # 获取优先级最低的</div><div class="line">            return heapq.heappop(self._queue)[-1]</div></pre></td></tr></table></figure>
<p>使用task_done()和join()来表示已经完成,q.task_done()，每次从queue中get一个数据之后，当处理好相关问题，最后调用该方法，以提示q.join()是否停止阻塞，让线程向前执行或者退出；q.join()，阻塞，直到queue中的数据均被删除或者处理。为队列中的每一项都调用一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        in_q.task_done()</div><div class="line">q = Queue()</div><div class="line">t2 = Thread(target=producer, args=(q, ))</div><div class="line">t1 = Thread(target=consumer, args=(q, ))</div><div class="line">t2.start()</div><div class="line">t1.start()</div><div class="line">q.join() #所有生产的都被消费</div></pre></td></tr></table></figure>
<p>使用event当消费者线程处理完数据后生产者立即得到通知，来监测处理过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        evt = Event()</div><div class="line">        out_q.put((data, event))</div><div class="line">        evt.wait()</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data, evt = in_q.get()</div><div class="line">        evt.set()</div></pre></td></tr></table></figure>
<p>使用线程队列需要注意向队列中添加数据项并不会复制此数据项，实际上是在线程中传递对象引用。可以使用不变结构或者深拷贝。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，调用子进程，生成器函数，并行计算&lt;/p&gt;
&lt;h1 id=&quot;启动和停止线程&quot;&gt;&lt;a href=&quot;#启动和停止线程&quot; class=&quot;headerlink&quot; title=&quot;启动和停止线程&quot;&gt;&lt;/a&gt;启动和停止线程&lt;/h1&gt;&lt;p&gt;threading库可以在单独的线程中执行任
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Intro to Backend 1</title>
    <link href="http://microndgt.github.io/2017/02/13/Intro-to-backend-1/"/>
    <id>http://microndgt.github.io/2017/02/13/Intro-to-backend-1/</id>
    <published>2017-02-13T04:43:57.000Z</published>
    <updated>2017-02-13T04:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，Introduction to the web</p>
<p>万维网是HTML文档的集合，这些文件由HTML组成</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一部分，Introduction to the web&lt;/p&gt;
&lt;p&gt;万维网是HTML文档的集合，这些文件由HTML组成&lt;/p&gt;

    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程管理</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://microndgt.github.io/2017/02/13/Python多进程管理/</id>
    <published>2017-02-13T01:41:53.000Z</published>
    <updated>2017-02-13T03:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class MyProcManager(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div><div class="line">    def terminate_all(self):</div><div class="line">        with self._lock:</div><div class="line">            for p in self.procs:</div><div class="line">                if p.is_alive():</div><div class="line">                    print(&quot;Terminating %s&quot; % p)</div><div class="line">                    p.terminate()</div><div class="line">        self.cleaning()</div><div class="line">    def launch_proc(self, func, args=(), kwargs=&#123;&#125;):</div><div class="line">        t = threading.Thread(target=self._proc_thread_runner,</div><div class="line">                             args=(func, args, kwargs))</div><div class="line">        self._threads.append(t)</div><div class="line">        t.start()</div><div class="line">    def _proc_thread_runner(self, func, args, kwargs):</div><div class="line">        p = multiprocessing.Process(target=func, args=args, kwargs=kwargs)</div><div class="line">        self.procs.append(p)</div><div class="line">        p.start()</div><div class="line">        while p.exitcode is None:</div><div class="line">            p.join()</div><div class="line">        if p.exitcode &gt; 0:</div><div class="line">            self.errors_flag = True</div><div class="line">            self.terminate_all()</div><div class="line">    def wait(self):</div><div class="line">        for t in self._threads:</div><div class="line">            t.join()</div><div class="line">    def cleaning(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div></pre></td></tr></table></figure>
<p><code>cleaning</code>方法，因为自己在调用的时候在全局实例化了这个类，所以在每次运行完毕的时候需要重新初始化实例变量。</p>
<p>以下是调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t0 = time.time()</div><div class="line">for fundId in fundIds:</div><div class="line">    proc_manager.launch_proc(calc_ability_proc, args=(fundId, start_date, end_date, config))</div><div class="line">proc_manager.wait()</div><div class="line">if proc_manager.errors_flag:</div><div class="line">    return gen_response(data=None, message=&quot;some processes crashed&quot;, errorcode=1, status=&quot;error&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;Everything closed cleanly&quot;)</div><div class="line">proc_manager.cleaning()</div><div class="line">t1 = time.time()</div><div class="line">print(&quot;time used: %d min&quot; % ((t1 - t0) / 60))</div></pre></td></tr></table></figure>
<p>用了10个fundId进行测试，大约比单线程快了2倍，不过应该fundId越多，速度会越快吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用Python和Flask设计RESTful API</title>
    <link href="http://microndgt.github.io/2017/02/05/%E4%BD%BF%E7%94%A8Python%E5%92%8CFlask%E8%AE%BE%E8%AE%A1RESTful-API/"/>
    <id>http://microndgt.github.io/2017/02/05/使用Python和Flask设计RESTful-API/</id>
    <published>2017-02-05T03:25:20.000Z</published>
    <updated>2017-02-05T03:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST-REpresentational-State-Transfer表现层状态迁移"><a href="#REST-REpresentational-State-Transfer表现层状态迁移" class="headerlink" title="REST(REpresentational State Transfer表现层状态迁移)"></a>REST(REpresentational State Transfer表现层状态迁移)</h1><p>web services和web APIs</p>
<ul>
<li>客户端－服务器，两者隔离</li>
<li>无状态，一种服务器不会存储客户端上一次请求的信息用来下一次使用</li>
<li>可缓存，服务器明示客户端请求能否缓存</li>
<li>分层系统，客户端和服务器通信应该以一种标准方式，中间层代替服务器做出相应，客户端不需要做任何变动</li>
<li>统一接口，通信方法必须是统一的</li>
<li>按需编码：服务器可以提供可执行代码的脚本，为客户端在它们的环境中执行</li>
</ul>
<h1 id="RESTful-的-web-service"><a href="#RESTful-的-web-service" class="headerlink" title="RESTful 的 web service"></a>RESTful 的 web service</h1><p>核心是资源，资源可以用URI表示，客户端使用HTTP协议定义的方法来发送请求到这些URIs，当然可能会导致这些被访问的资源状态改变</p>
<p><code>GET,POST,PUT,DELETE</code></p>
<p>REST设计不需要特定的数据格式，在请求中数据可以以JSON形式，或者作为url中查询参数项。</p>
<h1 id="设计一个web-service"><a href="#设计一个web-service" class="headerlink" title="设计一个web service"></a>设计一个web service</h1><p>其实就是一个标识资源被展示出来以及它们是怎样受不同的请求方法影响。</p>
<p>首先设计URL: <code>http://[hostname]/todo/api/v1.0</code>，在URL中包含应用名称有助于提供一个命名空间以便区分同一系统上的其他服务，包含版本号能够帮助以后的更新，如果新版本中存在新的和潜在不兼容的功能，可以不影响依赖于旧的功能的应用程序。</p>
<p>现在从前端过来的也就是指令信息，然后发送给服务器，计算之后返回数据信息，主要在于要将这些数据格式化成json格式，把指令从json变成python可用的。</p>
<p>有这么几项，一个是登陆，密码验证之类。另外一个是开始计算，返回数据，已完成百分比，耗费时间。另外一个是返回summary数据，输入id的话返回对应的ability或者其他数据，这块也就是数据查询功能，看查询类型了</p>
<p>擦，在虚拟环境指定Python3也是不容易啊，<code>virtualenv backend -p /usr/local/bin/python3</code>使用用户安装的python3，貌似anaconda的Python3用不了</p>
<h1 id="Flask-restful使用"><a href="#Flask-restful使用" class="headerlink" title="Flask restful使用"></a>Flask restful使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask.ext import restful</div><div class="line"># 创建程序实例</div><div class="line">app = Flask(__name__)</div><div class="line">api = restful.Api(app)</div><div class="line"># 定义资源</div><div class="line">class HelloWorld(restful.Resource):</div><div class="line">    def get(self):</div><div class="line">        return &#123;&apos;hello&apos;: &apos;world&apos;&#125;</div><div class="line"># 添加资源</div><div class="line">api.add_resource(HelloWorld, &apos;/&apos;)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    # 开始运行</div><div class="line">    app.run(debug=True)</div></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST-REpresentational-State-Transfer表现层状态迁移&quot;&gt;&lt;a href=&quot;#REST-REpresentational-State-Transfer表现层状态迁移&quot; class=&quot;headerlink&quot; title=&quot;REST(R
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python元编程</title>
    <link href="http://microndgt.github.io/2017/02/04/Python%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/04/Python元编程/</id>
    <published>2017-02-04T07:02:23.000Z</published>
    <updated>2017-02-05T02:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。</p>
<h1 id="在函数上添加包装器"><a href="#在函数上添加包装器" class="headerlink" title="在函数上添加包装器"></a>在函数上添加包装器</h1><p>使用额外的代码包装一个函数，定义一个装饰器函数，一个装饰器就是一个函数，它接受一个函数作为参数并且返回一个新的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def timethis(func):</div><div class="line">    # 使用wraps的目的是为了防止函数信息变成wrapper的函数信息</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        start = time.time()</div><div class="line">        result = func(*args, **kwargs)</div><div class="line">        end = time.time()</div><div class="line">        print(func.__name__, end-start)</div><div class="line">        return result</div><div class="line">    return wrapper</div><div class="line">@timethis</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line"># 相当于</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line">countdown = timethis(countdown)</div></pre></td></tr></table></figure>
<p>所以真正执行的是装饰器函数中的闭包内部函数，使用装饰器并不会修改原始函数的参数签名以及返回值，使用<code>*args</code>和<code>**kwargs</code>的目的就是确保任何参数都能适用，而返回结果值都是调用原始函数<code>func(*args, **kwargs)</code>的返回结果。<code>@wraps(func)</code>注解是保留原始函数的元数据</p>
<h1 id="创建装饰器时保留函数元信息"><a href="#创建装饰器时保留函数元信息" class="headerlink" title="创建装饰器时保留函数元信息"></a>创建装饰器时保留函数元信息</h1><p>任何时候定义装饰器，都应该使用functools库中的<code>@wraps</code>装饰器来注解底层包装函数，这样就会复制原始函数的元信息。<code>@wraps</code>可以通过属性<code>__wrapped__</code>直接访问被包装函数，<code>countdown.__wrapped__(100000)</code></p>
<h1 id="解除一个装饰器"><a href="#解除一个装饰器" class="headerlink" title="解除一个装饰器"></a>解除一个装饰器</h1><p>如果装饰器是通过<code>@wraps</code>来实现的，那么可以访问<code>__wrapped__</code>属性来访问原始函数。</p>
<p>如果有多个包装器，那么访问<code>__wrapped__</code>属性的行为是不可预知的，而且仅仅适用于包装器正确使用了<code>@wraps</code>的情况。多个包装器，从内向外进行包装。</p>
<h1 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>最外层的函数logged()接受参数并将它们作用在内部的装饰器函数上。其实就相当于下面：<code>add = logged(logging.DEBUG)(add)</code>logged()返回的是一个可调用对象，接受一个函数作为参数并且包装它。</p>
<h1 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h1><p>用装饰器来包装函数，并且在运行时候提供参数控制装饰器的行为。方法是，引入一个访问函数，使用nolocal来修改内部变量，然后这个访问函数被作为一个属性赋值给包装函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def attach_wrapper(obj, func=None):</div><div class="line">    if func is None:</div><div class="line">        # 相当于将第一个参数默认了</div><div class="line">        return partial(attach_wrapper, obj)</div><div class="line">    # 这里相当于给这个对象设置了一个这个属性，后面可以直接调用</div><div class="line">    setattr(obj, func.__name__, func)</div><div class="line">    return func</div><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        # 这里将返回的wrapper作为对象，返回了一个包涵默认对象的attach_wrapper，然后再装饰set_level，只是为该对象设置了set_level属性</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_level(newlevel):</div><div class="line">            nonlocal level</div><div class="line">            level = newlevel</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_message(newmsg):</div><div class="line">            nonlocal logmsg</div><div class="line">            logmsg = newmsg</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">add.set_message(&apos;Add called&apos;)</div></pre></td></tr></table></figure>
<p>并且访问函数会在多层装饰器间传播</p>
<h1 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h1><p>一个装饰器可以不传参数，如<code>@decorator</code>，也可以传递参数给它，如<code>@decorator(x, y, z)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def logged(func=None, *, level=logging.DEBUG, name=None, message=None):</div><div class="line">    if func is None:</div><div class="line">        # 返回一个接受一个函数参数并且包装它的函数</div><div class="line">        return partial(logged, level=level, name=name, message=message)</div><div class="line">    logname = name if name else func.__module__</div><div class="line">    log = logging.getLogger(logname)</div><div class="line">    logmsg = message if message else func.__name__</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        log.log(level, logmsg)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line"># 不带参数，func不是None，调用类似于logged(func)</div><div class="line">@logged</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line"># 带参数，func为None，返回一个partial的函数logged,可选参数作为默认值</div><div class="line">@logged(level=logging.CRITICAL, name=&apos;example&apos;)</div><div class="line">def spam():</div><div class="line">    print(&quot;Spam!&quot;)</div></pre></td></tr></table></figure>
<p>如果定义一个所有参数都是可选的装饰器，那么使用语法糖的时候就要这样<code>@logged()</code>加上括号，否则就会出现问题。上面的第一个装饰器调用等价于<code>add = logged(add)</code>，而第2个调用等价于<code>spam = logged(level=logging.CRITICAL, name=&#39;example&#39;)(spam)</code>，使用了<code>functools.partial</code>这个技巧，它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定。</p>
<h1 id="将装饰器定义为类的一部分"><a href="#将装饰器定义为类的一部分" class="headerlink" title="将装饰器定义为类的一部分"></a>将装饰器定义为类的一部分</h1><p>在类中定义装饰器，并将其用在其他函数或者方法上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">class A:</div><div class="line">    def decorator1(self, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&quot;Decorator 1&quot;)</div><div class="line">            return func(*args, **kwrags)</div><div class="line">        return wrapper</div><div class="line">    @classmethod</div><div class="line">    def decorator2(cls, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&apos;Decorator 2&apos;)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">a = A()</div><div class="line">@a.decorator1</div><div class="line">def spam():</div><div class="line">    pass</div><div class="line">@A.decorator2</div><div class="line">def grok():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>一个是实例调用，一个是类调用，<code>@property</code>装饰器实际上是一个类，里面定义了三个方法，<code>getter()</code>,<code>setter()</code>,<code>deleter()</code>，每一个方法都是一个装饰器。这么定义的主要原因是各种不同的装饰器方法会在关联的property实例上操作它的状态，因此，只要需要在装饰器中记录或者绑定信息，都可以使用在类中定义装饰器的办法。</p>
<p>在类中定义装饰器对于额外参数self，cls，两个装饰器内部创建的wrapper函数并不需要这两个参数，唯一需要的时候是确实要访问包装器中这个实例的某些部分的时候。</p>
<p>涉及到继承的时候，应该这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class B(A):</div><div class="line">    @A.decorator2</div><div class="line">    def bar(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>装饰器被定义成类方法并且必须显式使用父类名去调用它，而不能用B，因为方法定义的时候类B还没有创建。</p>
<h1 id="将装饰器定义为类"><a href="#将装饰器定义为类" class="headerlink" title="将装饰器定义为类"></a>将装饰器定义为类</h1><p>使用一个装饰器去包装函数，但是返回一个可调用的实例，装饰器可以同时工作在类定义的内部和外部。</p>
<p>将装饰器定义成一个实例，确保其实现了<code>__call__()</code>和<code>__get__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import types</div><div class="line">from functools import wraps</div><div class="line">class Profiled:</div><div class="line">    def __init__(self, func):</div><div class="line">        wraps(func)(self)</div><div class="line">        self.ncalls = 0</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        self.ncalls += 1</div><div class="line">        return self.__wrapped__(*args, **kwargs)</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return types.MethodType(self, instance)</div><div class="line">@Profiled</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">class Spam:</div><div class="line">    @Profiled</div><div class="line">    def bar(self, x):</div><div class="line">        print(self, x)</div></pre></td></tr></table></figure>
<p>这一块居然没怎么看懂，我的妈呀～</p>
<h1 id="为类方法和静态方法提供装饰器"><a href="#为类方法和静态方法提供装饰器" class="headerlink" title="为类方法和静态方法提供装饰器"></a>为类方法和静态方法提供装饰器</h1><p>确保装饰器在<code>@classmethod</code>或者<code>@staticmethod</code>之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Spam:</div><div class="line">    @timethis</div><div class="line">    def instance_method(self, n):</div><div class="line">        pass</div><div class="line">    @classmethod</div><div class="line">    @timethis</div><div class="line">    def class_method(cls, n):</div><div class="line">        pass</div><div class="line">    @staticmethod</div><div class="line">    @timethis</div><div class="line">    def static_method(n):</div><div class="line">        pass</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。&lt;/p&gt;
&lt;h1 id=&quot;在函数上添加包装器&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象2</title>
    <link href="http://microndgt.github.io/2017/02/01/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A12/"/>
    <id>http://microndgt.github.io/2017/02/01/Python类与对象2/</id>
    <published>2017-02-01T04:29:49.000Z</published>
    <updated>2017-02-24T08:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-set-和-get-等解释"><a href="#Python-set-和-get-等解释" class="headerlink" title="Python __set__和__get__等解释"></a>Python <code>__set__</code>和<code>__get__</code>等解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class T:</div><div class="line">    name = &apos;name&apos;</div><div class="line">    def hello(self):</div><div class="line">        print(&apos;hello&apos;)</div><div class="line">t = T()</div></pre></td></tr></table></figure>
<p>使用<code>dir(t)</code>列出t的所有有效属性，分为两类，一类是Python自动产生的，一类是自定义的，如hello,name</p>
<p>类和实例对象，实际上Python中一切都是对象，类是type的实例，都有<code>__dict__</code>属性，里面存放他们的自定义属性</p>
<p><code>t.__dict__</code>是一个空字典，在t上没有自定义任何属性，它的有效属性hello和name都是从T得到的。查找t的name属性的时候，首先判断name属性是否是个自动产生的属性，如果是自动产生的，就按特别的方法找到这个属性，自定义的属性，从t的<code>__dict__</code>中寻找，没找到从类T中寻找,<code>T.__dict__</code>中寻找，然后返回，如果没有找到在父类中查找。</p>
<h2 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h2><p>查找属性的时候，如<code>obj.attr</code>，如果Python发现这个属性attr有个<code>__get__</code>方法，Python就会调用这个方法，返回这个方法的返回值，而不是attr。</p>
<p>descriptor是实现了某些特定方法的对象，<code>__get__</code>和<code>__set__</code>和<code>__delete__</code>，其中set和delete是可选的，另外描述器必须依附对象，作为对象的一个属性，而不能单独存在，描述器也必须存在类的<code>__dict__</code>中，只有在<strong><em>类</em></strong>的<code>__dict__</code>中找到属性，Python才会去看它有没有<code>__get__</code>，但是如果是实例的<code>__dict__</code>中找到的属性，那么不会去查看是否有<code>__get__</code>等方法，直接返回属性本身。</p>
<p>描述器是对象的一个属性，但是存在于类的<code>__dict__</code>中并且有特殊方法<code>__get__</code>而具有特别的功能，所以成为描述器属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Descriptor(object):</div><div class="line">    def __get__(self, obj, type=None):</div><div class="line">        return(&apos;get&apos;, self, obj, type, sep=&quot;, &quot;)</div><div class="line">    def __set__(self, obj, val):</div><div class="line">        print(&quot;set&quot;, self, obj, val)</div><div class="line">    def __delete__(self, obj):</div><div class="line">        print(&quot;delete&quot;, self, obj)</div></pre></td></tr></table></figure>
<p>self是当前Descriptor实例，obj值是拥有属性的对象，如果直接用类访问，那么就相当于直接用类访问类的属性，obj的值是None。type是obj的类型，如果用类访问，obj是None，那么type就是类本身。</p>
<p><code>T.d</code>返回的是<code>d.__get__(None, T)</code>，<code>t.d</code>返回的是<code>d.__get__(t, T)</code></p>
<p>如果描述器只有get方法，没有set方法，那么给这样的属性赋值的时候就会隐藏实例的描述器，直接进行赋值了。些方法: <code>__get__()</code>, <code>__set__()</code>, <code>__delete__()</code>, 如果任何这些方法在一个对象中被定义，就说他是个描述器。</p>
<h2 id="Python属性查找策略"><a href="#Python属性查找策略" class="headerlink" title="Python属性查找策略"></a>Python属性查找策略</h2><ul>
<li>如果attr是一个Python自动产生的属性，直接找到</li>
<li>查找类中的属性<code>obj.__class__.__dict__</code>，如果attr存在而且是描述器，那么返回描述器<code>__get__</code>方法的结果，如果没有那么继续在<code>obj.__class__</code>的父类以及祖先类中寻找描述器，如果是non-data描述器的话，仅仅定义<strong>get</strong>()被称为非资料描述器,就不满足要求。</li>
<li>在实例属性字典中<code>obj.__dict__</code>寻找，如果obj是普通实例，那么找到就直接返回。如果obj是类，那么在obj和它的父类，祖先类的<code>__dict__</code>中查找，如果找到描述器就返回描述器的<code>__get__</code>方法的结果，否则直接返回attr。如果没有找到，进入下一步</li>
<li>在<code>obj.__class__.__dict__</code>中查找，如果找到一个non-data描述器，返回描述器<code>__get__</code>方法的结果，找到普通属性，那么直接返回属性值。</li>
<li><code>raise AttributeError</code></li>
</ul>
<h2 id="属性赋值的查找策略"><a href="#属性赋值的查找策略" class="headerlink" title="属性赋值的查找策略"></a>属性赋值的查找策略</h2><ul>
<li>查找<code>obj.__class__.__dict__</code>，如果attr存在并且是一个描述器，调用attr的<code>__set__</code>方法，如果不存在，继续到<code>obj.__class__</code>父类和祖先类中查找，找到描述器调用器<code>__set__</code>方法。</li>
<li>直接在<code>obj.__dict__</code>中加入<code>obj.__dict__[&#39;attr&#39;] = value</code></li>
</ul>
<h1 id="创建新的类或实例属性"><a href="#创建新的类或实例属性" class="headerlink" title="创建新的类或实例属性"></a>创建新的类或实例属性</h1><p>创建新的拥有额外功能的实例属性类型，通过描述器类来定义它的功能，下面加上了一个类型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Integer:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        # 用类访问,instance为None</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return instance.__dict__[self.name]</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise TypeError(&apos;Expected an int&apos;)</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">    def __delete__(self, instance):</div><div class="line">        del instance.__dict__[self.name]</div></pre></td></tr></table></figure>
<p>为了使用描述器，必须把描述器的实例作为类属性放到类的定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Point:</div><div class="line">    x = Integer(&apos;x&apos;)</div><div class="line">    y = Integer(&apos;y&apos;)</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div></pre></td></tr></table></figure>
<p>使用描述器，可以在底层捕获核心的实例操作，并且完全自定义行为，它只能在类级别被定义，而不能为每个实例单独定义。</p>
<p>另外如果描述器被当作一个类变量来访问，instance参数就为None，这种情况下，标准做法就是简单的返回这个描述器本身即可。如果是实例变量来访问，那么instance就是对应的实例。</p>
<p>如果只是想简单的自定义某个类的单个属性访问的话就不太需要描述器了，使用property技术会更容易。当程序中有很多重复代码的时候使用描述器，比如上面的多个属性都要用到Integer。</p>
<h1 id="使用延迟计算属性"><a href="#使用延迟计算属性" class="headerlink" title="使用延迟计算属性"></a>使用延迟计算属性</h1><p>这个看起来相当有用，将一个只读属性定义成一个property，并且只在访问的时候才会计算结构，并且访问后，结果值被缓存起来，不用每次都去计算，使用描述器类。这个就可以加入到全量或者增量的计算脚本中，不需要重复计算收益或者资产。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class lazyproperty:</div><div class="line">    def __init__(self, func):</div><div class="line">        self.func = func</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            value = self.func(instance)</div><div class="line">            # 设置属性后，就会直接访问属性，因为这个是一个non-data的描述器，访问顺序在上一节有所描述</div><div class="line">            setattr(instance, self.func.__name__, value)</div><div class="line">            return value</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    # 这里也算是在类中定义的，所以可以访问并且触发描述器</div><div class="line">    @lazyproperty</div><div class="line">    def area(self):</div><div class="line">        print(&apos;Computing area&apos;)</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">    @lazyproperty</div><div class="line">    def perimeter(self):</div><div class="line">        print(&apos;Computing perimeter&apos;)</div><div class="line">        return 2 * math.pi * self.radius</div></pre></td></tr></table></figure>
<p>看来的学习下元类的相关知识了。。lazyproperty使用<code>__get__()</code>方法在实例中存储计算出来的值，这个实例使用相同的名字作为它的property，所以结果值被存储在实例字典中并且以后就不需要再去计算这个property了。</p>
<p>另外一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def lazyproperty(func):</div><div class="line">    name = &apos;_lazy_&apos; + func.__name__</div><div class="line">    @property</div><div class="line">    def lazy(self):</div><div class="line">        if hasattr(self, name):</div><div class="line">            return getattr(self, name)</div><div class="line">        else:</div><div class="line">            value = func(self)</div><div class="line">            setattr(self, name, value)</div><div class="line">            return value</div><div class="line">    return lazy</div></pre></td></tr></table></figure>
<h1 id="简单数据结构的初始化"><a href="#简单数据结构的初始化" class="headerlink" title="简单数据结构的初始化"></a>简单数据结构的初始化</h1><p>有很多用作数据结构的类，减少<code>__init__()</code>函数的个数。对啊，可以考虑将部分多层次的数据结构分解为单个的类，这样是不是容易维护？</p>
<p>可以在一个基类中写一个公用的<code>__init__()</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Structure1:</div><div class="line">    _fields = []</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        if len(args) &gt; len(self._fields):</div><div class="line">            raise TypeError(&apos;Expected &#123;&#125; arguments&apos;.format(len(self._fields)))</div><div class="line">        for name, value in zip(self._fields, args):</div><div class="line">            setattr(self, name, value)</div><div class="line">        for name in self._fields[len(args):]:</div><div class="line">            setattr(self, name, kwargs.pop(name))</div><div class="line">        # 未知的关键字</div><div class="line">        if kwargs:</div><div class="line">            raise TypeError(&apos;Invalid arguments: &#123;&#125;&apos;.format(&apos;,&apos;.join(kwargs)))</div><div class="line">class Stock(Structure1):</div><div class="line">    _fields = [&apos;name&apos;, &apos;shares&apos;, &apos;price&apos;]</div></pre></td></tr></table></figure>
<h1 id="定义接口或者抽象基类"><a href="#定义接口或者抽象基类" class="headerlink" title="定义接口或者抽象基类"></a>定义接口或者抽象基类</h1><p>定义一个接口或者抽象类，通过执行类型检查来确保子类实现了某些特定方法。</p>
<p>使用abc模块定义抽象基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxbytes=-1):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>抽象类不能被实例化，目的是为了让别的类继承并且实现特定的抽象方法，一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口。</p>
<p>除了继承，还可以通过注册的方式来让某个类实现抽象基类。<code>IStream.register(io.IOBase)</code></p>
<p><code>@abstractmethod</code>还能注解静态方法，类方法和properties，只需要将注解紧靠在函数定义前即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property</div><div class="line">@abstractmethod</div><div class="line">def name(self):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="实现数据模型的类型约束"><a href="#实现数据模型的类型约束" class="headerlink" title="实现数据模型的类型约束"></a>实现数据模型的类型约束</h1><p>需要对某些实例属性赋值时候进行检查，自定义属性赋值函数，最好使用描述器。</p>
<p>下面使用描述器实现了一个系统类型和赋值验证框架,只定义了<code>__set__()</code>方法，没有<code>__get__()</code>方法，如果一个描述仅仅是从底层实例字典中获取某个属性值的话,那么没必要去定义<code>__get__()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Descriptor:</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        self.name = name</div><div class="line">        for key, value in opts.items():</div><div class="line">            # 赋值给实例属性</div><div class="line">            setattr(self, key, value)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">class Typed(Descriptor):</div><div class="line">    expected_type = type(None)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        # 这里用的是实例属性，描述器是在一个类中使用，所以这个属性是另外一个类的实例属性</div><div class="line">        if not isinstance(value, self.expected_type):</div><div class="line">            raise TypeError(&apos;expected &apos; + str(self.expected_type))</div><div class="line">        super().__set__(instance, value)</div><div class="line">class Unsigned(Descriptor):</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if value &lt; 0:</div><div class="line">            raise ValueError(&apos;Excepted &gt;= 0&apos;)</div><div class="line">        super().__set__(instance, value)</div><div class="line">class MaxSized(Descriptor):</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        if &apos;size&apos; not in opts:</div><div class="line">            raise TypeError(&apos;missing size option&apos;)</div><div class="line">        # 这里继承基类，已经设置了self.size</div><div class="line">        super().__init__(name, **opts)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if len(value) &gt;= self.size:</div><div class="line">            raise ValueError(&apos;size must be &lt; &apos; + str(self.size))</div><div class="line">        super().__set__(instance, value)</div></pre></td></tr></table></figure>
<p>自己定义各种不同的数据类型，所有描述器类都是基于混入类来实现的。比如          和Unsigned要跟其他继承自MaxSized类混入。这里利用多继承来实现相应的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Integer(Typed):</div><div class="line">    expected_type = int</div><div class="line">class UnsignedInteger(Integer, Unsigned):</div><div class="line">    pass</div><div class="line">class Float(Typed):</div><div class="line">    expected_type = float</div><div class="line">class UnsignedFloat(Float, Unsigned):</div><div class="line">    pass</div><div class="line">class String(Typed):</div><div class="line">    expected_type = str</div><div class="line">class SizedString(String, MaxSized):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>混入类的一个比较难理解的地方是,调用<code>super()</code>函数时,你并不知道究竟要调 用哪个具体类。你需要跟其他类结合后才能正确的使用,也就是必须合作才能产生效 果。</p>
<p>使用这些自定义数据类型,描述器必须要定义在类变量中，描述器也必须存在类的<code>__dict__</code>中，只有在<strong><em>类</em></strong>的<code>__dict__</code>中找到属性，Python才会去看它有没有<code>__get__</code>，但是如果是实例的<code>__dict__</code>中找到的属性，那么不会去查看是否有<code>__get__</code>等方法，直接返回属性本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Stock:</div><div class="line">    name = SizedString(&apos;name&apos;, size=8)</div><div class="line">    shares = UnsignedInteger(&apos;shares&apos;)</div><div class="line">    price = UnsignedFloat(&apos;price&apos;)</div><div class="line">    def __init__(self, name, shares, price):</div><div class="line">        self.name = name</div><div class="line">        self.shares = shares</div><div class="line">        self.price = price</div></pre></td></tr></table></figure>
<p>还可以使用类装饰器来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">def check_attributes(**kwargs):</div><div class="line">    def decorator(cls):</div><div class="line">        for key, value in kwargs.items():</div><div class="line">            if isinstance(value, Descriptor):</div><div class="line">                value.name = key</div><div class="line">                setattr(cls, key, value)</div><div class="line">            else:</div><div class="line">                # 如果不是描述器，那么就转换成这种类型</div><div class="line">                setattr(cls, key, value(key))</div><div class="line">        return cls</div><div class="line">    return decorator</div><div class="line">@check_attributes(name=SizedString(size=8),</div><div class="line">                  shares=UnsignedInteger,</div><div class="line">                  price=UnsignedFloat)</div><div class="line">class Stock:</div><div class="line">    def __init__(self, name, shares, price):</div><div class="line">        self.name = name</div><div class="line">        self.shares = shares</div><div class="line">        self.price = price</div></pre></td></tr></table></figure>
<p>使用元类(元类这一块需要搞定)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class checkedmeta(type):</div><div class="line">    def __new__(cls, clsname, bases, methods):</div><div class="line">        for key, value in methods.items():</div><div class="line">            if isinstance(value, Descriptor):</div><div class="line">                value.name = key</div><div class="line">        return type.__new__(cls, clsname, bases, methods)</div><div class="line">class Stock2(metaclass=checkedmeta):</div><div class="line">    name = SizedString(&apos;name&apos;, size=8)</div><div class="line">    shares = UnsignedInteger(&apos;shares&apos;)</div><div class="line">    price = UnsignedFloat(&apos;price&apos;)</div><div class="line">    def __init__(self, name, shares, price):</div><div class="line">        self.name = name</div><div class="line">        self.shares = shares</div><div class="line">        self.price = price</div></pre></td></tr></table></figure>
<p>使用装饰器作为混入类的代替技术</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">def Typed(expected_type, cls=None):</div><div class="line">    if cls is None:</div><div class="line">        # 返回一个函数对象</div><div class="line">        return lambda cls: Typed(expected_type, cls)</div><div class="line">    super_set = cls.__set__</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if not isinstance(value, expected_type):</div><div class="line">            raise TypeError(&apos;expected &apos; + str(expected_type))</div><div class="line">        super_set(self, instance, value)</div><div class="line">    cls.__set__ = __set__</div><div class="line">    return cls</div><div class="line">def Unsigned(cls):</div><div class="line">    super_set = cls.__set__</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if value &lt; 0:</div><div class="line">            raise ValueError(&apos;Expected &gt;= 0&apos;)</div><div class="line">        super_set(self, instance, value)</div><div class="line">    cls.__set__ = __set__</div><div class="line">    return cls</div><div class="line">@Typed(int)</div><div class="line">class Integer(Descriptor):</div><div class="line">    pass</div><div class="line">@Unsigned</div><div class="line">class UnsignedInteger(Integer):</div><div class="line">    pass</div><div class="line"># 这些必须在类中使用</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-set-和-get-等解释&quot;&gt;&lt;a href=&quot;#Python-set-和-get-等解释&quot; class=&quot;headerlink&quot; title=&quot;Python __set__和__get__等解释&quot;&gt;&lt;/a&gt;Python &lt;code&gt;__set__&lt;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象</title>
    <link href="http://microndgt.github.io/2017/01/28/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://microndgt.github.io/2017/01/28/Python类和对象/</id>
    <published>2017-01-28T09:01:05.000Z</published>
    <updated>2017-02-01T04:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。</p>
<h1 id="改变对象的字符串显示"><a href="#改变对象的字符串显示" class="headerlink" title="改变对象的字符串显示"></a>改变对象的字符串显示</h1><p>要改变一个实例的字符串表示，可以重新定义它的<code>__str__()</code>和<code>__repr__()</code>方法，今天彻底解决这两个的混乱，repr用于返回一个实例的代码表示形式，用于调试，交互式解释器显示的值是一样的。而str会将实例转换成一个字符串，使用<code>str()</code>或者<code>print()</code>函数会输出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Pair:</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line">    # &#123;!r&#125;和&#123;!s&#125;取得%r和%s的效果，也就是输出这个属性的时候也用%r或者%s</div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&apos;.format(self)</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&apos;.format(self)</div></pre></td></tr></table></figure>
<p>很有道理呀，自定义<code>__repr__()</code>和<code>__str__()</code>这样就可以分别在调试的时候和正式运行的时候有所差异</p>
<h1 id="自定义字符串的格式化"><a href="#自定义字符串的格式化" class="headerlink" title="自定义字符串的格式化"></a>自定义字符串的格式化</h1><p>format()函数和字符串方法使得一个对象能够支持自定义的格式化。需要在类上面定义<code>__format__()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_formats = &#123;</div><div class="line">  &apos;ymd&apos; : &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;,</div><div class="line">&#125;</div><div class="line">class Date:</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div><div class="line">    def __format__(self, code):</div><div class="line">        if code == &quot;&quot;:</div><div class="line">            code = &apos;ymd&apos;</div><div class="line">        fmt = _formats[code]</div><div class="line">        return fmt.format(d=self)</div><div class="line">d = Date(2012, 12, 21)</div><div class="line">format(d)</div><div class="line">format(d, &apos;ymd&apos;)</div></pre></td></tr></table></figure>
<p>就和之前自己写date的解析函数一样，自定义字符串格式功能。<code>__format__()</code>方法给Python的字符串格式化功能提供一个钩子。</p>
<h1 id="让对象支持上下文管理协议"><a href="#让对象支持上下文管理协议" class="headerlink" title="让对象支持上下文管理协议"></a>让对象支持上下文管理协议</h1><p>需要实现<code>__enter__()</code>和<code>__exit__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = family</div><div class="line">        self.type = type</div><div class="line">        self.sock = None</div><div class="line">    def __enter__(self):</div><div class="line">        if self.sock is not None:</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.sock = socket(self.family, self.type)</div><div class="line">        self.sock.connect(self.address)</div><div class="line">        return self.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.sock.close()</div><div class="line">        self.sock = None</div><div class="line"># 看到类的书写方法，当然是很熟悉，要融化于心;-)</div></pre></td></tr></table></figure>
<p><code>__enter__()</code>方法的返回值为赋值给as生命的变量，<code>__exit__()</code>方法进行清理工作</p>
<h1 id="创建大量对象时节省内存的方法"><a href="#创建大量对象时节省内存的方法" class="headerlink" title="创建大量对象时节省内存的方法"></a>创建大量对象时节省内存的方法</h1><p>对于主要是用来当成简单数据结构的类来说，可以通过给类添加<code>__slots__</code>属性来极大减少实例所占的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Date:</div><div class="line">    __slots__ = [&apos;year&apos;, &apos;month&apos;, &apos;day&apos;]</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div></pre></td></tr></table></figure>
<p>定义<code>__slots__</code>后，实例就会通过很小的固定大小的数组创建，但是有一个缺点就是只能用在<code>__slots__</code>定义的属性名，不能给实例添加新的属性了。使用slots后节省的内存会跟存储属性的数量和类型有关。不过使用它最好只在真的需要的地方作为内存优化工具。</p>
<h1 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h1><p><code>_internal</code>单个下划线开头的名字应该是内部实现，同样适用于模块名和模块级别的函数，<code>__private</code>双下划线开头的名字是私有属性或者私有方法，这种属性或者方法是无法通过继承被覆盖的。</p>
<p>应该让非公共名称以单下划线开始，如果代码涉及子类，并且有些内部属性应该在子类中隐藏，那么使用双下划线方案。</p>
<p>如果定义的变量和某个保留关键字冲突，后面加上单下划线，<code>lambda_</code></p>
<h1 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h1><p>对于重复代码，可以使用装饰器和闭包啊，我现在觉得capacity包的代码又可以优化了。</p>
<p>给某个实例属性增加除了访问和修改之外的其他逻辑，比如类型检查或者合法性验证。自定义属性的简单方法是将它定义为一个property。</p>
<p>下面的这种定义方式值得学习：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person:</div><div class="line">    def __init__(self, first_name):</div><div class="line">        # 初始化的时候也进行类型检查，first_name是一个属性</div><div class="line">        self.first_name = first_name</div><div class="line">    @property</div><div class="line">    def first_name(self):</div><div class="line">        return self._first_name</div><div class="line">    @first_name.setter</div><div class="line">    def first_name(self, value):</div><div class="line">        if not isinstance(value, str):</div><div class="line">            raise TypeError(&apos;Expected a string&apos;)</div><div class="line">        self._first_name = value</div><div class="line">    @first_name.deleter</div><div class="line">    def first_name(self):</div><div class="line">        raise AttributeError(&quot;can not delete attribute&quot;)</div></pre></td></tr></table></figure>
<p>只有在first_name属性被创建后，后面的两个装饰器才能被定义。另外在初始化的时候也进行类型检查，通过设置<code>self.first_name</code>，自动调用setter方法。</p>
<p>不要写没有做任何其他额外操作的property，而且property还是一种定义动态计算attribute的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    @property</div><div class="line">    def area(self):</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">c = Circle(4.0)</div><div class="line">c.radius</div><div class="line">c.area</div></pre></td></tr></table></figure>
<h1 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h1><p>调用父类的一个方法，可以使用super()函数，super()函数的一个常见用法是在<code>__init__()</code>方法中确保父类被正确的初始化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A:</div><div class="line">    def __init__(self):</div><div class="line">        self.x = 0</div><div class="line">class B(A):</div><div class="line">    def __init__(self):</div><div class="line">        # 其他的普通方法也是如此使用</div><div class="line">        super().__init__()</div><div class="line">        self.y = 1</div></pre></td></tr></table></figure>
<p>对于定义的每一个类，Python会计算出一个方法解析顺序(MRO)列表，这个列表就是一个简单的所有基类的线性顺序表，为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<h1 id="子类中扩展property"><a href="#子类中扩展property" class="headerlink" title="子类中扩展property"></a>子类中扩展property</h1><p>扩展定义在父类的property的功能，一个property是getter，setter和deleter方法的集合，而不是单个方法，所以扩展property的时候确定是重新定义所有方法，还是只修改其中一个。</p>
<h2 id="重新定义所有方法"><a href="#重新定义所有方法" class="headerlink" title="重新定义所有方法"></a>重新定义所有方法</h2><p>使用super()来调用父类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @property</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div><div class="line">    @name.setter</div><div class="line">    def name(self, value):</div><div class="line">        print(&quot;Setting name to &quot;, value)</div><div class="line">        super(SubPerson, Subperson).name.__set__(self, value)</div><div class="line">    @name.deleter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;Deleting name&quot;)</div><div class="line">        super(SubPerson, SubPerson).name.__delete__(self)</div></pre></td></tr></table></figure>
<p>使用<code>super(SubPerson, SubPerson).name.__delete__(self)</code>原因是将控制权传递给之前定义的name属性的<code>__delete__()</code>方法，但是获取这个方法的唯一途径是使用类变量来访问。</p>
<h2 id="重定义其中一个方法"><a href="#重定义其中一个方法" class="headerlink" title="重定义其中一个方法"></a>重定义其中一个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @Person.getter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div></pre></td></tr></table></figure>
<p>如此，property之前已经定义过的方法会被复制过来，而getter函数被替换。</p>
<p>如果不知道到底哪个基类定义了property，只能重新定义所有property并且使用super()来将控制权传递给前面的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。&lt;/p&gt;
&lt;h1 id=&quot;改变对象的字符串显示&quot;&gt;&lt;a href=&quot;#改变对象的字符串显示&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
</feed>
