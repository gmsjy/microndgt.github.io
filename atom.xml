<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyRover</title>
  <subtitle>做我的仲夏夜之梦～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://microndgt.github.io/"/>
  <updated>2017-02-14T15:58:18.000Z</updated>
  <id>http://microndgt.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>今日情人节</title>
    <link href="http://microndgt.github.io/2017/02/14/%E4%BB%8A%E6%97%A5%E6%83%85%E4%BA%BA%E8%8A%82/"/>
    <id>http://microndgt.github.io/2017/02/14/今日情人节/</id>
    <published>2017-02-14T15:46:22.000Z</published>
    <updated>2017-02-14T15:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>说实话，都长这么大了，从来没有在情人节这天给谁送过花，谈恋爱从2011年到2017年，6年了，没有过。我不知道为什么，买花这件事其实并没有什么，但是我总是想着但是总不会行动，不知道有什么力量阻止着我。是觉得麻烦？是不够爱？是觉得对感情没有信息？抑或是觉得买花没意思？我不知道，可能是觉得麻烦吧，可能觉得突然的来个这么节日挺麻烦的吧，各种生日，过年，大小节日，送礼物我觉得应该是我的软肋，更本质了的说就是我这个人不知道如何和别人交往，我不主动，很不主动，有点过分，因为我不知道这样做是不是对的，会不会被别人笑话。那么从这个方面来讲，就可以深入到性格方面来说了，我性格压抑，内向，自卑，这与从小的生活成长环境有关，我父母就是比较压抑的人，加上从小看父母吵架，很心痛。还有一个原因就是头有点大，让我觉得不爽很久了，因为和别人不一样，总觉得有点怪异，很烦。从小到大，喜欢我的人我觉得是挺多的，但是我没有明白为什么，我长得好看？我学习好？还是我举止优雅像个绅士？我不懂诶。</p>
<p>说到她，更是让我感动，是感动，而不是不懂，她爱我让我觉得我为了她做什么我都不会后悔，因为真的是感动，我享受她对我的爱。我们去厦门，在厦门海湾公园，她那么爱我的和我举行模拟婚礼，和我约定，那么开心的和我走在一起。在武汉，也是对我百依百顺，临分别前火车站前的那个吻。到我们中间分开了一段时间后的北京。再到西安。她对我，我想说我爱你，在我的生命里，遇到你是我最大的幸运，没有之一。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话，都长这么大了，从来没有在情人节这天给谁送过花，谈恋爱从2011年到2017年，6年了，没有过。我不知道为什么，买花这件事其实并没有什么，但是我总是想着但是总不会行动，不知道有什么力量阻止着我。是觉得麻烦？是不够爱？是觉得对感情没有信息？抑或是觉得买花没意思？我不知道
    
    </summary>
    
      <category term="人生杂记" scheme="http://microndgt.github.io/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="奋斗" scheme="http://microndgt.github.io/tags/%E5%A5%8B%E6%96%97/"/>
    
      <category term="西安" scheme="http://microndgt.github.io/tags/%E8%A5%BF%E5%AE%89/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程2</title>
    <link href="http://microndgt.github.io/2017/02/14/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/14/Python并发编程2/</id>
    <published>2017-02-14T04:23:49.000Z</published>
    <updated>2017-02-14T08:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程第二部分</p>
<h1 id="给关键部分加锁"><a href="#给关键部分加锁" class="headerlink" title="给关键部分加锁"></a>给关键部分加锁</h1><p>一次仅允许一个进程使用的资源称为临界资源。临界区内放的一般是被1个以上的进程或线程（以下只说进程）共用的数据。临界区内的数据一次只能同时被一个进程使用，当一个进程使用临界区内的数据时，其他需要使用临界区数据的进程进入等待状态。</p>
<p>在多线程程序中安全使用可变对象，使用threading库中的Lock对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value -= delta</div></pre></td></tr></table></figure>
<p>线程调度本质上是不稳定的。RLock可重入锁，可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下,当锁被持有时,只有一个线程可以使用完整 的函数或者类中的方法。一个被所 有实例共享的类级锁。这个锁用来同步类方法,具体来说就是,这个锁可以保证一次 只有一个线程可以调用这个类方法。不过,与一个标准的锁不同的是,已经持有这个 锁的方法在调用同样使用这个锁的方法时,无需再次获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    _lock = threading.RLock()</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self.incr(-delta)</div></pre></td></tr></table></figure>
<h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><h1 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h1><p>服务器端程序也应该这样做，至少要限制进程创建的数目，最大应该是8，然后使用Condition对象或者event，等到一个进程结束运行后，然后再将阻塞的创建进程的函数解除阻塞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程第二部分&lt;/p&gt;
&lt;h1 id=&quot;给关键部分加锁&quot;&gt;&lt;a href=&quot;#给关键部分加锁&quot; class=&quot;headerlink&quot; title=&quot;给关键部分加锁&quot;&gt;&lt;/a&gt;给关键部分加锁&lt;/h1&gt;&lt;p&gt;一次仅允许一个进程使用的资源称为临界资源。临界区内放的一般是被1个以
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/13/Python并发编程/</id>
    <published>2017-02-13T04:49:52.000Z</published>
    <updated>2017-02-14T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，调用子进程，生成器函数，并行计算</p>
<h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p>threading库可以在单独的线程中执行任何的在Python中可以调用的对象，可以创建一个Thread对象并且将要执行的对象以target参数的形式提供给该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">t = Thread(target=countdown, args=(10, ))</div><div class="line">t.start()</div></pre></td></tr></table></figure>
<p>线程会在一个单独的系统级线程中执行，这些线程由操作系统全权管理，一旦启动，独立执行到目标函数返回。查询线程状态<code>t.is_alive()</code>，将一个线程加入到当前线程，等待它终止<code>t.join()</code></p>
<p>Python解释器在所有线程都终止后才继续执行代码，所以长时间运行的线程或者需要一直运行的后台任务，使用后台线程。<code>t = Thread(target=countdown, args=(10, ), daemon=True)</code></p>
<p>后台线程无法等待，但是这些线程会在主线程终止时候自动销毁，但是无法结束线程，必须自己写一个调度类来实现这些功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class CountdownTask:</div><div class="line">    def __init__(self):</div><div class="line">        self.running = True</div><div class="line">    def terminate(self):</div><div class="line">        self.running = False</div><div class="line">    def run(self, n):</div><div class="line">        while self.running and n &gt; 0:</div><div class="line">            print(&quot;T-minus&quot;, n)</div><div class="line">            n -= 1</div><div class="line">            time.sleep(5)</div><div class="line">c = CountdownTask()</div><div class="line">t = Thread(target=c.run, args=(10,))</div><div class="line">t.start()</div><div class="line">c.terminate()</div><div class="line">t.join()</div></pre></td></tr></table></figure>
<p>如果线程执行I/O阻塞操作，name就应该使用超时循环来操作线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class IOTask:</div><div class="line">    def terminate(self):</div><div class="line">        self._running = False</div><div class="line">    def run(self, sock):</div><div class="line">        sock.settimeout(5)</div><div class="line">        while self._running:</div><div class="line">            try:</div><div class="line">                data = sock.recv(8192)</div><div class="line">                break</div><div class="line">            except socket.timeout:</div><div class="line">                continue</div><div class="line">        return</div></pre></td></tr></table></figure>
<p>Python线程被限制到同一时刻只允许一个线程执行，所以Python线程更适用于I/O和其他需要并发执行的阻塞操作，而不是需要多处理器并行的计算密集型任务。</p>
<p>以下的实现的线程也可以工作，但是依赖于threading库，所以只能在线程上下文中使用，但是上面的与threading库无关，所以可以被用在其他上下文中，比如在multiprocessing单独进程中执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">class CountdownTask(Thread):</div><div class="line">    def __init__(self, n):</div><div class="line">        super().__init__()</div><div class="line">        self.n = 0</div><div class="line">    def run(self):</div><div class="line">        while self.n &gt; 0:</div><div class="line">            self.n -= 1</div><div class="line">            time.sleep(5)</div></pre></td></tr></table></figure>
<h1 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h1><p>程序其他线程判断某个线程的状态来确定下一步，使用threading的Event来设置一个信号标志来协调线程的启动。初始状态为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from threading import Thread, Event</div><div class="line">import time</div><div class="line">def countdown(n, started_evt):</div><div class="line">    print(&quot;starting&quot;)</div><div class="line">    # 在此设置event对象为真</div><div class="line">    started_evt.set()</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;t-minus&apos;)</div><div class="line">        n -= 1</div><div class="line">        time.sleep(2)</div><div class="line">started_evt = Event()</div><div class="line">print(&apos;launching countdown&apos;)</div><div class="line">t = Thread(target=countdown, args=(10, started_evt))</div><div class="line">t.start()</div><div class="line"># 为真后执行继续执行主线程</div><div class="line">started_evt.wait()</div><div class="line">print(&apos;running&apos;)</div></pre></td></tr></table></figure>
<p>event对象最好单次使用，一旦对象设置为真，就应该丢弃它。如果需要多次使用，则使用Condition对象代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line">class PeriodcTimer:</div><div class="line">    def __init__(self, interval):</div><div class="line">        self._interval = interval</div><div class="line">        self._flag = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def start(self):</div><div class="line">        t = threading.Thread(target=self.run)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            time.sleep(self._interval)</div><div class="line">            with self._cv:</div><div class="line">                self._flag ^= 1</div><div class="line">                self._cv.notify_all()</div><div class="line">    def wait_for_tick(self):</div><div class="line">        with self._cv:</div><div class="line">            last_flag = self._flag</div><div class="line">            while last_flag == self._flag:</div><div class="line">                # 当每次有notify_all时候结束循环,开始计数</div><div class="line">                self._cv.wait()</div><div class="line">ptiemr = PeriodcTimer(5)</div><div class="line">ptiemr.start()</div><div class="line">def countdown(nticks):</div><div class="line">    while nticks &gt; 0:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;T-minus&quot;, nticks)</div><div class="line">        nticks -= 1</div><div class="line">def countup(last):</div><div class="line">    n = 0</div><div class="line">    while n &lt; last:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;counting&quot;, n)</div><div class="line">        n += 1</div><div class="line">threading.Thread(target=countdown, args=(10, )).start()</div><div class="line">threading.Thread(target=countup, args=(5, )).start()</div></pre></td></tr></table></figure>
<p>event当它设置为真的时候会唤醒所有等待它的线程，如果只想唤醒单个线程，最好使用信号量或者Condition对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def worker(n, sema):</div><div class="line">    sema.acquire()</div><div class="line">    print(&quot;working &quot;, n)</div><div class="line">sema = threading.Semaphore(0)</div><div class="line">nworkers = 10</div><div class="line">for n in range(nworkers):</div><div class="line">    # 会启动一个线程池，但是所有线程都在等待获取信号量</div><div class="line">    t = threading.Thread(target=worker, args=(n, sema, ))</div><div class="line">    t.start()</div><div class="line"># 每次释放信号量的时候，只有一个线程会唤醒并且执行</div><div class="line">sema.release()</div></pre></td></tr></table></figure>
<p>使用队列来进行线程间通信或者把每个线程当成一个Actor，使用Actor模型控制并发。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式是使用queue库中的队列。创建一个被多个线程共享的Queue对象，这些线程通过使用put()和get()方法来向队列中添加或者删除元素。Queue中含有了必要的锁，可以在多个线程中安全地共享数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line"># 哨兵</div><div class="line">_sentinel = object()</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">    out_q.put(_sentinel)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        if data is _sentinel:</div><div class="line">            # 再放回去，这样所有监听这个队列的消费者线程就可以都关闭了。</div><div class="line">            in_q.put(_sentinel)</div><div class="line">            break</div></pre></td></tr></table></figure>
<p>使用Condition变量来包装数据结构，创建一个线程安全的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">import threading</div><div class="line">class PriorityQueue:</div><div class="line">    def __init__(self):</div><div class="line">        self._queue = []</div><div class="line">        self._count = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def put(self, item, priority):</div><div class="line">        with self._cv:</div><div class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</div><div class="line">            self._count += 1</div><div class="line">            self._cv.notify()</div><div class="line">    def get(self):</div><div class="line">        with self._cv:</div><div class="line">            while len(self._queue) == 0:</div><div class="line">                # 在这里阻塞,而不是循环，直到添加元素后解除阻塞</div><div class="line">                self._cv.wait()</div><div class="line">            # 获取优先级最低的</div><div class="line">            return heapq.heappop(self._queue)[-1]</div></pre></td></tr></table></figure>
<p>使用task_done()和join()来表示已经完成,q.task_done()，每次从queue中get一个数据之后，当处理好相关问题，最后调用该方法，以提示q.join()是否停止阻塞，让线程向前执行或者退出；q.join()，阻塞，直到queue中的数据均被删除或者处理。为队列中的每一项都调用一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        in_q.task_done()</div><div class="line">q = Queue()</div><div class="line">t2 = Thread(target=producer, args=(q, ))</div><div class="line">t1 = Thread(target=consumer, args=(q, ))</div><div class="line">t2.start()</div><div class="line">t1.start()</div><div class="line">q.join() #所有生产的都被消费</div></pre></td></tr></table></figure>
<p>使用event当消费者线程处理完数据后生产者立即得到通知，来监测处理过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        evt = Event()</div><div class="line">        out_q.put((data, event))</div><div class="line">        evt.wait()</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data, evt = in_q.get()</div><div class="line">        evt.set()</div></pre></td></tr></table></figure>
<p>使用线程队列需要注意向队列中添加数据项并不会复制此数据项，实际上是在线程中传递对象引用。可以使用不变结构或者深拷贝。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，调用子进程，生成器函数，并行计算&lt;/p&gt;
&lt;h1 id=&quot;启动和停止线程&quot;&gt;&lt;a href=&quot;#启动和停止线程&quot; class=&quot;headerlink&quot; title=&quot;启动和停止线程&quot;&gt;&lt;/a&gt;启动和停止线程&lt;/h1&gt;&lt;p&gt;threading库可以在单独的线程中执行任
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Intro to Backend 1</title>
    <link href="http://microndgt.github.io/2017/02/13/Intro-to-backend-1/"/>
    <id>http://microndgt.github.io/2017/02/13/Intro-to-backend-1/</id>
    <published>2017-02-13T04:43:57.000Z</published>
    <updated>2017-02-13T04:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分，Introduction to the web</p>
<p>万维网是HTML文档的集合，这些文件由HTML组成</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一部分，Introduction to the web&lt;/p&gt;
&lt;p&gt;万维网是HTML文档的集合，这些文件由HTML组成&lt;/p&gt;

    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python多进程管理</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://microndgt.github.io/2017/02/13/Python多进程管理/</id>
    <published>2017-02-13T01:41:53.000Z</published>
    <updated>2017-02-13T03:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class MyProcManager(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div><div class="line">    def terminate_all(self):</div><div class="line">        with self._lock:</div><div class="line">            for p in self.procs:</div><div class="line">                if p.is_alive():</div><div class="line">                    print(&quot;Terminating %s&quot; % p)</div><div class="line">                    p.terminate()</div><div class="line">        self.cleaning()</div><div class="line">    def launch_proc(self, func, args=(), kwargs=&#123;&#125;):</div><div class="line">        t = threading.Thread(target=self._proc_thread_runner,</div><div class="line">                             args=(func, args, kwargs))</div><div class="line">        self._threads.append(t)</div><div class="line">        t.start()</div><div class="line">    def _proc_thread_runner(self, func, args, kwargs):</div><div class="line">        p = multiprocessing.Process(target=func, args=args, kwargs=kwargs)</div><div class="line">        self.procs.append(p)</div><div class="line">        p.start()</div><div class="line">        while p.exitcode is None:</div><div class="line">            p.join()</div><div class="line">        if p.exitcode &gt; 0:</div><div class="line">            self.errors_flag = True</div><div class="line">            self.terminate_all()</div><div class="line">    def wait(self):</div><div class="line">        for t in self._threads:</div><div class="line">            t.join()</div><div class="line">    def cleaning(self):</div><div class="line">        self.procs = []</div><div class="line">        self.errors_flag = False</div><div class="line">        self._threads = []</div><div class="line">        self._lock = threading.Lock()</div></pre></td></tr></table></figure>
<p><code>cleaning</code>方法，因为自己在调用的时候在全局实例化了这个类，所以在每次运行完毕的时候需要重新初始化实例变量。</p>
<p>以下是调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">t0 = time.time()</div><div class="line">for fundId in fundIds:</div><div class="line">    proc_manager.launch_proc(calc_ability_proc, args=(fundId, start_date, end_date, config))</div><div class="line">proc_manager.wait()</div><div class="line">if proc_manager.errors_flag:</div><div class="line">    return gen_response(data=None, message=&quot;some processes crashed&quot;, errorcode=1, status=&quot;error&quot;)</div><div class="line">else:</div><div class="line">    print(&quot;Everything closed cleanly&quot;)</div><div class="line">proc_manager.cleaning()</div><div class="line">t1 = time.time()</div><div class="line">print(&quot;time used: %d min&quot; % ((t1 - t0) / 60))</div></pre></td></tr></table></figure>
<p>用了10个fundId进行测试，大约比单线程快了2倍，不过应该fundId越多，速度会越快吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作上要在Flask后台调用计算包，需要进行多进程并行计算，但是要对诸多进程进行管理，于是创造了这个多进程管理，记录下来以便后来使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>上班第一周</title>
    <link href="http://microndgt.github.io/2017/02/11/%E4%B8%8A%E7%8F%AD%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://microndgt.github.io/2017/02/11/上班第一周/</id>
    <published>2017-02-11T01:18:06.000Z</published>
    <updated>2017-02-11T01:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>这周是从毕业以来正式出去上班工作的第一个周，真的体会到了上班不易，不仅是上下班路上不易，更多的是要工作好，然后自己要有所提高，和自己预想的差异还是蛮大的。曾经自己构想的每日计划其实到了每日也就能执行一小部分，原因就是自己没那么多精力，不仅思想会累，身体也会累，眼镜会累，并且每天还有各种各样的事情，谁能保证自己有那个精力那个时间呢。在工作后，自己才觉得自己需要回炉重造，但是哪里又有那个机会呢。又到了新的学期，自己势必要去退学，想起这个就觉的心慌，但是没有办法了，早去早解脱吧。说起这个，又想起以后，难道安全感是如此获得的吗？我在恐惧什么？</p>
<p>这周途中搬了一次家，真是累，感谢两位小伙伴，要不然我真的是觉得有点无助，就开车搬都搬了3次，这么多东西，我到底是买了什么？搬到一个离工作地点更远的地方，为了她。算了，不提了，现在已经这样了，记得上次租房子也是。不过还好还好吧，至少现在安定下来了，住了一个稍微大点的房子，感觉还不错。每天上班40-50分钟，早上7点半起床。</p>
<p>工作呢，也随着时间慢慢的我也在适应了，虽然我在一个小房间一个人工作，但是我也觉得挺好，至少随意。项目上这周进展也比较大，web后端成体系了，自己也学到了不少，当然只是基本。计算核心也搞出来了，当然需要优化。不过深知自己需要大量学习，自己还是太菜了，很多东西没有接触，自然就没法想到更好的办法，所以学习学习再学习！</p>
<p>搬家时候整理衣服，看到那件风衣，突然很突然的一下心里有点痛。谁的青春不腐朽呢？总有那么多遗憾，谁都刻骨铭心，怎能忘记？当时在别人的故事里流的泪，终将化作那混凝土，浇筑在心底最柔软的角落，才能在多年以后，把酒言欢，唏嘘着自己的青春。愿所有的爱情不要轻易的说再见。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周是从毕业以来正式出去上班工作的第一个周，真的体会到了上班不易，不仅是上下班路上不易，更多的是要工作好，然后自己要有所提高，和自己预想的差异还是蛮大的。曾经自己构想的每日计划其实到了每日也就能执行一小部分，原因就是自己没那么多精力，不仅思想会累，身体也会累，眼镜会累，并且
    
    </summary>
    
      <category term="人生杂记" scheme="http://microndgt.github.io/categories/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="奋斗" scheme="http://microndgt.github.io/tags/%E5%A5%8B%E6%96%97/"/>
    
      <category term="西安" scheme="http://microndgt.github.io/tags/%E8%A5%BF%E5%AE%89/"/>
    
  </entry>
  
  <entry>
    <title>使用Python和Flask设计RESTful API</title>
    <link href="http://microndgt.github.io/2017/02/05/%E4%BD%BF%E7%94%A8Python%E5%92%8CFlask%E8%AE%BE%E8%AE%A1RESTful-API/"/>
    <id>http://microndgt.github.io/2017/02/05/使用Python和Flask设计RESTful-API/</id>
    <published>2017-02-05T03:25:20.000Z</published>
    <updated>2017-02-05T03:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST-REpresentational-State-Transfer表现层状态迁移"><a href="#REST-REpresentational-State-Transfer表现层状态迁移" class="headerlink" title="REST(REpresentational State Transfer表现层状态迁移)"></a>REST(REpresentational State Transfer表现层状态迁移)</h1><p>web services和web APIs</p>
<ul>
<li>客户端－服务器，两者隔离</li>
<li>无状态，一种服务器不会存储客户端上一次请求的信息用来下一次使用</li>
<li>可缓存，服务器明示客户端请求能否缓存</li>
<li>分层系统，客户端和服务器通信应该以一种标准方式，中间层代替服务器做出相应，客户端不需要做任何变动</li>
<li>统一接口，通信方法必须是统一的</li>
<li>按需编码：服务器可以提供可执行代码的脚本，为客户端在它们的环境中执行</li>
</ul>
<h1 id="RESTful-的-web-service"><a href="#RESTful-的-web-service" class="headerlink" title="RESTful 的 web service"></a>RESTful 的 web service</h1><p>核心是资源，资源可以用URI表示，客户端使用HTTP协议定义的方法来发送请求到这些URIs，当然可能会导致这些被访问的资源状态改变</p>
<p><code>GET,POST,PUT,DELETE</code></p>
<p>REST设计不需要特定的数据格式，在请求中数据可以以JSON形式，或者作为url中查询参数项。</p>
<h1 id="设计一个web-service"><a href="#设计一个web-service" class="headerlink" title="设计一个web service"></a>设计一个web service</h1><p>其实就是一个标识资源被展示出来以及它们是怎样受不同的请求方法影响。</p>
<p>首先设计URL: <code>http://[hostname]/todo/api/v1.0</code>，在URL中包含应用名称有助于提供一个命名空间以便区分同一系统上的其他服务，包含版本号能够帮助以后的更新，如果新版本中存在新的和潜在不兼容的功能，可以不影响依赖于旧的功能的应用程序。</p>
<p>现在从前端过来的也就是指令信息，然后发送给服务器，计算之后返回数据信息，主要在于要将这些数据格式化成json格式，把指令从json变成python可用的。</p>
<p>有这么几项，一个是登陆，密码验证之类。另外一个是开始计算，返回数据，已完成百分比，耗费时间。另外一个是返回summary数据，输入id的话返回对应的ability或者其他数据，这块也就是数据查询功能，看查询类型了</p>
<p>擦，在虚拟环境指定Python3也是不容易啊，<code>virtualenv backend -p /usr/local/bin/python3</code>使用用户安装的python3，貌似anaconda的Python3用不了</p>
<h1 id="Flask-restful使用"><a href="#Flask-restful使用" class="headerlink" title="Flask restful使用"></a>Flask restful使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask.ext import restful</div><div class="line"># 创建程序实例</div><div class="line">app = Flask(__name__)</div><div class="line">api = restful.Api(app)</div><div class="line"># 定义资源</div><div class="line">class HelloWorld(restful.Resource):</div><div class="line">    def get(self):</div><div class="line">        return &#123;&apos;hello&apos;: &apos;world&apos;&#125;</div><div class="line"># 添加资源</div><div class="line">api.add_resource(HelloWorld, &apos;/&apos;)</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    # 开始运行</div><div class="line">    app.run(debug=True)</div></pre></td></tr></table></figure>
<h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST-REpresentational-State-Transfer表现层状态迁移&quot;&gt;&lt;a href=&quot;#REST-REpresentational-State-Transfer表现层状态迁移&quot; class=&quot;headerlink&quot; title=&quot;REST(R
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python元编程</title>
    <link href="http://microndgt.github.io/2017/02/04/Python%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/04/Python元编程/</id>
    <published>2017-02-04T07:02:23.000Z</published>
    <updated>2017-02-05T02:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。</p>
<h1 id="在函数上添加包装器"><a href="#在函数上添加包装器" class="headerlink" title="在函数上添加包装器"></a>在函数上添加包装器</h1><p>使用额外的代码包装一个函数，定义一个装饰器函数，一个装饰器就是一个函数，它接受一个函数作为参数并且返回一个新的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def timethis(func):</div><div class="line">    # 使用wraps的目的是为了防止函数信息变成wrapper的函数信息</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        start = time.time()</div><div class="line">        result = func(*args, **kwargs)</div><div class="line">        end = time.time()</div><div class="line">        print(func.__name__, end-start)</div><div class="line">        return result</div><div class="line">    return wrapper</div><div class="line">@timethis</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line"># 相当于</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        n -= 1</div><div class="line">countdown = timethis(countdown)</div></pre></td></tr></table></figure>
<p>所以真正执行的是装饰器函数中的闭包内部函数，使用装饰器并不会修改原始函数的参数签名以及返回值，使用<code>*args</code>和<code>**kwargs</code>的目的就是确保任何参数都能适用，而返回结果值都是调用原始函数<code>func(*args, **kwargs)</code>的返回结果。<code>@wraps(func)</code>注解是保留原始函数的元数据</p>
<h1 id="创建装饰器时保留函数元信息"><a href="#创建装饰器时保留函数元信息" class="headerlink" title="创建装饰器时保留函数元信息"></a>创建装饰器时保留函数元信息</h1><p>任何时候定义装饰器，都应该使用functools库中的<code>@wraps</code>装饰器来注解底层包装函数，这样就会复制原始函数的元信息。<code>@wraps</code>可以通过属性<code>__wrapped__</code>直接访问被包装函数，<code>countdown.__wrapped__(100000)</code></p>
<h1 id="解除一个装饰器"><a href="#解除一个装饰器" class="headerlink" title="解除一个装饰器"></a>解除一个装饰器</h1><p>如果装饰器是通过<code>@wraps</code>来实现的，那么可以访问<code>__wrapped__</code>属性来访问原始函数。</p>
<p>如果有多个包装器，那么访问<code>__wrapped__</code>属性的行为是不可预知的，而且仅仅适用于包装器正确使用了<code>@wraps</code>的情况。多个包装器，从内向外进行包装。</p>
<h1 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>最外层的函数logged()接受参数并将它们作用在内部的装饰器函数上。其实就相当于下面：<code>add = logged(logging.DEBUG)(add)</code>logged()返回的是一个可调用对象，接受一个函数作为参数并且包装它。</p>
<h1 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h1><p>用装饰器来包装函数，并且在运行时候提供参数控制装饰器的行为。方法是，引入一个访问函数，使用nolocal来修改内部变量，然后这个访问函数被作为一个属性赋值给包装函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def attach_wrapper(obj, func=None):</div><div class="line">    if func is None:</div><div class="line">        # 相当于将第一个参数默认了</div><div class="line">        return partial(attach_wrapper, obj)</div><div class="line">    # 这里相当于给这个对象设置了一个这个属性，后面可以直接调用</div><div class="line">    setattr(obj, func.__name__, func)</div><div class="line">    return func</div><div class="line">def logged(level, name=None, message=None):</div><div class="line">    def decorate(func):</div><div class="line">        logname = name if name else func.__module__</div><div class="line">        log = logging.getLogger(logname)</div><div class="line">        logmsg = message if message else func.__name__</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            log.log(level, logmsg)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        # 这里将返回的wrapper作为对象，返回了一个包涵默认对象的attach_wrapper，然后再装饰set_level，只是为该对象设置了set_level属性</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_level(newlevel):</div><div class="line">            nonlocal level</div><div class="line">            level = newlevel</div><div class="line">        @attach_wrapper(wrapper)</div><div class="line">        def set_message(newmsg):</div><div class="line">            nonlocal logmsg</div><div class="line">            logmsg = newmsg</div><div class="line">        return wrapper</div><div class="line">    return decorate</div><div class="line">@logged(logging.DEBUG)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">add.set_message(&apos;Add called&apos;)</div></pre></td></tr></table></figure>
<p>并且访问函数会在多层装饰器间传播</p>
<h1 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h1><p>一个装饰器可以不传参数，如<code>@decorator</code>，也可以传递参数给它，如<code>@decorator(x, y, z)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def logged(func=None, *, level=logging.DEBUG, name=None, message=None):</div><div class="line">    if func is None:</div><div class="line">        # 返回一个接受一个函数参数并且包装它的函数</div><div class="line">        return partial(logged, level=level, name=name, message=message)</div><div class="line">    logname = name if name else func.__module__</div><div class="line">    log = logging.getLogger(logname)</div><div class="line">    logmsg = message if message else func.__name__</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, **kwargs):</div><div class="line">        log.log(level, logmsg)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line"># 不带参数，func不是None，调用类似于logged(func)</div><div class="line">@logged</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line"># 带参数，func为None，返回一个partial的函数logged,可选参数作为默认值</div><div class="line">@logged(level=logging.CRITICAL, name=&apos;example&apos;)</div><div class="line">def spam():</div><div class="line">    print(&quot;Spam!&quot;)</div></pre></td></tr></table></figure>
<p>如果定义一个所有参数都是可选的装饰器，那么使用语法糖的时候就要这样<code>@logged()</code>加上括号，否则就会出现问题。上面的第一个装饰器调用等价于<code>add = logged(add)</code>，而第2个调用等价于<code>spam = logged(level=logging.CRITICAL, name=&#39;example&#39;)(spam)</code>，使用了<code>functools.partial</code>这个技巧，它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定。</p>
<h1 id="将装饰器定义为类的一部分"><a href="#将装饰器定义为类的一部分" class="headerlink" title="将装饰器定义为类的一部分"></a>将装饰器定义为类的一部分</h1><p>在类中定义装饰器，并将其用在其他函数或者方法上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">class A:</div><div class="line">    def decorator1(self, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&quot;Decorator 1&quot;)</div><div class="line">            return func(*args, **kwrags)</div><div class="line">        return wrapper</div><div class="line">    @classmethod</div><div class="line">    def decorator2(cls, func):</div><div class="line">        @wraps(func)</div><div class="line">        def wrapper(*args, **kwargs):</div><div class="line">            print(&apos;Decorator 2&apos;)</div><div class="line">            return func(*args, **kwargs)</div><div class="line">        return wrapper</div><div class="line">a = A()</div><div class="line">@a.decorator1</div><div class="line">def spam():</div><div class="line">    pass</div><div class="line">@A.decorator2</div><div class="line">def grok():</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>一个是实例调用，一个是类调用，<code>@property</code>装饰器实际上是一个类，里面定义了三个方法，<code>getter()</code>,<code>setter()</code>,<code>deleter()</code>，每一个方法都是一个装饰器。这么定义的主要原因是各种不同的装饰器方法会在关联的property实例上操作它的状态，因此，只要需要在装饰器中记录或者绑定信息，都可以使用在类中定义装饰器的办法。</p>
<p>在类中定义装饰器对于额外参数self，cls，两个装饰器内部创建的wrapper函数并不需要这两个参数，唯一需要的时候是确实要访问包装器中这个实例的某些部分的时候。</p>
<p>涉及到继承的时候，应该这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class B(A):</div><div class="line">    @A.decorator2</div><div class="line">    def bar(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>装饰器被定义成类方法并且必须显式使用父类名去调用它，而不能用B，因为方法定义的时候类B还没有创建。</p>
<h1 id="将装饰器定义为类"><a href="#将装饰器定义为类" class="headerlink" title="将装饰器定义为类"></a>将装饰器定义为类</h1><p>使用一个装饰器去包装函数，但是返回一个可调用的实例，装饰器可以同时工作在类定义的内部和外部。</p>
<p>将装饰器定义成一个实例，确保其实现了<code>__call__()</code>和<code>__get__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">import types</div><div class="line">from functools import wraps</div><div class="line">class Profiled:</div><div class="line">    def __init__(self, func):</div><div class="line">        wraps(func)(self)</div><div class="line">        self.ncalls = 0</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        self.ncalls += 1</div><div class="line">        return self.__wrapped__(*args, **kwargs)</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return types.MethodType(self, instance)</div><div class="line">@Profiled</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">class Spam:</div><div class="line">    @Profiled</div><div class="line">    def bar(self, x):</div><div class="line">        print(self, x)</div></pre></td></tr></table></figure>
<p>这一块居然没怎么看懂，我的妈呀～</p>
<h1 id="为类方法和静态方法提供装饰器"><a href="#为类方法和静态方法提供装饰器" class="headerlink" title="为类方法和静态方法提供装饰器"></a>为类方法和静态方法提供装饰器</h1><p>确保装饰器在<code>@classmethod</code>或者<code>@staticmethod</code>之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Spam:</div><div class="line">    @timethis</div><div class="line">    def instance_method(self, n):</div><div class="line">        pass</div><div class="line">    @classmethod</div><div class="line">    @timethis</div><div class="line">    def class_method(cls, n):</div><div class="line">        pass</div><div class="line">    @staticmethod</div><div class="line">    @timethis</div><div class="line">    def static_method(n):</div><div class="line">        pass</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元编程来解决高度重复的代码，元编程就是关于创建操作源代码(比如修改，生成或者包装原来的代码)的函数和类，主要技术是使用装饰器，类装饰器和元类，签名对象，使用exec()执行代码以及对内部函数和类的反射技术。&lt;/p&gt;
&lt;h1 id=&quot;在函数上添加包装器&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象2</title>
    <link href="http://microndgt.github.io/2017/02/01/Python%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A12/"/>
    <id>http://microndgt.github.io/2017/02/01/Python类与对象2/</id>
    <published>2017-02-01T04:29:49.000Z</published>
    <updated>2017-02-04T02:59:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-set-和-get-等解释"><a href="#Python-set-和-get-等解释" class="headerlink" title="Python __set__和__get__等解释"></a>Python <code>__set__</code>和<code>__get__</code>等解释</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class T:</div><div class="line">    name = &apos;name&apos;</div><div class="line">    def hello(self):</div><div class="line">        print(&apos;hello&apos;)</div><div class="line">t = T()</div></pre></td></tr></table></figure>
<p>使用<code>dir(t)</code>列出t的所有有效属性，分为两类，一类是Python自动产生的，一类是自定义的，如hello,name</p>
<p>类和实例对象，实际上Python中一切都是对象，类是type的实例，都有<code>__dict__</code>属性，里面存放他们的自定义属性</p>
<p><code>t.__dict__</code>是一个空字典，在t上没有自定义任何属性，它的有效属性hello和name都是从T得到的。查找t的name属性的时候，首先判断name属性是否是个自动产生的属性，如果是自动产生的，就按特别的方法找到这个属性，自定义的属性，从t的<code>__dict__</code>中寻找，没找到从类T中寻找,<code>T.__dict__</code>中寻找，然后返回，如果没有找到在父类中查找。</p>
<h2 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h2><p>查找属性的时候，如<code>obj.attr</code>，如果Python发现这个属性attr有个<code>__get__</code>方法，Python就会调用这个方法，返回这个方法的返回值，而不是attr。</p>
<p>descriptor是实现了某些特定方法的对象，<code>__get__</code>和<code>__set__</code>和<code>__delete__</code>，其中set和delete是可选的，另外描述器必须依附对象，作为对象的一个属性，而不能单独存在，描述器也必须存在类的<code>__dict__</code>中，只有在<strong><em>类</em></strong>的<code>__dict__</code>中找到属性，Python才会去看它有没有<code>__get__</code>，但是如果是实例的<code>__dict__</code>中找到的属性，那么不会去查看是否有<code>__get__</code>等方法，直接返回属性本身。</p>
<p>描述器是对象的一个属性，但是存在于类的<code>__dict__</code>中并且有特殊方法<code>__get__</code>而具有特别的功能，所以成为描述器属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Descriptor(object):</div><div class="line">    def __get__(self, obj, type=None):</div><div class="line">        return(&apos;get&apos;, self, obj, type, sep=&quot;, &quot;)</div><div class="line">    def __set__(self, obj, val):</div><div class="line">        print(&quot;set&quot;, self, obj, val)</div><div class="line">    def __delete__(self, obj):</div><div class="line">        print(&quot;delete&quot;, self, obj)</div></pre></td></tr></table></figure>
<p>self是当前Descriptor实例，obj值是拥有属性的对象，如果直接用类访问，那么就相当于直接用类访问类的属性，obj的值是None。type是obj的类型，如果用类访问，obj是None，那么type就是类本身。</p>
<p><code>T.d</code>返回的是<code>d.__get__(None, T)</code>，<code>t.d</code>返回的是<code>d.__get__(t, T)</code></p>
<p>如果描述器只有get方法，没有set方法，那么给这样的属性赋值的时候就会隐藏实例的描述器，直接进行赋值了。</p>
<h2 id="Python属性查找策略"><a href="#Python属性查找策略" class="headerlink" title="Python属性查找策略"></a>Python属性查找策略</h2><ul>
<li>如果attr是一个Python自动产生的属性，直接找到</li>
<li>查找类中的属性<code>obj.__class__.__dict__</code>，如果attr存在而且是描述器，那么返回描述器<code>__get__</code>方法的结果，如果没有那么继续在<code>obj.__class__</code>的父类以及祖先类中寻找描述器，如果是non-data描述器的话，就不满足要求。</li>
<li>在实例属性字典中<code>obj.__dict__</code>寻找，如果obj是普通实例，那么找到就直接返回。如果obj是类，那么在obj和它的父类，祖先类的<code>__dict__</code>中查找，如果找到描述器就返回描述器的<code>__get__</code>方法的结果，否则直接返回attr。如果没有找到，进入下一步</li>
<li>在<code>obj.__class__.__dict__</code>中查找，如果找到一个non-data描述器，返回描述器<code>__get__</code>方法的结果，找到普通属性，那么直接返回属性值。</li>
<li><code>raise AttributeError</code></li>
</ul>
<h2 id="属性赋值的查找策略"><a href="#属性赋值的查找策略" class="headerlink" title="属性赋值的查找策略"></a>属性赋值的查找策略</h2><ul>
<li>查找<code>obj.__class__.__dict__</code>，如果attr存在并且是一个描述器，调用attr的<code>__set__</code>方法，如果不存在，继续到<code>obj.__class__</code>父类和祖先类中查找，找到描述器调用器<code>__set__</code>方法。</li>
<li>直接在<code>obj.__dict__</code>中加入<code>obj.__dict__[&#39;attr&#39;] = value</code></li>
</ul>
<h1 id="创建新的类或实例属性"><a href="#创建新的类或实例属性" class="headerlink" title="创建新的类或实例属性"></a>创建新的类或实例属性</h1><p>创建新的拥有额外功能的实例属性类型，通过描述器类来定义它的功能，下面加上了一个类型检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Integer:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        # 用类访问,instance为None</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            return instance.__dict__[self.name]</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if not isinstance(value, int):</div><div class="line">            raise TypeError(&apos;Expected an int&apos;)</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">    def __delete__(self, instance):</div><div class="line">        del instance.__dict__[self.name]</div></pre></td></tr></table></figure>
<p>为了使用描述器，必须把描述器的实例作为类属性放到类的定义中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Point:</div><div class="line">    x = Integer(&apos;x&apos;)</div><div class="line">    y = Integer(&apos;y&apos;)</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div></pre></td></tr></table></figure>
<p>使用描述器，可以在底层捕获核心的实例操作，并且完全自定义行为，它只能在类级别被定义，而不能为每个实例单独定义。</p>
<p>另外如果描述器被当作一个类变量来访问，instance参数就为None，这种情况下，标准做法就是简单的返回这个描述器本身即可。如果是实例变量来访问，那么instance就是对应的实例。</p>
<p>如果只是想简单的自定义某个类的单个属性访问的话就不太需要描述器了，使用property技术会更容易。当程序中有很多重复代码的时候使用描述器，比如上面的多个属性都要用到Integer。</p>
<h1 id="使用延迟计算属性"><a href="#使用延迟计算属性" class="headerlink" title="使用延迟计算属性"></a>使用延迟计算属性</h1><p>这个看起来相当有用，将一个只读属性定义成一个property，并且只在访问的时候才会计算结构，并且访问后，结果值被缓存起来，不用每次都去计算，使用描述器类。这个就可以加入到全量或者增量的计算脚本中，不需要重复计算收益或者资产。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class lazyproperty:</div><div class="line">    def __init__(self, func):</div><div class="line">        self.func = func</div><div class="line">    def __get__(self, instance, cls):</div><div class="line">        if instance is None:</div><div class="line">            return self</div><div class="line">        else:</div><div class="line">            value = self.func(instance)</div><div class="line">            # 设置属性后，就会直接访问属性，因为这个是一个non-data的描述器，访问顺序在上一节有所描述</div><div class="line">            setattr(instance, self.func.__name__, value)</div><div class="line">            return value</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    # 这里也算是在类中定义的，所以可以访问并且触发描述器</div><div class="line">    @lazyproperty</div><div class="line">    def area(self):</div><div class="line">        print(&apos;Computing area&apos;)</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">    @lazyproperty</div><div class="line">    def perimeter(self):</div><div class="line">        print(&apos;Computing perimeter&apos;)</div><div class="line">        return 2 * math.pi * self.radius</div></pre></td></tr></table></figure>
<p>看来的学习下元类的相关知识了。。lazyproperty使用<code>__get__()</code>方法在实例中存储计算出来的值，这个实例使用相同的名字作为它的property，所以结果值被存储在实例字典中并且以后就不需要再去计算这个property了。</p>
<p>另外一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def lazyproperty(func):</div><div class="line">    name = &apos;_lazy_&apos; + func.__name__</div><div class="line">    @property</div><div class="line">    def lazy(self):</div><div class="line">        if hasattr(self, name):</div><div class="line">            return getattr(self, name)</div><div class="line">        else:</div><div class="line">            value = func(self)</div><div class="line">            setattr(self, name, value)</div><div class="line">            return value</div><div class="line">    return lazy</div></pre></td></tr></table></figure>
<h1 id="简单数据结构的初始化"><a href="#简单数据结构的初始化" class="headerlink" title="简单数据结构的初始化"></a>简单数据结构的初始化</h1><p>有很多用作数据结构的类，减少<code>__init__()</code>函数的个数。对啊，可以考虑将部分多层次的数据结构分解为单个的类，这样是不是容易维护？</p>
<p>可以在一个基类中写一个公用的<code>__init__()</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Structure1:</div><div class="line">    _fields = []</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        if len(args) &gt; len(self._fields):</div><div class="line">            raise TypeError(&apos;Expected &#123;&#125; arguments&apos;.format(len(self._fields)))</div><div class="line">        for name, value in zip(self._fields, args):</div><div class="line">            setattr(self, name, value)</div><div class="line">        for name in self._fields[len(args):]:</div><div class="line">            setattr(self, name, kwargs.pop(name))</div><div class="line">        # 未知的关键字</div><div class="line">        if kwargs:</div><div class="line">            raise TypeError(&apos;Invalid arguments: &#123;&#125;&apos;.format(&apos;,&apos;.join(kwargs)))</div><div class="line">class Stock(Structure1):</div><div class="line">    _fields = [&apos;name&apos;, &apos;shares&apos;, &apos;price&apos;]</div></pre></td></tr></table></figure>
<h1 id="定义接口或者抽象基类"><a href="#定义接口或者抽象基类" class="headerlink" title="定义接口或者抽象基类"></a>定义接口或者抽象基类</h1><p>定义一个接口或者抽象类，通过执行类型检查来确保子类实现了某些特定方法。</p>
<p>使用abc模块定义抽象基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxbytes=-1):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>抽象类不能被实例化，目的是为了让别的类继承并且实现特定的抽象方法，一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口。</p>
<p>除了继承，还可以通过注册的方式来让某个类实现抽象基类。<code>IStream.register(io.IOBase)</code></p>
<p><code>@abstractmethod</code>还能注解静态方法，类方法和properties，只需要将注解紧靠在函数定义前即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property</div><div class="line">@abstractmethod</div><div class="line">def name(self):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="实现数据模型的类型约束"><a href="#实现数据模型的类型约束" class="headerlink" title="实现数据模型的类型约束"></a>实现数据模型的类型约束</h1><p>需要对某些实例属性赋值时候进行检查，自定义属性赋值函数，最好使用描述器。</p>
<p>下面使用描述器实现了一个系统类型和赋值验证框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Descriptor:</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        self.name = name</div><div class="line">        for key, value in opts.items():</div><div class="line">            # 赋值给实例属性</div><div class="line">            setattr(self, key, value)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        instance.__dict__[self.name] = value</div><div class="line">class Typed(Descriptor):</div><div class="line">    expected_type = type(None)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        # 这里用的是实例属性，描述器是在一个类中使用，所以这个属性是另外一个类的实例属性</div><div class="line">        if not isinstance(value, self.expected_type):</div><div class="line">            raise TypeError(&apos;expected &apos; + str(self.expected_type))</div><div class="line">        super().__set__(instance, value)</div><div class="line">class Unsigned(Descriptor):</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if value &lt; 0:</div><div class="line">            raise ValueError(&apos;Excepted &gt;= 0&apos;)</div><div class="line">        super().__set__(instance, value)</div><div class="line">class MaxSized(Descriptor):</div><div class="line">    def __init__(self, name=None, **opts):</div><div class="line">        if &apos;size&apos; not in opts:</div><div class="line">            raise TypeError(&apos;missing size option&apos;)</div><div class="line">        # 这里继承基类，已经设置了self.size</div><div class="line">        super().__init__(name, **opts)</div><div class="line">    def __set__(self, instance, value):</div><div class="line">        if len(value) &gt;= self.size:</div><div class="line">            raise ValueError(&apos;size must be &lt; &apos; + str(self.size))</div><div class="line">        super().__set__(instance, value)</div></pre></td></tr></table></figure>
<p>自己定义各种不同的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Integer(Typed):</div><div class="line">    expected_type = int</div><div class="line">class UnsignedInteger(Integer, Unsigned):</div><div class="line">    pass</div><div class="line">class Float(Typed):</div><div class="line">    expected_type = float</div><div class="line">class UnsignedFloat(Float, Unsigned):</div><div class="line">    pass</div><div class="line">class String(Typed):</div><div class="line">    expected_type = str</div><div class="line">class SizedString(String, MaxSized):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>使用这些自定义数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Stock:</div><div class="line">    name = SizedString(&apos;name&apos;, size=8)</div><div class="line">    shares = UnsignedInteger(&apos;shares&apos;)</div><div class="line">    price = UnsignedFloat(&apos;price&apos;)</div><div class="line">    def __init__(self, name, shares, price):</div><div class="line">        self.name = name</div><div class="line">        self.shares = shares</div><div class="line">        self.price = price</div></pre></td></tr></table></figure>
<p>混入类的使用这块需要学习一下。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-set-和-get-等解释&quot;&gt;&lt;a href=&quot;#Python-set-和-get-等解释&quot; class=&quot;headerlink&quot; title=&quot;Python __set__和__get__等解释&quot;&gt;&lt;/a&gt;Python &lt;code&gt;__set__&lt;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python类与对象</title>
    <link href="http://microndgt.github.io/2017/01/28/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://microndgt.github.io/2017/01/28/Python类和对象/</id>
    <published>2017-01-28T09:01:05.000Z</published>
    <updated>2017-02-01T04:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。</p>
<h1 id="改变对象的字符串显示"><a href="#改变对象的字符串显示" class="headerlink" title="改变对象的字符串显示"></a>改变对象的字符串显示</h1><p>要改变一个实例的字符串表示，可以重新定义它的<code>__str__()</code>和<code>__repr__()</code>方法，今天彻底解决这两个的混乱，repr用于返回一个实例的代码表示形式，用于调试，交互式解释器显示的值是一样的。而str会将实例转换成一个字符串，使用<code>str()</code>或者<code>print()</code>函数会输出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Pair:</div><div class="line">    def __init__(self, x, y):</div><div class="line">        self.x = x</div><div class="line">        self.y = y</div><div class="line">    # &#123;!r&#125;和&#123;!s&#125;取得%r和%s的效果，也就是输出这个属性的时候也用%r或者%s</div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)&apos;.format(self)</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;(&#123;0.x!s&#125;, &#123;0.y!s&#125;)&apos;.format(self)</div></pre></td></tr></table></figure>
<p>很有道理呀，自定义<code>__repr__()</code>和<code>__str__()</code>这样就可以分别在调试的时候和正式运行的时候有所差异</p>
<h1 id="自定义字符串的格式化"><a href="#自定义字符串的格式化" class="headerlink" title="自定义字符串的格式化"></a>自定义字符串的格式化</h1><p>format()函数和字符串方法使得一个对象能够支持自定义的格式化。需要在类上面定义<code>__format__()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">_formats = &#123;</div><div class="line">  &apos;ymd&apos; : &apos;&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;&apos;,</div><div class="line">&#125;</div><div class="line">class Date:</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div><div class="line">    def __format__(self, code):</div><div class="line">        if code == &quot;&quot;:</div><div class="line">            code = &apos;ymd&apos;</div><div class="line">        fmt = _formats[code]</div><div class="line">        return fmt.format(d=self)</div><div class="line">d = Date(2012, 12, 21)</div><div class="line">format(d)</div><div class="line">format(d, &apos;ymd&apos;)</div></pre></td></tr></table></figure>
<p>就和之前自己写date的解析函数一样，自定义字符串格式功能。<code>__format__()</code>方法给Python的字符串格式化功能提供一个钩子。</p>
<h1 id="让对象支持上下文管理协议"><a href="#让对象支持上下文管理协议" class="headerlink" title="让对象支持上下文管理协议"></a>让对象支持上下文管理协议</h1><p>需要实现<code>__enter__()</code>和<code>__exit__()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = family</div><div class="line">        self.type = type</div><div class="line">        self.sock = None</div><div class="line">    def __enter__(self):</div><div class="line">        if self.sock is not None:</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.sock = socket(self.family, self.type)</div><div class="line">        self.sock.connect(self.address)</div><div class="line">        return self.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.sock.close()</div><div class="line">        self.sock = None</div><div class="line"># 看到类的书写方法，当然是很熟悉，要融化于心;-)</div></pre></td></tr></table></figure>
<p><code>__enter__()</code>方法的返回值为赋值给as生命的变量，<code>__exit__()</code>方法进行清理工作</p>
<h1 id="创建大量对象时节省内存的方法"><a href="#创建大量对象时节省内存的方法" class="headerlink" title="创建大量对象时节省内存的方法"></a>创建大量对象时节省内存的方法</h1><p>对于主要是用来当成简单数据结构的类来说，可以通过给类添加<code>__slots__</code>属性来极大减少实例所占的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Date:</div><div class="line">    __slots__ = [&apos;year&apos;, &apos;month&apos;, &apos;day&apos;]</div><div class="line">    def __init__(self, year, month, day):</div><div class="line">        self.year = year</div><div class="line">        self.month = month</div><div class="line">        self.day = day</div></pre></td></tr></table></figure>
<p>定义<code>__slots__</code>后，实例就会通过很小的固定大小的数组创建，但是有一个缺点就是只能用在<code>__slots__</code>定义的属性名，不能给实例添加新的属性了。使用slots后节省的内存会跟存储属性的数量和类型有关。不过使用它最好只在真的需要的地方作为内存优化工具。</p>
<h1 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h1><p><code>_internal</code>单个下划线开头的名字应该是内部实现，同样适用于模块名和模块级别的函数，<code>__private</code>双下划线开头的名字是私有属性或者私有方法，这种属性或者方法是无法通过继承被覆盖的。</p>
<p>应该让非公共名称以单下划线开始，如果代码涉及子类，并且有些内部属性应该在子类中隐藏，那么使用双下划线方案。</p>
<p>如果定义的变量和某个保留关键字冲突，后面加上单下划线，<code>lambda_</code></p>
<h1 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h1><p>对于重复代码，可以使用装饰器和闭包啊，我现在觉得capacity包的代码又可以优化了。</p>
<p>给某个实例属性增加除了访问和修改之外的其他逻辑，比如类型检查或者合法性验证。自定义属性的简单方法是将它定义为一个property。</p>
<p>下面的这种定义方式值得学习：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Person:</div><div class="line">    def __init__(self, first_name):</div><div class="line">        # 初始化的时候也进行类型检查，first_name是一个属性</div><div class="line">        self.first_name = first_name</div><div class="line">    @property</div><div class="line">    def first_name(self):</div><div class="line">        return self._first_name</div><div class="line">    @first_name.setter</div><div class="line">    def first_name(self, value):</div><div class="line">        if not isinstance(value, str):</div><div class="line">            raise TypeError(&apos;Expected a string&apos;)</div><div class="line">        self._first_name = value</div><div class="line">    @first_name.deleter</div><div class="line">    def first_name(self):</div><div class="line">        raise AttributeError(&quot;can not delete attribute&quot;)</div></pre></td></tr></table></figure>
<p>只有在first_name属性被创建后，后面的两个装饰器才能被定义。另外在初始化的时候也进行类型检查，通过设置<code>self.first_name</code>，自动调用setter方法。</p>
<p>不要写没有做任何其他额外操作的property，而且property还是一种定义动态计算attribute的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import math</div><div class="line">class Circle:</div><div class="line">    def __init__(self, radius):</div><div class="line">        self.radius = radius</div><div class="line">    @property</div><div class="line">    def area(self):</div><div class="line">        return math.pi * self.radius ** 2</div><div class="line">c = Circle(4.0)</div><div class="line">c.radius</div><div class="line">c.area</div></pre></td></tr></table></figure>
<h1 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h1><p>调用父类的一个方法，可以使用super()函数，super()函数的一个常见用法是在<code>__init__()</code>方法中确保父类被正确的初始化了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A:</div><div class="line">    def __init__(self):</div><div class="line">        self.x = 0</div><div class="line">class B(A):</div><div class="line">    def __init__(self):</div><div class="line">        # 其他的普通方法也是如此使用</div><div class="line">        super().__init__()</div><div class="line">        self.y = 1</div></pre></td></tr></table></figure>
<p>对于定义的每一个类，Python会计算出一个方法解析顺序(MRO)列表，这个列表就是一个简单的所有基类的线性顺序表，为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<h1 id="子类中扩展property"><a href="#子类中扩展property" class="headerlink" title="子类中扩展property"></a>子类中扩展property</h1><p>扩展定义在父类的property的功能，一个property是getter，setter和deleter方法的集合，而不是单个方法，所以扩展property的时候确定是重新定义所有方法，还是只修改其中一个。</p>
<h2 id="重新定义所有方法"><a href="#重新定义所有方法" class="headerlink" title="重新定义所有方法"></a>重新定义所有方法</h2><p>使用super()来调用父类的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @property</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div><div class="line">    @name.setter</div><div class="line">    def name(self, value):</div><div class="line">        print(&quot;Setting name to &quot;, value)</div><div class="line">        super(SubPerson, Subperson).name.__set__(self, value)</div><div class="line">    @name.deleter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;Deleting name&quot;)</div><div class="line">        super(SubPerson, SubPerson).name.__delete__(self)</div></pre></td></tr></table></figure>
<p>使用<code>super(SubPerson, SubPerson).name.__delete__(self)</code>原因是将控制权传递给之前定义的name属性的<code>__delete__()</code>方法，但是获取这个方法的唯一途径是使用类变量来访问。</p>
<h2 id="重定义其中一个方法"><a href="#重定义其中一个方法" class="headerlink" title="重定义其中一个方法"></a>重定义其中一个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SubPerson(Person):</div><div class="line">    @Person.getter</div><div class="line">    def name(self):</div><div class="line">        print(&quot;getting name&quot;)</div><div class="line">        return super().name</div></pre></td></tr></table></figure>
<p>如此，property之前已经定义过的方法会被复制过来，而getter函数被替换。</p>
<p>如果不知道到底哪个基类定义了property，只能重新定义所有property并且使用super()来将控制权传递给前面的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与类定义有关的常见编程模型，包括让对象支持常见的Python特性，特殊方法的使用，类封装技术，继承，内存管理以及有用的设计模式。&lt;/p&gt;
&lt;h1 id=&quot;改变对象的字符串显示&quot;&gt;&lt;a href=&quot;#改变对象的字符串显示&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python Guide</title>
    <link href="http://microndgt.github.io/2017/01/27/Python-guide/"/>
    <id>http://microndgt.github.io/2017/01/27/Python-guide/</id>
    <published>2017-01-27T03:18:47.000Z</published>
    <updated>2017-01-28T06:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><p><code>list, tuple, set</code></p>
<h2 id="fronzenset"><a href="#fronzenset" class="headerlink" title="fronzenset"></a>fronzenset</h2><p>元素一经创建，不可增加、删除和修改。</p>
<h2 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h2><p>记录了内容添加的顺序，以添加顺序为准<code>d1 = collections.OrderedDict()</code></p>
<h2 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h2><p>会自动为它的键赋一个初值，<code>frequencies = defaultdict(int)</code>，所以默认值是int类型的，如果<code>frequencies = defaultdict(list)</code>，键对应的值类型就默认是列表类型的</p>
<h2 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h2><p>高效实现插入和删除操作的双向列表，适合用于列表和栈，对的，是否可以用在项目上经常有<code>insert</code>的列表数据结构上？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</div><div class="line">q.append(&apos;x&apos;)</div><div class="line">q.appendleft(&apos;y&apos;)</div><div class="line"># 还支持pop()和popleft()</div></pre></td></tr></table></figure>
<h2 id="collections-namedtuple"><a href="#collections-namedtuple" class="headerlink" title="collections.namedtuple"></a>collections.namedtuple</h2><p>创建了一个自定义的tuple对象，并且规定了tuple元素的个数，并且可以用属性而不是索引来表示tuple中的某个元素，这样<code>namedtuple</code>定义的数据类型，具备tuple的不变性，又可以根据属性来引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from collections import namedtuple</div><div class="line"># 名称，属性list</div><div class="line">Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])</div><div class="line">p = Point(1, 2)</div><div class="line">p.x</div><div class="line">p.y</div></pre></td></tr></table></figure>
<h2 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h2><p>简单的计数器，比如统计字符出现的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">a = &quot;programming&quot;</div><div class="line">c = Counter(a)</div><div class="line">c.most_common()</div></pre></td></tr></table></figure>
<blockquote>
<p>去刷leetcode！看看算法导论</p>
</blockquote>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>这块自己应该是最薄弱的地方吧，没有系统的概念，所以多看书，多学习吧。这里有两个资源：</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">从输入URL 到页面加载完成的过程中都发生了什么事情</a></p>
<p>图解Http</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>有三种类型的数据库，关系型数据库，文档型数据库(mongodb)，内存型数据库(Redis)</p>
<p>有时间去研究一下mongodb，强化学习一下Redis</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>这块虽然基本的自己在用，但是好多都没有实践，比如合并请求之类的命令，现在发现好多都需要学习。。。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add . #将什么添加到仓库</div><div class="line">git commit -m &quot;wrote a note&quot; # 将文件提交到仓库</div><div class="line">git status #掌握仓库当前状态</div><div class="line">git diff # 查看做了什么修改</div></pre></td></tr></table></figure>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git log # 查看历史记录，显示最近到最远的提交日志</div><div class="line">git log --pretty=oneline # 只输出一条必要信息</div><div class="line"># HEAD表示当前版本，HEAD^表示上一个版本,HEAD^^上上一个版本，HEAD^100表示往上100个版本</div><div class="line">git reset --hard HEAD^ # 表示回退到上一个版本</div><div class="line"># 可以使用新版本的commit id号再回去，输入前几位也可以</div><div class="line">git reset --hard 326234</div><div class="line"># 下面命令记录了git的每次命令</div><div class="line">git reflog</div></pre></td></tr></table></figure>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><code>git add</code>命令是把要提交的所有修改放到暂存区，<code>git commit</code>是把暂存区的所有修改提交到分支</p>
<p>每次修改，如果不add到暂存区，就不会加入到commit中</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，将文件在工作区的修改全部撤销，也就是将该文件回到最近一次<code>git commit</code>或者<code>git add</code>时的状态</p>
<p>如果不想要的内容已经<code>git add</code>到暂存区，但是没有提交，那么<code>git reset HEAD file</code>可以将暂存区的修改撤销掉，重新放回工作区，然后<code>git checkout -- file</code>丢弃工作区的修改</p>
<p>如果已经commit那么使用版本回退</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除之后，工作区和版本库就不一致，这时候如果确实要在版本库中删除文件，那么使用<code>git rm file</code>并且<code>git commit</code></p>
<p>如果删除错了，那么从版本库中将文件恢复<code>git checkout -- file</code>，<code>git checkout</code>其实是用版本库的版本替换工作区的版本</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>一台电脑充当服务器的角色，其他每个人都是从服务器仓库中克隆一份到自己电脑上，并且各自把自己的提交推送到服务器仓库中，也从服务器仓库中拉取别人的提交。所以完全可以自己搭建一台运行Git的服务器。</p>
<p>git支持多种协议，https，但是通过ssh支持的原生的git协议速度最快，有必要，每次都输密码真是烦。在<code>hexo</code>配置文件中<code>_config.yml</code>设置<code>deploy</code>属性，<code>repo</code>为<code>git@github.com:Microndgt/microndgt.github.io.git</code>即可。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>HEAD</code>指向的是<code>master</code>，<code>master</code>指向提交，所以<code>HEAD</code>指向的就是当前分支</p>
<p>创建一个分支后，增加了一个<code>dev</code>指针，指向与<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上，新提交一次，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变，合并的时候把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并，删除<code>dev</code>分支是把<code>dev</code>指针给删掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># -b创建并且切换</div><div class="line">git checkout -b dev</div><div class="line"># 相当于以下</div><div class="line">git branch dev</div><div class="line">git checkout dev</div><div class="line"># 查看分支</div><div class="line">git branch</div><div class="line"># 切换分支</div><div class="line">git checkout master</div><div class="line"># 合并分支,合并指定分支到当前分支</div><div class="line">git merge dev</div><div class="line"># 合并完成后，删除dev分支</div><div class="line">git branch -d dev</div></pre></td></tr></table></figure>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>就是自己之前考虑的情况，这种情况如果是两个分支修改的文件各不相同就可以自动merge，没有冲突，但是如果修改了一个文件的话，就会产生冲突，就不能快速合并，必须解决冲突之后才能合并，可以使用<code>git status</code>来查看冲突文件，解决冲突之后<code>git merge feature1</code>，然后删除<code>feature1</code>分支,<code>git branch -d feature1</code></p>
<h2 id="非快速合并分支"><a href="#非快速合并分支" class="headerlink" title="非快速合并分支"></a>非快速合并分支</h2><p>通常分支合并会使用<code>Fast forward</code>，这种模式下，删除分支后，会丢掉分支信息，强制禁用<code>Fast forward</code>，就会在<code>merge</code>生成一个新的commit，这样在分支历史上就可以看出分支信息。</p>
<p>合并的时候指定<code>--no-ff</code>参数<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去</p>
<h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p>一般是<code>master</code>分支非常稳定，仅用来发布新版本，平时在<code>dev</code>分支干活，如果1.0版本发布的时候，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本</p>
<p>然后团队每个人在<code>dev</code>分支上干活，每个人都有自己的分支，时不时往<code>dev</code>分支上合并即可。</p>
<p>我打算是<code>master</code>作为主分支，然后建立一个<code>dev</code>分支，我在这个上面干活，然后其他人就建立自己的分支，然后我来从<code>dev</code>分支合并他们的分支，然后每次稳定版本发布再合并到<code>master</code></p>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>每添加一个新功能的时候，最好新建一个feature分支，在上面开发，如果完成，合并，最后删除该feature分支，如果新功能要取消，就可以销毁掉这个分支<code>git branch -D feature-vulcan</code></p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>git中，分支完全可以自己本地搞，推送的时候推送合并后的主分支好了。所以开发的时候，现在可以创建一个新分支，然后开发，最后合并删除即可，再推送。</p>
<p>如果别人clone，默认只能看到<code>master</code>分支，那么要用其他分支，必须创建远程<code>origin</code>的<code>dev</code>分支到本地，<code>git checkout -b dev origin/dev</code>，如果别人更新了仓库，那么可以<code>git pull</code>然后再本地合并，解决冲突，再推送，但是必须指定本地分支与远程分支进行链接<code>git branch --set-upstream dev origin/dev</code></p>
<p>查看远程库信息<code>git remote -v</code></p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>git tag -a v0.1 -m &quot;version 0.1 released&quot;</code></p>
<h1 id="专业素养"><a href="#专业素养" class="headerlink" title="专业素养"></a>专业素养</h1><p>不仅需要写程序，还要写文档，写注释，单元测试，这里自己还欠缺的能力是单元测试，有时间去研究学习一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法与数据结构&quot;&gt;&lt;a href=&quot;#算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构&quot;&gt;&lt;/a&gt;算法与数据结构&lt;/h1&gt;&lt;p&gt;&lt;code&gt;list, tuple, set&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;fronzens
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python函数</title>
    <link href="http://microndgt.github.io/2017/01/23/Python%E5%87%BD%E6%95%B0/"/>
    <id>http://microndgt.github.io/2017/01/23/Python函数/</id>
    <published>2017-01-23T06:34:34.000Z</published>
    <updated>2017-01-27T05:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认参数，任意数量参数，强制关键字参数，注解和闭包。</p>
<h1 id="可接受任意数量参数的函数"><a href="#可接受任意数量参数的函数" class="headerlink" title="可接受任意数量参数的函数"></a>可接受任意数量参数的函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def avg(first, *rest):</div><div class="line">    # 传入相当于一个序列</div><div class="line">    return (first + sum(rest)) / (1 + len(rest))</div></pre></td></tr></table></figure>
<p>任意数量的关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def make_element(name, value, **attrs):</div><div class="line">    keyvals = [&apos; %s = &quot;%s&quot; &apos; % item for item in attrs.items()]</div></pre></td></tr></table></figure>
<p>任意数量的位置参数和关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def anyargs(*args, **kwargs):</div><div class="line">    print(args)</div><div class="line">    print(kwargs)</div></pre></td></tr></table></figure>
<h1 id="强制关键字参数"><a href="#强制关键字参数" class="headerlink" title="强制关键字参数"></a>强制关键字参数</h1><p>将强制关键字参数放到某个<em>参数，或者单个</em>后面就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def recv(maxsize, *, block):</div><div class="line">    pass</div><div class="line">recv(1024, block=True)</div><div class="line">def mininum(*values, clip=None):</div><div class="line">    pass</div><div class="line">mininum(1, 5, 2, clip=0)</div></pre></td></tr></table></figure>
<p>使用强制关键字参数可以使得对调用者友好，并且也比<code>**kwargs</code>友好，因为help输出的时候更容易理解</p>
<h1 id="给函数参数增加元信息"><a href="#给函数参数增加元信息" class="headerlink" title="给函数参数增加元信息"></a>给函数参数增加元信息</h1><p>增加额外信息，这样使用者就知道函数应该怎样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add(x:int, y:int) -&gt; int:</div><div class="line">    return x + y</div></pre></td></tr></table></figure>
<p>并不会类型检查，一般加上简单的注解，通常使用类或者字符串会更好</p>
<h1 id="定义有默认参数的函数"><a href="#定义有默认参数的函数" class="headerlink" title="定义有默认参数的函数"></a>定义有默认参数的函数</h1><p>定义一个有可选参数的函数直接在函数定义中给参数指定一个默认值，并且放到参数列表最后就可以了。</p>
<p>如果默认参数是一个可以修改的容器比如列表，使用None作为默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def spam(a, b=None):</div><div class="line">    if b is None:</div><div class="line">        b = []</div></pre></td></tr></table></figure>
<p>默认值仅仅在函数定义的时候赋值一次，默认参数的值应该是不可变的对象，并且在测试None值的时候使用is操作符。<code>if a is None:</code></p>
<h1 id="匿名函数捕获变量值"><a href="#匿名函数捕获变量值" class="headerlink" title="匿名函数捕获变量值"></a>匿名函数捕获变量值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = 10</div><div class="line">a = lambda y: x + y</div><div class="line">x = 20</div><div class="line">b = lambda y: x + y</div></pre></td></tr></table></figure>
<p><code>a(10)</code>和<code>b(10)</code>的结果都是30，因为lambda表达式中x是一个自由变量，在运行的时候绑定值，也就是说，在调用lambda表达式的时候，x的值是执行时的值，和函数的默认参数定义是不一样的。</p>
<p>如果想让某个匿名函数在定义的时候捕获到值，可以将那个参数值定义成默认参数</p>
<p><code>a = lambda y, x=x: x + y</code></p>
<h1 id="减少可调用对象的参数个数"><a href="#减少可调用对象的参数个数" class="headerlink" title="减少可调用对象的参数个数"></a>减少可调用对象的参数个数</h1><p>有一个被其他python代码使用的callable对象，可能是一个回调函数或者是一个处理器，但是参数过多的时候，可能导致调用出错。对这就是为什么我的多进程调用没有作用，可能这个是一方面原因，另外一方面原因就是传入的是可变对象。</p>
<p>使用<code>functools.partial()</code>允许给一个或者多个参数设置固定的值，减少接下来被调用时候的参数个数。</p>
<p>一个例子，partial用来微调其他库函数所使用的回调函数的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def output_result(result, log=None):</div><div class="line">    if log is not None:</div><div class="line">        log.debug(&apos;Got: %r&apos;, result)</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import logging</div><div class="line">    from multiprocessing import Pool</div><div class="line">    from functools import partial</div><div class="line">    logging.basicConfig(level=logging.DEBUG)</div><div class="line">    log = logging.getLogger(&apos;test&apos;)</div><div class="line">    p = Pool()</div><div class="line">    p.apply_async(add, (3, 4), callback=partial(outoutput_result, log=log))</div><div class="line">    p.close()</div><div class="line">    p.join()</div></pre></td></tr></table></figure>
<h1 id="将单方法的类转换成函数"><a href="#将单方法的类转换成函数" class="headerlink" title="将单方法的类转换成函数"></a>将单方法的类转换成函数</h1><p>可以使用闭包将单个方法的类转换成函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from urllib.request import urlopen</div><div class="line">class UrlTemplate:</div><div class="line">    def __init__(self, template):</div><div class="line">        self.template = template</div><div class="line">    def open(self, **kwargs):</div><div class="line">        return urlopen(self.template.format_map(kwargs))</div></pre></td></tr></table></figure>
<p>可以使用闭包来代替:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def urltemplate(template):</div><div class="line">    def opener(**kwargs):</div><div class="line">        return urlopen(template.format_map(kwargs))</div><div class="line">    return opener</div></pre></td></tr></table></figure>
<p>经典啊！使用单方法类的原因是需要存储某些额外的状态来给方法使用，但是使用内部函数或者闭包更优雅，一个闭包就是一个函数，只不过在函数内部带上了一个额外的变量环境。闭包关键特点是它会记住自己被定义时的环境。</p>
<p>任何时候遇到需要给某个函数增加额外的状态信息的问题，都可以考虑使用闭包。</p>
<h1 id="带额外状态信息的回调函数"><a href="#带额外状态信息的回调函数" class="headerlink" title="带额外状态信息的回调函数"></a>带额外状态信息的回调函数</h1><p>代码需要依赖到回调函数的使用，并且需要让回调函数拥有额外的状态值，以便在它的内部使用。</p>
<p>回调函数的使用，仅仅接受一个参数，不能再传入其他信息。</p>
<p>为了让回调函数访问外部信息，一种方法是使用绑定方法来代替一个简单函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class ResultHandler:</div><div class="line">    def __init__(self):</div><div class="line">        self.sequence = 0</div><div class="line">    def handler(self, result):</div><div class="line">        self.sequence += 1</div><div class="line">        print(self.sequence, result)</div></pre></td></tr></table></figure>
<p>先创建实例，然后使用它的handler()绑定方法作为回调函数</p>
<p><code>apply_async(add, (2, 3), callback=r.handler)</code></p>
<p>可以使用闭包捕获状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    def handler(result):</div><div class="line">        nonlocal sequence</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div><div class="line">    return handler</div></pre></td></tr></table></figure>
<p>使用协程来储存状态值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def make_handler():</div><div class="line">    sequence = 0</div><div class="line">    while True:</div><div class="line">        result = yield</div><div class="line">        sequence += 1</div><div class="line">        print(sequence, result)</div></pre></td></tr></table></figure>
<p>使用send方法作为回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handler=make_handler()</div><div class="line">next(handler) ＃必须的，走到yield</div><div class="line">apply_async(add, (2, 3), callback=handler.send)</div></pre></td></tr></table></figure>
<h1 id="访问闭包中定义的变量"><a href="#访问闭包中定义的变量" class="headerlink" title="访问闭包中定义的变量"></a>访问闭包中定义的变量</h1><p>扩展函数中的某个闭包，允许其能访问和修改函数的内部变量，通过编写访问函数并将其作为函数属性绑定到闭包上实现这个目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def sample():</div><div class="line">    n = 0</div><div class="line">    def func():</div><div class="line">        print(&apos;n=&apos;, n)</div><div class="line">    def get_n():</div><div class="line">        return n</div><div class="line">    def set_n(value):</div><div class="line">        nonlocal n</div><div class="line">        n = value</div><div class="line">    fuuc.get_n = get_n</div><div class="line">    func.set_n = set_n</div><div class="line">    return func</div><div class="line">f = sample()</div><div class="line">f()</div><div class="line">f.set_n(10)</div><div class="line">f.get_n()</div></pre></td></tr></table></figure>
<p>函数属性可以使用简单的方式将访问方法绑定到闭包函数上。</p>
<h1 id="内联回调函数"><a href="#内联回调函数" class="headerlink" title="内联回调函数"></a>内联回调函数</h1><p>回调函数可能会找不清楚程序控制流，所以使用内联回调函数可以看起来像一个普通的执行序列。</p>
<p>使用生成器和协程可以使得回调函数内联在某个函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from functools import wraps</div><div class="line"># 使用functools.wraps可以保证装饰器不会对被装饰函数造成影响，原函数返回内部函数，这样原函数的名字变成了内部函数，所以把原函数的名字等属性复制到内部函数中，这样的话依赖函数签名的代码就不会执行出错。</div><div class="line">class Async:</div><div class="line">    def __init__(self, func, args):</div><div class="line">        self.func = func</div><div class="line">        self.args = args</div><div class="line">def inlined_async(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args):</div><div class="line">        # 这里相当于初始化生成器</div><div class="line">        f = func(*args)</div><div class="line">        result_queue = Queue()</div><div class="line">        result_queue.put(None)</div><div class="line">        while True:</div><div class="line">            result = result_queue.get()</div><div class="line">            try:</div><div class="line">                # 第一次发送None，作为必须的next，走到yield,下次来就会把计算结果发送过去，作为r，然后print，然后走向下一个yield</div><div class="line">                a = f.send(result)</div><div class="line">                # 返回a是Async对象，也就是yield之后的对象</div><div class="line">                apply_async(a.func, a.args, callback=result_queue.put)</div><div class="line">            except StopIteration:</div><div class="line">                break</div><div class="line">    return wrapper</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div><div class="line">@inlined_async</div><div class="line">def test():</div><div class="line">    r = yield Async(add, (2, 3))</div><div class="line">    print(r)</div><div class="line">    r = yield Async(add, (&apos;hello&apos;, &apos;world&apos;))</div><div class="line">    print(r)</div><div class="line">    for n in range(10):</div><div class="line">        r = yield Async(add, (n, n))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认参数，任意数量参数，强制关键字参数，注解和闭包。&lt;/p&gt;
&lt;h1 id=&quot;可接受任意数量参数的函数&quot;&gt;&lt;a href=&quot;#可接受任意数量参数的函数&quot; class=&quot;headerlink&quot; title=&quot;可接受任意数量参数的函数&quot;&gt;&lt;/a&gt;可接受任意数量参数的函数&lt;/h1
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python数字日期和时间</title>
    <link href="http://microndgt.github.io/2017/01/20/Python%E6%95%B0%E5%AD%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/"/>
    <id>http://microndgt.github.io/2017/01/20/Python数字日期和时间/</id>
    <published>2017-01-20T03:20:22.000Z</published>
    <updated>2017-01-27T05:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。</p>
<h1 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h1><p><code>round(value, ndigits)</code>比如<code>round(1.231, 1)</code>为1.2，如果在中间的话，返回离它最近的偶数，1.5和2.5都会返回2，并且ndigits可以是负数，这样舍入运算作用在十位，百位和千位上。</p>
<p>如果不允许小误差，那么使用decimal模块。</p>
<h1 id="精确的浮点数运算"><a href="#精确的浮点数运算" class="headerlink" title="精确的浮点数运算"></a>精确的浮点数运算</h1><p>精确但是有性能损失，使用decimal模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from decimal import Decimal</div><div class="line">a = Decimal(&apos;4.2&apos;)</div><div class="line">b = Decimal(&apos;2.1&apos;)</div><div class="line">print(a + b) # 6.3</div></pre></td></tr></table></figure>
<p>decimal可以允许你控制计算的数字位数和四舍五入运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 创建本地上下文并且更改它的设置</div><div class="line">with localcontext() as ctx:</div><div class="line">    ctx.prec = 3 # 位数</div><div class="line">print(a / b)</div></pre></td></tr></table></figure>
<p>之前遇到的情况是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nums = [1.23e+18, 1, -1.23e+18]</div><div class="line">sum(nums)</div><div class="line"># 可以使用math.fsum()提供的更精确计算能力来解决</div><div class="line">import math</div><div class="line">math.fsum(nums)</div></pre></td></tr></table></figure>
<p>处理金融数据的时候会用到decimal模块</p>
<h1 id="数字的格式化输出"><a href="#数字的格式化输出" class="headerlink" title="数字的格式化输出"></a>数字的格式化输出</h1><p>控制数字位数，对齐，千位分隔符和其他细节</p>
<p>格式化输出单个数字的时候，可以使用内置的format()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = 1234.56789</div><div class="line">format(x, &apos;0.2f&apos;)</div><div class="line">format(x, &apos;&gt;10.1f&apos;) # 右对齐宽度10</div><div class="line">format(x, &apos;~10.1f&apos;) # 居中</div><div class="line">format(x, &apos;,&apos;) # 千位符</div></pre></td></tr></table></figure>
<p>指定宽度和精度的一般形式是<code>&#39;[&lt;&gt;^]?width[,]?(.digits)?&#39;</code>，同样的格式也用在字符串的format()方法中</p>
<p><code>the value is {:0,.2f}.format(x)</code></p>
<p>格式化值会根据指定数字的位数，和round函数采用同样的规则</p>
<h1 id="二八十六进制整数"><a href="#二八十六进制整数" class="headerlink" title="二八十六进制整数"></a>二八十六进制整数</h1><p><code>bin(x)</code>和<code>oct(x)</code>和<code>hex(x)</code>，如果不想显示前缀的话，使用format函数，<code>format(x, &#39;b&#39;)</code> 和 <code>format(x, &#39;o&#39;)</code>和<code>format(x, &#39;x&#39;)</code></p>
<p>将不同进制转换整数字符串，使用带有进制的int()函数<code>int(&#39;4d2&#39;, 16)</code>或者<code>int(&#39;0010&#39;, 2)</code>表示16进制，2进制</p>
<h1 id="无穷大和NaN"><a href="#无穷大和NaN" class="headerlink" title="无穷大和NaN"></a>无穷大和NaN</h1><p>使用<code>float()</code>来创建它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = float(&apos;inf&apos;)</div><div class="line">b = float(&apos;-inf&apos;)</div><div class="line">c = float(&apos;nan&apos;)</div></pre></td></tr></table></figure>
<p>使用<code>math.isinf()</code>和<code>math.isnan()</code>函数来测试值是否存在,也可以使用<code>numpy.isinf()</code>或者<code>numpy.isnan()</code></p>
<p>NaN值会在所有操作中传播，而不会产生异常</p>
<h1 id="分数运算"><a href="#分数运算" class="headerlink" title="分数运算"></a>分数运算</h1><p>fractions模块可以用来执行包含分数的数学运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from fractions import Fraction</div><div class="line">a = Fraction(5, 4)</div><div class="line">b = Fraction(7, 16)</div><div class="line">print(a + b)</div><div class="line">float(a + b)</div></pre></td></tr></table></figure>
<h1 id="大型数组运算"><a href="#大型数组运算" class="headerlink" title="大型数组运算"></a>大型数组运算</h1><p>使用NumPy库，提供一个数组对象，更适合用来进行数学运算，底层实现中，NumPy数组使用了C或者Fortran语言的机制分配内存，它们是一个非常大的连续的并且由同类型数据组成的内存区域。<code>import numpy as np</code></p>
<p>同时NumPy库有矩阵对象来进行线性代数运算</p>
<h1 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h1><p>从一个序列中随机抽选一个元素，使用<code>random.choice()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import random</div><div class="line">values = [1, 2, 3, 4, 5, 6]</div><div class="line">random.choice(values)</div></pre></td></tr></table></figure>
<p>提取N个不同元素的样本来作进一步操作，<code>random.sample(values, 2)</code></p>
<p>打乱序列中元素顺序，<code>random.shuffle(values)</code>，原地修改顺序</p>
<p>生成随机整数，<code>random.randint(0, 10)</code> 包括0和10</p>
<p>生成0到1范围内均匀分布的浮点书，使用<code>random.random()</code></p>
<p>通过<code>random.seed()</code>函数修改初始化种子，<code>random.seed(12345)</code></p>
<h1 id="基本的日期与时间转换"><a href="#基本的日期与时间转换" class="headerlink" title="基本的日期与时间转换"></a>基本的日期与时间转换</h1><p>使用datetime模块，表示一个时间段，创建一个timedelta实例，<code>a = timedelta(days=2)</code></p>
<p>创建一个datetime实例<code>a = datetime(2012, 9, 23)</code></p>
<p><code>now = datetime.today()</code>，并且datetime会自动处理闰年</p>
<p>使用<code>dateutil</code>模块处理时区，模糊时间范围，节假日计算，使用<code>dateutil.relativedelta</code>来计算间距日期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">a = datetime(2017, 1, 21)</div><div class="line">a + relativedelta(years=-1)</div></pre></td></tr></table></figure>
<h1 id="最后一个周五的日期"><a href="#最后一个周五的日期" class="headerlink" title="最后一个周五的日期"></a>最后一个周五的日期</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime, timedelta</div><div class="line">weekdays = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;,</div><div class="line">            &apos;Friday&apos;, &apos;Saturday&apos;, &apos;Sunday&apos;]</div><div class="line">def get_previous_byday(dayname, start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        start_date = datetime.today()</div><div class="line">    day_num = start_date.weekday() # 返回序号，周一是第一个0</div><div class="line">    day_num_target = weekdays.index(dayname)</div><div class="line">    # 这里因为有两种情况，一种是现在日期序号大于或者等于target的，这样直接减就好，比如周三2减去周二1等于1，说明上一个周二离现在1天</div><div class="line">    ＃ 另外一种情况是日期序号小于的，这样直接减就是负的，并且肯定是上一个星期的，但是不足7天，所以7加上这个差</div><div class="line">    days_ago = (7 + day_num - day_num_target) % 7</div><div class="line">    if days_ago == 0:</div><div class="line">        days_ago = 7</div><div class="line">    target_date = start_date - timedelta(days=days_ago)</div><div class="line">    return target_date</div></pre></td></tr></table></figure>
<p>可以使用dateutil模块中的relativedelta()函数执行同样的计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from dateutil.relativedelta import relativedelta</div><div class="line">d = datetime.now()</div><div class="line">print(d + relativedelta(weekday=FR))</div><div class="line">print(d + relativedelta(weekday=FR(-1)))</div></pre></td></tr></table></figure>
<h1 id="计算当前月份的日期范围"><a href="#计算当前月份的日期范围" class="headerlink" title="计算当前月份的日期范围"></a>计算当前月份的日期范围</h1><p><code>calendar.monthrange(year, month)</code>返回该月第一天的weekday和这个月的天数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">def get_month_range(start_date=None):</div><div class="line">    if start_date is None:</div><div class="line">        # 计算出对应月份第一天的日期</div><div class="line">        start_date = date.today().replace(day=1)</div><div class="line">    _, days_in_month = calendar.monthrange(start_date.year, start_date.month)</div><div class="line">    end_date = start_date + timedelta(days=days_in_month)</div><div class="line">    return (start_date, end_date)</div><div class="line">a_day = timedelta(days=1)</div><div class="line">first_day, last_day = get_month_range()</div><div class="line"># 结束日期不包含在日期范围内</div><div class="line">while first_day &lt; last_day:</div><div class="line">    print(first_day)</div><div class="line">    first_day += a_day</div><div class="line"># 或者定义一个生成器</div><div class="line">def date_range(start, stop, step):</div><div class="line">    while start &lt; stop:</div><div class="line">        yield start</div><div class="line">        start += step</div></pre></td></tr></table></figure>
<h1 id="字符串转换为日期"><a href="#字符串转换为日期" class="headerlink" title="字符串转换为日期"></a>字符串转换为日期</h1><p>使用<code>datetime.strptime()</code>方法的性能还是很低的，所以如果知道了日期字符串的确切形式，可以自己实现解析方案来获取更好的性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line">def parse_ymd(s):</div><div class="line">    year_s, mon_s, day_s = s.split(&apos;-&apos;)</div><div class="line">    return datetime(int(year_s), int(mon_s), int(day_s))</div></pre></td></tr></table></figure>
<p>速度比<code>datetime.strptime()</code>快7倍多，6666，把capacity项目的都改过来了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;执行分数，数组或者日期和时间运算，就需要更多工作，不过这里着重关注日期和时间的运算，毕竟工作上对时间处理还是比较多的。&lt;/p&gt;
&lt;h1 id=&quot;数字的四舍五入&quot;&gt;&lt;a href=&quot;#数字的四舍五入&quot; class=&quot;headerlink&quot; title=&quot;数字的四舍五入&quot;&gt;&lt;/
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发可规模化的应用</title>
    <link href="http://microndgt.github.io/2017/01/20/%E7%94%A8Python%E5%BC%80%E5%8F%91%E5%8F%AF%E8%A7%84%E6%A8%A1%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://microndgt.github.io/2017/01/20/用Python开发可规模化的应用/</id>
    <published>2017-01-20T00:47:38.000Z</published>
    <updated>2017-01-27T05:22:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Developing Scalable Apps in Python!</p>
<h1 id="Scalability-Basics"><a href="#Scalability-Basics" class="headerlink" title="Scalability Basics"></a>Scalability Basics</h1><p>在Google基础结构上运行的应用，缩放，scale，可缩放应用</p>
<p>the race for scalability 可伸缩性争用</p>
<p>optimize software, change software to run on more servers -&gt; scalable architecture</p>
<h2 id="从在单个计算机运行解耦"><a href="#从在单个计算机运行解耦" class="headerlink" title="从在单个计算机运行解耦"></a>从在单个计算机运行解耦</h2><p>将向外扩展架构设计为将应用扩展到单一计算机范围之外，因此还需要扩展此分布式架构(distributed architecture)， 而不是共享架构(share architecture)，有道理，不能用共享的，这样扩展的时候共享资源就会称为瓶颈，分布式应用最好也不要有共享的数据，这样会导致通信，处理起来比较麻烦。虚拟机(virtual machine)</p>
<p>key step to building a scalable system is your need to decouple it from executing on a single computer. You design a scale out architecture as your application scales outside the scope of a single computer and this distributed architecture needs to be socalled, share nothing architecture. Meaning, that it must not depend on any shared resources that can become the bottleneck, this way if your application needs a scale, you can just provide more computer to provide the additional capacity required. That means, you can run your application on. All the things. And to get even more flexibility the concept of virtual machines was born which enables you to decouple a physical machine from the application execution machine. This had great flexibility gain since the infrastructure turned virtual you would now run your scale out application on several virtual machines instead of physical computers. You can now scale indefinitely by adding these standard building blocks of performance that your application can utilize and you have decomposed(分解) your application from the specific execution machine. So how do you design your application to be able to scale like this?</p>
<h2 id="Use-distributed-architecture-to-solve-problems"><a href="#Use-distributed-architecture-to-solve-problems" class="headerlink" title="Use distributed architecture to solve problems"></a>Use distributed architecture to solve problems</h2><p>plain virtual machines</p>
<p>First of all, virtual machines are nowadays a standard offering by any cloud service provider. This called IaaS, or infrastructure(基础设施) as a Service. This is because a computer and therefore also a virtual machine can be considered infrastructure today.And achieve unlimited scalability by distributing the execution(分布式计算) of our application, across these virtual machines.</p>
<p>creating this architecture for your application is a very complicated and resource intensive problem(资源密集型问题).</p>
<ul>
<li>VM Management. Starting and stopping the virtual machine.</li>
<li>Software Management</li>
<li>Web Server. Powerful</li>
<li>Distributed Database where you can read and write data, from all of your virtual machines.</li>
<li>A distributed file system, where you can read and write data which is accessible from all your virtual machines.</li>
<li>Application monitoring, with a consolidated view(统一视图) of any problems occurring in your distributed execution environment.</li>
<li>Availability including data replication, hardware software resilience(恢复力), geographic disaster recovery strategies. Back ups, recovery, automatic fail overs, et cetera.</li>
<li>Security set up and management(安全设置和管理) in your distributed execution environment</li>
<li>load balancing. How to spread the load across the VMs, including application level session management(应用级会话管理分布负载).</li>
</ul>
<h2 id="Google-App-Engine"><a href="#Google-App-Engine" class="headerlink" title="Google App Engine"></a>Google App Engine</h2><p>App Engine is a development and deployment platform that takes care of many things for your application.</p>
<p>internet services, server side applications.</p>
<h2 id="really-check"><a href="#really-check" class="headerlink" title="really check"></a>really check</h2><p>since App Engine provides services to control the execution environment, it also has to set up programming languages it supports. Python, Java, PHP, and GO. And since App Engine is an execution container, it also means that there are specific versions of these languages that are supported.</p>
<p><strong><em>it’s important to remember there are trade-offs with any framework or platform you use.</em></strong></p>
<p>outro(结尾)</p>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><p>app engine development cycle and create an app engine project where you can upload your code</p>
<p>cloud endpoints that allows you to create a backend that can work with any frontend device technology</p>
<p>a development environment where you develop code for app engine</p>
<p>conference central</p>
<p>不能连接Google是硬伤啊。。。算了，先到这里了，至少了解了scalable application</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Developing Scalable Apps in Python!&lt;/p&gt;
&lt;h1 id=&quot;Scalability-Basics&quot;&gt;&lt;a href=&quot;#Scalability-Basics&quot; class=&quot;headerlink&quot; title=&quot;Scalability B
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Udacity" scheme="http://microndgt.github.io/tags/Udacity/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hive学习</title>
    <link href="http://microndgt.github.io/2017/01/19/Hive%E5%AD%A6%E4%B9%A0/"/>
    <id>http://microndgt.github.io/2017/01/19/Hive学习/</id>
    <published>2017-01-19T07:26:16.000Z</published>
    <updated>2017-01-27T05:24:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>大数据之Hive的数据操作以及开发</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Hive是基于Hadoop的一个数据仓库工具，通过它可以实现将结构化的数据文件映射为一张数据库表，并且提供简单的sql查询功能，同时将sql语句转换为MapReduce任务进行运行</p>
<p>Hive是构建在hadoop HDFS上的一个数据仓库</p>
<h2 id="数据仓库简介"><a href="#数据仓库简介" class="headerlink" title="数据仓库简介"></a>数据仓库简介</h2><p>有别于普通的数据库，数据仓库是一个面向主题的，集成的，不可更新的，随时间不变化的数据集合，它用于支持企业或组织的决策分析处理</p>
<p>面向主题：用户关注的具体方面</p>
<p>集成的：来自分散性的数据，进行加工和处理后进入数据仓库</p>
<p>不可更新：主要用于决策分析，主要涉及操作，数据查询</p>
<h2 id="数据仓库的结构和建立过程"><a href="#数据仓库的结构和建立过程" class="headerlink" title="数据仓库的结构和建立过程"></a>数据仓库的结构和建立过程</h2><p>数据源：业务数据系统，文档资料，其他数据</p>
<p>数据存储及管理：抽取，转换，装载，Extract,Transform,load，满足格式的数据</p>
<p>数据仓库引擎：为数据查询等提供服务</p>
<p>前端展示：数据查询，数据报表，数据分析，各类应用</p>
<h2 id="OLTP应用和OLAP应用"><a href="#OLTP应用和OLAP应用" class="headerlink" title="OLTP应用和OLAP应用"></a>OLTP应用和OLAP应用</h2><p>OLTP:连接事务处理，面对事务，操作频率高，银行转账</p>
<p>OLAP:连接分析处理，Online analysis process, 商品推荐系统,面对的是查询操作</p>
<h2 id="数据仓库中的数据模型"><a href="#数据仓库中的数据模型" class="headerlink" title="数据仓库中的数据模型"></a>数据仓库中的数据模型</h2><p>面向主题的模型</p>
<p>星形模型：商品信息-&gt;客户信息，订单信息，促销信息，生产信息，物流信息</p>
<p>雪花模型：客户也可以分很多信息，家庭信息，地址信息，教育背景信息，财务信息</p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>Hive是构建在hadoop HDFS上的一个数据仓库基础架构</p>
<p>可以用来进行数据提取转化加载ETL</p>
<p>定义了简单的类似SQL查询语言，称为HQL它允许熟悉SQL的用户查询数据</p>
<p>允许MapReduce开发者的开发自定义的mapper和reducer来处理内建的mapper和reducer无法完成的复杂分析工作</p>
<p>Hive是SQL解析引擎，将SQL语句转移成M/R job然后在hadoop执行</p>
<p>Hive的表其实是HDFS的目录/文件</p>
<h1 id="Hive的体系结构"><a href="#Hive的体系结构" class="headerlink" title="Hive的体系结构"></a>Hive的体系结构</h1><h2 id="Hive的元数据"><a href="#Hive的元数据" class="headerlink" title="Hive的元数据"></a>Hive的元数据</h2><p>将元数据存储在数据库中(metastore)，支持mysql，derby等数据库，默认是derby数据库。</p>
<p>元数据包括表的名字，表的列和分区及其属性，表的属性是否为外部表，表的数据所在目录</p>
<h2 id="HQL的执行过程"><a href="#HQL的执行过程" class="headerlink" title="HQL的执行过程"></a>HQL的执行过程</h2><p>解释器，编译器和优化器完成HQL查询语句从词法分析，语法分析，编译，优化以及查询计划的生成，生成的查询计划存储在HDFS中，并在随后由MapReduce调用执行</p>
<p>select-&gt;解析器，词法分析-&gt;编译器，生成HQL的执行计划-&gt;优化器，生成最佳的执行计划-&gt;执行</p>
<h2 id="Hive的体系结构-1"><a href="#Hive的体系结构-1" class="headerlink" title="Hive的体系结构"></a>Hive的体系结构</h2><ul>
<li>Hadoop</li>
<li>元数据存储</li>
</ul>
<p>linux-&gt;hadoop-&gt;hive</p>
<p>hadoop: DataNode数据节点，NameNode名称节点，JobTracker任务调度器</p>
<p>hive：Hive Driver驱动包括编译器，解析器，优化器。访问接口：CLI,ODBC,Web Console只可以查询。元数据metastore</p>
<h2 id="Hive安装和管理"><a href="#Hive安装和管理" class="headerlink" title="Hive安装和管理"></a>Hive安装和管理</h2><h2 id="Hive的数据模型和操作"><a href="#Hive的数据模型和操作" class="headerlink" title="Hive的数据模型和操作"></a>Hive的数据模型和操作</h2><h1 id="Hive的数据导入到数据仓库"><a href="#Hive的数据导入到数据仓库" class="headerlink" title="Hive的数据导入到数据仓库"></a>Hive的数据导入到数据仓库</h1><h2 id="load语句执行数据导入"><a href="#load语句执行数据导入" class="headerlink" title="load语句执行数据导入"></a>load语句执行数据导入</h2><p><code>LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=vall, partcol2=val2)]</code></p>
<p>PARTITION当是分区表</p>
<p>load命令，Sqoop组件导入</p>
<p>数据查询 HQL语句</p>
<p>Hive的Java客户端和自定义函数</p>
<p>Hive的体系结构和基本操作</p>
<p>Java编程</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据之Hive的数据操作以及开发&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Hive是基于Hadoop的一个数据仓库工具，通过它可以实现将结构化的数据文件映射为一张数
    
    </summary>
    
      <category term="数据分析" scheme="http://microndgt.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Hive" scheme="http://microndgt.github.io/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串和文本</title>
    <link href="http://microndgt.github.io/2017/01/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC/"/>
    <id>http://microndgt.github.io/2017/01/19/Python字符串和文本/</id>
    <published>2017-01-19T00:40:59.000Z</published>
    <updated>2017-01-27T05:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>拆分字符串，搜索，替换，词法分析以及解析，正则表达式.</p>
<h1 id="针对任意多的分隔符拆分字符串"><a href="#针对任意多的分隔符拆分字符串" class="headerlink" title="针对任意多的分隔符拆分字符串"></a>针对任意多的分隔符拆分字符串</h1><p>普通字符串的split方法只能处理单个的分隔符，如果要处理多个分隔符，使用<code>re.split()</code>，返回结果仍然是列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line = &apos;asdf fjdk; afed, fjek,asdf&apos;</div><div class="line">import re</div><div class="line">re.split(r&apos;[;,\s]\s*&apos;, line&apos;)</div><div class="line"># \s表示空格，*表示匹配前方0次或者多次</div></pre></td></tr></table></figure>
<p>如果使用捕获组，匹配的文本也会包含在最终结果中，捕获组中加入或<code>|</code>符号</p>
<p><code>fields = re.split(r&#39;(;|,|\s)\s*&#39;, line&#39;)</code></p>
<p>或者使用非捕获组<code>?:</code></p>
<p><code>fields = re.split(r&#39;(?:;|,|\s)\s*&#39;, line&#39;)</code></p>
<h1 id="在字符串开头或者结尾处做文本匹配"><a href="#在字符串开头或者结尾处做文本匹配" class="headerlink" title="在字符串开头或者结尾处做文本匹配"></a>在字符串开头或者结尾处做文本匹配</h1><p>使用<code>str.startswith()</code>和<code>str.endswith()</code>，如果要对多个选项做检查，给这两个函数传入包含可能选项的元组。</p>
<p><code>[name for name in filenames if name.endswith((&#39;.h&#39;, &#39;.c&#39;))]</code></p>
<p>使用<code>any()</code>函数：</p>
<p><code>any(name.endswith(&#39;.py&#39;) for name in filenames)</code></p>
<p>这里是Python需要把元组当成输入的一个地方，如果选项指定在列表或者集合里，使用<code>tuple()</code>函数将其转换成元组</p>
<h1 id="文本模式的匹配和查找"><a href="#文本模式的匹配和查找" class="headerlink" title="文本模式的匹配和查找"></a>文本模式的匹配和查找</h1><p>使用re模块</p>
<p>可以将正则表达式首先预编译成一个模式对象<code>datepat = re.compile(r&#39;\d+/\d+/\d+&#39;)</code></p>
<p><code>\d</code>表示数字，<code>+</code>表示匹配一次或者多次，<code>*</code>表示匹配0次或者多次</p>
<p><code>re.match()</code>返回一个匹配对象，可以使用<code>groups()</code>方法，<code>m.group(0)</code>表示所有匹配对象，<code>m.group(1)</code>表示第一次匹配的对象</p>
<p><code>re.search()</code>和<code>match()</code>不同的是对整个文本进行匹配而不是从头开始匹配</p>
<p><code>re.findall()</code>返回一个列表，包含所有匹配成功的字符串</p>
<h1 id="查找和替换文本"><a href="#查找和替换文本" class="headerlink" title="查找和替换文本"></a>查找和替换文本</h1><p><code>str.replace(old, new)</code>进行字符串的替换</p>
<p>使用<code>re.sub()</code>，第一个参数是要匹配的模式，第二个参数是要替换上的模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">t = &apos; today is 11/27/2017. Pycon is 3/13/2013&apos;</div><div class="line">import re</div><div class="line">re.sub(r&apos;(\d+)/(\d+)/(\d+)&apos;, r&apos;\3-\1-\2&apos;, t)</div><div class="line"># 真正运行一遍才知道自己掌握了没，注意：使用r原始字符串，使用捕获组后面的\3才能使用</div></pre></td></tr></table></figure>
<p>可以预先编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">datepat = re.compile(r&apos;(\d+)/(\d+)/(\d+)&apos;)</div><div class="line">datapat.sub(r&apos;\3-\1-\2&apos;, t)</div></pre></td></tr></table></figure>
<p>完成多少次替换<code>re.subn()</code></p>
<p><code>newtext, n = datepat.subn(r&#39;\3-\1-\2&#39;, text)</code></p>
<h1 id="以不区分大小写的方式对文本做查找和替换"><a href="#以不区分大小写的方式对文本做查找和替换" class="headerlink" title="以不区分大小写的方式对文本做查找和替换"></a>以不区分大小写的方式对文本做查找和替换</h1><p>加上<code>re.IGNORECASE</code>标记</p>
<p><code>re.findall(&#39;python&#39;, text, flags=re.IGNORECASE)</code></p>
<p>可以使用一个支撑函数作为<code>sub()</code>中的要替换上的模式，返回一个替换后的字符串</p>
<h1 id="实现最短匹配的正则表达式"><a href="#实现最短匹配的正则表达式" class="headerlink" title="实现最短匹配的正则表达式"></a>实现最短匹配的正则表达式</h1><p><code>r&#39;\&quot;(.*)\&quot;&#39;</code>使用的是贪心策略，<code>r&#39;\&quot;(.*?)\&quot;&#39;</code>使用的是非贪心策略，另外<code>.</code>除了换行符可以匹配任意字符，可以使用<code>re.S</code>或者是<code>re.DOTALL</code>用来匹配换行符</p>
<p>另外一般遇到复杂情况都是自己书写正则表达式：<code>comment = re.compile(r&#39;/\*((?:.|\n)*?)\*/)</code>，其中指定了一个非捕获组，这个组只做匹配但是不捕获结果，也不会分配组号。</p>
<h1 id="将Unicode文本统一表示成规范形式"><a href="#将Unicode文本统一表示成规范形式" class="headerlink" title="将Unicode文本统一表示成规范形式"></a>将Unicode文本统一表示成规范形式</h1><p>对于任何需要确保以规范和一致性的方式处理Unicode文本的程序来说，规范化都是重要的一部分，在对文本进行过滤和净化的时候，规范化同样占据了重要的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import unicodedata</div><div class="line">t1 = unicodedata.normalize(&apos;NFD&apos;, s1)</div><div class="line">&apos;&apos;.join(c for c in t1 if not unicodedata.combining(c))</div></pre></td></tr></table></figure>
<p><code>combining()</code>函数对字符进行检查，判断它是否是一个组合型字符，若不是则返回0</p>
<p>NFC表示字符应该是全组成的，如果可能就使用单个代码点。NFD表示应该使用组合字符，每个字符应该是能完全分解开的。</p>
<h1 id="从字符串中去掉不需要的字符"><a href="#从字符串中去掉不需要的字符" class="headerlink" title="从字符串中去掉不需要的字符"></a>从字符串中去掉不需要的字符</h1><p>使用<code>strip()</code>方法，或者<code>lstrip()</code>，<code>rstrip()</code></p>
<p>如果要对里面的空格执行某些操作，应该使用其他技巧比如replace()方法或者正则表达式替换</p>
<p>经常遇到的情况是去除字符的操作和某些迭代操作结合起来，生成器表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">with open(filename) as f:</div><div class="line">    lines = (line.strip() for line in f)</div><div class="line">    for line in line:</div><div class="line">        ...</div></pre></td></tr></table></figure>
<h1 id="文本过滤与清理"><a href="#文本过滤与清理" class="headerlink" title="文本过滤与清理"></a>文本过滤与清理</h1><p>感觉非常好用啊，使用<code>str.translate()</code>方法，首先创建一个转换表格，然后使用这个方法对字符串进行转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ord函数返回ASC值</div><div class="line">remap = &#123;</div><div class="line">  ord(&apos;\t&apos;): &apos; &apos;,</div><div class="line">  ord(&apos;\f&apos;): &apos; &apos;,</div><div class="line">  ord(&apos;\r&apos;): None # 直接被删除</div><div class="line">&#125;</div><div class="line"># 调用translate方法</div><div class="line">a = s.translate(remap)</div></pre></td></tr></table></figure>
<p>删除所有的和音符，使用NFD可以将字符串分解成单个字符，标准化称为分解形式字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmb_chrs = dict.fromkeys(c for c in range(sys.maxunicode) if unicodedata.combining(chr(c)))</div><div class="line">b = unicodedata.normalize(&apos;NFD&apos;, a)</div><div class="line">b.translate(cmb_chrs)</div></pre></td></tr></table></figure>
<p>一般使用replace方法比较快，但是涉及任何复杂字符对字符的重新映射或者是删除操作的话，translate方法会比较快</p>
<h1 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h1><p>使用ljust(),rjust(),center()方法，并且可以接受一个可选的填充字符,<code>text.rjust(20, &#39;=&#39;)</code></p>
<p>format函数也可以用来对齐字符串<code>format(text, &#39;&gt;20&#39;)</code> 右对齐，或者指定一个非空格填充字符，<code>format(text, &#39;=&gt;20&#39;)</code></p>
<p>格式化多个值，<code>&#39;&#39;{:&gt;10s} {:&gt;10s}&#39;.format(&#39;hello&#39;, &#39;world&#39;)&#39;</code></p>
<p>可以格式化任何值，<code>x = 1.234</code>, <code>format(x, &#39;&gt;10&#39;)</code></p>
<p>优先选用format()函数或者方法</p>
<h1 id="合并拼接字符串"><a href="#合并拼接字符串" class="headerlink" title="合并拼接字符串"></a>合并拼接字符串</h1><p>如果要合并的字符串在一个序列中，最快的方式就是join()方法，如果是合并少数的几个字符串，使用加号就可以了。</p>
<p>如果只是将两个字面字符串合并起来，只需要简单的放在一起就OK, <code>a = &#39;Hello&#39; &#39;World&#39;</code></p>
<p>使用生成器表达式：<code>&#39;,&#39;.join(str(d) for d in data)</code></p>
<p>注意不必要的字符串连接操作：<code>print(a, b, c, sep=&quot;:&quot;)</code>，这样更加优雅</p>
<h1 id="内嵌变量的字符串"><a href="#内嵌变量的字符串" class="headerlink" title="内嵌变量的字符串"></a>内嵌变量的字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &apos;&#123;name&#125; has &#123;n&#125; message&apos;</div><div class="line">s.format(name=&quot;kevin&quot;, n=34)</div></pre></td></tr></table></figure>
<p>如果要被替换的变量能在变量域中找到，可以结合使用format_map()和vars(),vars()返回了一个字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name = &quot;kevin&quot;</div><div class="line">n = 5</div><div class="line">s.format_map(vars())</div></pre></td></tr></table></figure>
<p>vars()也适用于对象实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = Info(&apos;kevin&apos;, 30)</div><div class="line"># 其中Info类中含有相应的属性名字为name和n</div><div class="line">s.format_map(vars(a))</div></pre></td></tr></table></figure>
<p>定义一个含有<code>__missing__()</code>方法的字典对象这样就可以避免KeyError</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class safesub(dict):</div><div class="line">    # 定义如何处理缺失值</div><div class="line">    def __missing__(self, key):</div><div class="line">        return &apos;&#123;&apos; + key + &apos;&#125;&apos;</div><div class="line">s.format_map(safesub(vars()))</div><div class="line"># 这样即使不存在这个键也不会报错</div></pre></td></tr></table></figure>
<p>可以进一步封装成工具函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">def sub(text):</div><div class="line">    return text.format_map(safesub(sys._getframe(1).f_locals))</div></pre></td></tr></table></figure>
<p><code>sys._getframe(1)</code>返回调用者的栈帧，从中访问属性<code>f_locals</code>来获得局部变量，是一个复制调用函数本地变量的字典，对它的操作不回覆盖和改变调用者本地变量的值。</p>
<h1 id="文本分词"><a href="#文本分词" class="headerlink" title="文本分词"></a>文本分词</h1><p>有一个字符串，想从左到右将其解析为标记流</p>
<p>第一步是利用命名捕获组的正则表达式定义所有可能的标记，包括空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">NAME = r&apos;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&apos;</div><div class="line"># ?P&lt;TOKENNAME&gt;用于给一个模式命名</div><div class="line">NUM = r&apos;(?P&lt;NUM&gt;\d+)&apos;</div><div class="line">PLUS = r&apos;(?P&lt;PLUS&gt;\+)&apos;</div><div class="line">TIMES = r&apos;(?P&lt;TIMES&gt;\*)&apos;</div><div class="line">EQ = r&apos;(?P&lt;EQ&gt;=)&apos;</div><div class="line">WS = r&apos;(?P&lt;WS&gt;\s+)&apos;</div><div class="line">master_pat = re.compile(r&apos;|&apos;.join([NAME, NUM, PLUS, TIMES, EQ, WS]))</div></pre></td></tr></table></figure>
<p>第二步，使用scanner()方法，创建一个scanner对象，在这个对象上不断调用match()方法会一步步扫描目标文本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scanner = master_pat.scanner(&apos;foo = 42&apos;)</div><div class="line"># 重复之</div><div class="line">scanner.match().groups()</div></pre></td></tr></table></figure>
<p>要点在于必须确认使用正则表达式制定了所有输入中可能出现的文本序列。另外分词顺序也是有影响的，re模块会按照制定好的顺序去做匹配，因此另一个模式恰好是另一个更长模式的子字符串，需要确定长模式在前面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拆分字符串，搜索，替换，词法分析以及解析，正则表达式.&lt;/p&gt;
&lt;h1 id=&quot;针对任意多的分隔符拆分字符串&quot;&gt;&lt;a href=&quot;#针对任意多的分隔符拆分字符串&quot; class=&quot;headerlink&quot; title=&quot;针对任意多的分隔符拆分字符串&quot;&gt;&lt;/a&gt;针对任意多的分隔符
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构与算法</title>
    <link href="http://microndgt.github.io/2017/01/16/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://microndgt.github.io/2017/01/16/Python数据结构与算法/</id>
    <published>2017-01-16T13:18:44.000Z</published>
    <updated>2017-01-27T05:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python基本的数据结构与算法</p>
<h1 id="collections-deque的用法"><a href="#collections-deque的用法" class="headerlink" title="collections.deque的用法"></a>collections.deque的用法</h1><p>双端队列，可以用这个队列来保存有限的历史记录，形成一个简单的队列结构，如果不指定队列的大小，就会得到一个无界限的队列。</p>
<p>创建：<code>q = deque(maxlen=3)</code> 建立固定大小的队列</p>
<p>方法：append, appendleft, pop, popleft</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line"></div><div class="line">def search(lines, pattern, history=5):</div><div class="line">	previous_line = deque(maxlen=history)</div><div class="line">	count = 0</div><div class="line">	for li in lines:</div><div class="line">		if pattern in li:</div><div class="line">			yield li, previous_line</div><div class="line">		previous_line.append(li)</div><div class="line"></div><div class="line">with open(&quot;test.txt&quot;) as f:</div><div class="line">	for line, prevlines in search(f, &quot;python&quot;):</div><div class="line">		for pline in prevlines:</div><div class="line">			print(pline,end=&quot;&quot;)</div><div class="line">		print(line,end=&apos;&apos;)</div><div class="line">		print(&apos;-&apos; * 20)</div></pre></td></tr></table></figure>
<h1 id="heapq模块的用法"><a href="#heapq模块的用法" class="headerlink" title="heapq模块的用法"></a>heapq模块的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">start2 = time.time()</div><div class="line">for index, ele in enumerate(heapq.nsmallest(3, targetList)):</div><div class="line">	print(&quot;the %d st min value is %d&quot; % (index+1, ele))</div><div class="line">stop2 = time.time()</div></pre></td></tr></table></figure>
<p>如果查找的元素个数相对比较小，使用nlargest(), nsmallest()比较合适，如果查找唯一的话，使用min(), max()比较合适，如果N大小和集合大小相近，则先排序，sorted(items)[:N]</p>
<h1 id="用heapq模块实现优先级队列"><a href="#用heapq模块实现优先级队列" class="headerlink" title="用heapq模块实现优先级队列"></a>用heapq模块实现优先级队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">class PriorityQueue:</div><div class="line">	def __init__(self):</div><div class="line">		self._queue = []</div><div class="line">		self._index = 0</div><div class="line">	def push(self, item, priority):</div><div class="line">		# 元组比较大小,按照第一个元素来进行,如果优先级相同,按照插入顺序也就是</div><div class="line">		# 第二个元素决定顺序</div><div class="line">		heapq.heappush(self._queue, (-priority, self._index, item))</div><div class="line">		self._index += 1</div><div class="line">	def pop(self):</div><div class="line">		# 返回最小的元素，取出插入元组的最后一个项</div><div class="line">		return heapq.heappop(self._queue)[-1]</div><div class="line">class Item:</div><div class="line">	def __init__(self, name):</div><div class="line">		self.name = name</div><div class="line">	def __repr__(self):</div><div class="line">		return &apos;Item(&#123;&#125;)&apos;.format(self.name)</div><div class="line">q = PriorityQueue()</div><div class="line">q.push(Item(&apos;root&apos;), 5)</div><div class="line">q.push(Item(&apos;Elena&apos;), 3)</div><div class="line">q.push(Item(&apos;Kevin&apos;), 4)</div><div class="line">q.push(Item(&apos;group&apos;), 1)</div><div class="line">q.push(Item(&apos;other&apos;), 1)</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div><div class="line">print(q.pop())</div></pre></td></tr></table></figure>
<h1 id="使用defaultdict类实现一键多值字典"><a href="#使用defaultdict类实现一键多值字典" class="headerlink" title="使用defaultdict类实现一键多值字典"></a>使用defaultdict类实现一键多值字典</h1><p>一个键映射多个值，需要将多个值放到另外的容器里，如列表，集合。</p>
<p>使用collections中的defaultdict构造这样的字典，它会自动初始化每个key刚开始对应的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from collections import defaultdict</div><div class="line">d = defaultdict(list)</div><div class="line">d[&apos;a&apos;].append(1)</div><div class="line">d[&apos;a&apos;].append(2)</div><div class="line">d[&apos;b&apos;].append(4)</div><div class="line">for key, value in d.items():</div><div class="line">	print(key, &quot; and &quot;, value)</div><div class="line">d = defaultdict(set)</div><div class="line">d[&apos;a&apos;].add(1)</div><div class="line">d[&apos;a&apos;].add(3)</div><div class="line">d[&apos;b&apos;].add(4)</div><div class="line">for key, value in d.items():</div><div class="line">	print(key, &quot; and &quot;, value)</div></pre></td></tr></table></figure>
<p>defaultdict会自动为将要访问的键创建映射实体，另外一个是字典的setdefault方法</p>
<p><code>d.setdefault(&#39;a&#39;, []).append(1)</code></p>
<h1 id="使用zip将字典的键和值翻转过来"><a href="#使用zip将字典的键和值翻转过来" class="headerlink" title="使用zip将字典的键和值翻转过来"></a>使用zip将字典的键和值翻转过来</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">d = &#123;&#125;</div><div class="line">d[&apos;a&apos;] = 5</div><div class="line">d[&apos;b&apos;] = 3</div><div class="line">d[&apos;c&apos;] = 6</div><div class="line">d[&apos;d&apos;] = 2</div><div class="line"># 求最小值,返回的是一个只能访问一次的迭代器</div><div class="line">min_value = min(zip(d.values(), d.keys()))</div><div class="line">print(min_value)</div><div class="line"># sorted默认是按照第一个元素进行排序的</div><div class="line">d_sorted = sorted(zip(d.values(), d.keys()))</div><div class="line">print(d_sorted)</div><div class="line"># 要改变的话,指定key</div><div class="line">d_sorted_1 = sorted(d.items(), key=lambda x: x[1])</div><div class="line">print(d_sorted_1)</div></pre></td></tr></table></figure>
<h1 id="keys-和items-方法都支持集合操作"><a href="#keys-和items-方法都支持集合操作" class="headerlink" title="keys()和items()方法都支持集合操作"></a>keys()和items()方法都支持集合操作</h1><p>这两个方法返回了<code>keys-view</code>对象，其中暴露了键或者键值，但是values()方法不支持集合操作，因为value可能是重复的，不是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(d.keys() &amp; e.keys())</div><div class="line">print(d.keys() - e.keys())</div><div class="line">print(d.items() &amp; e.items())</div><div class="line">c = &#123;key: d[key] for key in d.keys() - &#123;&apos;z&apos;, &apos;b&apos;&#125;&#125;</div><div class="line">print(c)</div></pre></td></tr></table></figure>
<h1 id="从序列中去除重复元素"><a href="#从序列中去除重复元素" class="headerlink" title="从序列中去除重复元素"></a>从序列中去除重复元素</h1><p>如果一个对象是可哈希的，那么在它的生存期内必须是不可变的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def dedupe(items, key=None):</div><div class="line">	seen = set()</div><div class="line">	for item in items:</div><div class="line">		val = item if key is None else key(item)</div><div class="line">		if val not in seen:</div><div class="line">			yield item</div><div class="line">			seen.add(val)</div><div class="line">a = [ &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;, &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;]</div><div class="line"># 将值转换成元组,hashable</div><div class="line">print(list(dedupe(a, key=lambda d: (d[&apos;x&apos;], d[&apos;y&apos;]))))</div></pre></td></tr></table></figure>
<h1 id="寻找序列中出现次数最多的元素"><a href="#寻找序列中出现次数最多的元素" class="headerlink" title="寻找序列中出现次数最多的元素"></a>寻找序列中出现次数最多的元素</h1><p>使用collections里面的Counter类，可以给该对象提供任何可哈希的对象序列作为输入，是一个字典，在元素和它们出现的次数之间做了映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">word_counts = Counter(words)</div><div class="line">top_three = word_counts.most_common(3)</div><div class="line">print(top_three)</div><div class="line">record = &quot;32323432435435235326253435436546547643&quot;</div><div class="line">from collections import Counter</div><div class="line">record = list(record)</div><div class="line">counts = Counter(record)</div><div class="line">top_five = counts.most_common(5)</div><div class="line">print(top_five)</div><div class="line">print(counts[&apos;3&apos;])</div><div class="line">more = list(&quot;43542354&quot;)</div><div class="line">counts.update(more)</div><div class="line">print(counts[&apos;3&apos;])</div><div class="line"># Counter对象支持数学运算</div><div class="line">counts1 = Counter(more)</div><div class="line">print(counts + counts1)</div></pre></td></tr></table></figure>
<h1 id="使用itemgetter来对字典列表排序"><a href="#使用itemgetter来对字典列表排序" class="headerlink" title="使用itemgetter来对字典列表排序"></a>使用itemgetter来对字典列表排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">rows = [</div><div class="line">	&#123;&apos;fname&apos;: &apos;Brian&apos;, &apos;lname&apos;: &apos;Jones&apos;, &apos;uid&apos;: 1003&#125;,</div><div class="line">	&#123;&apos;fname&apos;: &apos;Kevin&apos;, &apos;lname&apos;: &apos;Du&apos;, &apos;uid&apos;: 1000&#125;</div><div class="line">]</div><div class="line">from operator import itemgetter</div><div class="line">＃ 类似一个方法，通过itemgetter的到rows的属性fname作为key，item表示项，和后面的attr属性有所区别，属性则用于类</div><div class="line">rows_by_fname = sorted(rows, key=itemgetter(&apos;fname&apos;))</div><div class="line">print(rows_by_fname)</div><div class="line">rows_by_lname = sorted(rows, key=itemgetter(&apos;lname&apos;))</div><div class="line">print(rows_by_lname)</div><div class="line">rows_by_nameid = sorted(rows, key=itemgetter(&apos;lname&apos;, &apos;uid&apos;))</div><div class="line">print(rows_by_nameid)</div><div class="line"># 也可以使用lambda表达式代替</div><div class="line">rows_by_fname = sorted(rows, key=lambda r: r[&apos;fname&apos;])</div><div class="line"># 但是使用itemgetter更快一些</div><div class="line">print(rows_by_fname)</div><div class="line"># 也适用于min和max函数</div></pre></td></tr></table></figure>
<h1 id="使用attrgetter来对类进行排序"><a href="#使用attrgetter来对类进行排序" class="headerlink" title="使用attrgetter来对类进行排序"></a>使用attrgetter来对类进行排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class User:</div><div class="line">	def __init__(self, user_id):</div><div class="line">		self.user_id = user_id</div><div class="line">	def __repr__(self):</div><div class="line">		return &apos;User(&#123;&#125;)&apos;.format(self.user_id)</div><div class="line"></div><div class="line">def sort_notcompare():</div><div class="line">	users = [User(23), User(3), User(99)]</div><div class="line">	print(users)</div><div class="line">	print(sorted(users, key=lambda a: a.user_id))</div><div class="line"></div><div class="line">from operator import attrgetter</div><div class="line">users = [User(23), User(3), User(99), User(43)]</div><div class="line">print(users)</div><div class="line">print(sorted(users, key=attrgetter(&apos;user_id&apos;)))</div><div class="line">sort_notcompare()</div></pre></td></tr></table></figure>
<h1 id="itertools的groupby函数对数据进行分组"><a href="#itertools的groupby函数对数据进行分组" class="headerlink" title="itertools的groupby函数对数据进行分组"></a>itertools的groupby函数对数据进行分组</h1><p>itertools.groupby()函数扫描整个序列并且查找连续相同的值的元素序列，每次迭代的时候返回一个值和一个迭代器对象，这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。但是必须根据指定的字段将数据排序，groupby函数仅仅检查连续的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">from itertools import groupby</div><div class="line">rows = [</div><div class="line">	&#123;&apos;date&apos;: &apos;01/01&apos;, &apos;item&apos;: 1&#125;,</div><div class="line">	&#123;&apos;date&apos;: &apos;02/01&apos;, &apos;item&apos;: 2&#125;,</div><div class="line">	&#123;&apos;date&apos;: &apos;01/01&apos;, &apos;item&apos;: 2&#125;</div><div class="line">]</div><div class="line"># 首先进行排序</div><div class="line"># 或者使用itemgetter, 用于字典</div><div class="line">rows.sort(key=itemgetter(&apos;date&apos;))</div><div class="line">print(rows)</div><div class="line">rows.sort(key=lambda x: x[&apos;item&apos;])</div><div class="line"># 返回值以及分组的组</div><div class="line">for date, item in groupby(rows, key=lambda x: x[&apos;item&apos;]):</div><div class="line">	print(date)</div><div class="line">	for i in item:</div><div class="line">		print(&quot; &quot;,i)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python基本的数据结构与算法&lt;/p&gt;
&lt;h1 id=&quot;collections-deque的用法&quot;&gt;&lt;a href=&quot;#collections-deque的用法&quot; class=&quot;headerlink&quot; title=&quot;collections.deque的用法&quot;&gt;&lt;/a&gt;co
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 部署</title>
    <link href="http://microndgt.github.io/2017/01/12/Effective-Python-%E9%83%A8%E7%BD%B2/"/>
    <id>http://microndgt.github.io/2017/01/12/Effective-Python-部署/</id>
    <published>2017-01-12T11:37:10.000Z</published>
    <updated>2017-01-27T05:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Effective Python 的最后部分。</p>
<h1 id="用适当的方式打破循环依赖关系"><a href="#用适当的方式打破循环依赖关系" class="headerlink" title="用适当的方式打破循环依赖关系"></a>用适当的方式打破循环依赖关系</h1><p>Python系统在执行import语句时的详细机制，引入模块时候，Python会按照深度优先的顺序执行下列操作</p>
<ol>
<li>在由sys.path所指定的路径中，搜寻待引入的模块</li>
<li>从模块中加载代码，并且保证这段代码能够正确编译</li>
<li>创建与该模块相对应的空对象</li>
<li>把这个空的模块对象，添加到sys.modules里面</li>
<li>运行模块对象中的代码，以定义其内容</li>
</ol>
<p>某些属性必须等Python系统把对应的代码执行完毕之后，才可以具有完整的定义，但是，包含该属性的模块，却只需要等Python系统执行完第四步，就可以用import语句引入并且添加到sys.modules</p>
<p>解决这个问题的最佳方案，就是重构代码，将要重复用到的数据结构定义出来，然后app与dialog模块都引入这个工具模块，这样以避免出现循环依赖关系。</p>
<p>三种解决办法：</p>
<ol>
<li>调整引入顺序</li>
<li><p>先引入，再配置，最后运行</p>
<p>只在模块中给出函数，类和常量的定义，而不要在引入的时候真正运行那些函数。在main模块中，分三个阶段来执行代码，首先引入所有的模块，然后配置他们，最后执行程序中的第一个动作。</p>
</li>
<li><p>动态引入</p>
<p>在函数或者方法内部使用import语句，程序会等到真正需要运行相关代码时候，才会触发模块的引入操作，所以称为动态引入。但是有可能重复引入，这样也不好。</p>
</li>
</ol>
<h1 id="用虚拟环境隔离项目，并重建其依赖关系"><a href="#用虚拟环境隔离项目，并重建其依赖关系" class="headerlink" title="用虚拟环境隔离项目，并重建其依赖关系"></a>用虚拟环境隔离项目，并重建其依赖关系</h1><p>使用pyvenv工具，提供了一套虚拟环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">which python</div><div class="line">python --version</div><div class="line"># 创建虚拟环境</div><div class="line">pyvenv /temp/myproject</div><div class="line">cd /tmp/myproject</div><div class="line">source bin/activate</div><div class="line">pip install pytz</div><div class="line">deactivate</div></pre></td></tr></table></figure>
<h2 id="重建项目的依赖关系"><a href="#重建项目的依赖关系" class="headerlink" title="重建项目的依赖关系"></a>重建项目的依赖关系</h2><p><code>pip freeze</code> 使用这个命令，生成<code>requirements.txt</code>将开发环境软件包的依赖关系，明确的保存到文件中。</p>
<p>然后<code>pip install -r /tmp/requirements.txt</code></p>
<h1 id="考虑使用模块级别的代码来配置不同的部署环境"><a href="#考虑使用模块级别的代码来配置不同的部署环境" class="headerlink" title="考虑使用模块级别的代码来配置不同的部署环境"></a>考虑使用模块级别的代码来配置不同的部署环境</h1><p>想让Python程序付诸使用，必须从开发环境部署到生产环境中，要将Python程序产品化，令其能够稳定的运行在实际环境中。</p>
<p>编写<code>__main__.py</code>文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Effective Python 的最后部分。&lt;/p&gt;
&lt;h1 id=&quot;用适当的方式打破循环依赖关系&quot;&gt;&lt;a href=&quot;#用适当的方式打破循环依赖关系&quot; class=&quot;headerlink&quot; title=&quot;用适当的方式打破循环依赖关系&quot;&gt;&lt;/a&gt;用适当的方式打破循环依赖关
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 并发与并行</title>
    <link href="http://microndgt.github.io/2017/01/11/Effective-Python-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
    <id>http://microndgt.github.io/2017/01/11/Effective-Python-并发与并行/</id>
    <published>2017-01-11T11:20:40.000Z</published>
    <updated>2017-01-27T05:23:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看书学习后对以前不懂的概念越发的清晰了.</p>
<p>并发是操作系统会在各程序之间迅速切换，使其都有机会运行在这一个处理器上，这种交错执行程序的方式，叫做并发。而并行是指，计算机是在同一时间做着不同的事情，多个核心的计算机，能够同时执行多个程序，使得这些程序能够在同一时刻向前推进。</p>
<h1 id="用subprocess管理子进程"><a href="#用subprocess管理子进程" class="headerlink" title="用subprocess管理子进程"></a>用subprocess管理子进程</h1><p>由Python所启动的多个子进程，是可以平行运作的。最简单的子进程管理模块就是subprocess模块</p>
<p>用Popen构造器来启动进程，然后使用communicate方法来读取子进程的输出信息，并等待其终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proc = subprocess.Popen([&apos;echo&apos;, &apos;Hello from the child!&apos;], stdout=subprocess.PIPE)</div><div class="line">out, err = proc.communicate()</div><div class="line">print(out.decode(&apos;utf-8&apos;))</div></pre></td></tr></table></figure>
<p>子进程会独立于父进程而运行，父进程就是Python解释器，把子进程从父进程中剥离，意味着父进程可以随意运行很多条平行的子进程。</p>
<p>并且也可以从Python程序向子进程中输送数据，然后获取子进程的输出信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">def run_openssl(data):</div><div class="line">    env = os.environ.copy()</div><div class="line">    env[&apos;passwd&apos;] = b&apos;\xe24U\n&apos;</div><div class="line">    proc = subprocess.Popen([&apos;openssl&apos;, &apos;enc&apos;, &apos;-des3&apos;, &apos;-pass&apos;, &apos;env:password&apos;],</div><div class="line">        env=env,</div><div class="line">        stdin=subprocess.PIPE</div><div class="line">        stdout=subprocess.PIPE)</div><div class="line">    proc.stdin.write(data)</div><div class="line">    proc.stdin.flush()</div><div class="line">    return proc</div><div class="line">procs = []</div><div class="line">for _ in range(3):</div><div class="line">    data = os.urandom(10)</div><div class="line">    proc = run_openssl(data)</div><div class="line">    procs.append(proc)</div><div class="line"># 这些子进程就可以平行的运作并且处理他们的输入信息</div><div class="line">for proc in procs:</div><div class="line">    out, err = proc.communicate()</div><div class="line">    print(out[-10:])</div></pre></td></tr></table></figure>
<h1 id="可以用线程来执行阻塞式I-O，但是不要用它做平行计算"><a href="#可以用线程来执行阻塞式I-O，但是不要用它做平行计算" class="headerlink" title="可以用线程来执行阻塞式I/O，但是不要用它做平行计算"></a>可以用线程来执行阻塞式I/O，但是不要用它做平行计算</h1><p>标准的Python实现叫做CPython，CPython分两步运行Python程序，首先，把文本形式的源代码解析并编译成字节码，然后用基于栈的解释器来运行这份字节码。执行Python程序时候，字节码解释器必须保持协调一致的状态，Python使用GIL全局解释器锁来确保这种协调性。</p>
<p>GIL防止CPython受到占先式多线程切换操作的干扰，是指某个线程可以通过打断另外一个线程的方式，来获取程序控制权。所以同一时刻，只有一条线程可以向前执行。</p>
<p>Python下的多线程有以下的好处，首先，多线程使得程序看上去好像能够在同一时间做许多事情。能够令Python程序自动以一种看似平行的方式，来执行这些函数。不过受到GIL限制，所以同一时刻实际上只能有一个线程得到执行。</p>
<p>另外一个好处是处理阻塞式I/O操作，可以借助线程，把Python程序与这些耗时的I/O操作隔离开。尽管受制于GIL，但是用多个Python线程来执行系统调用的时候，这些系统调用可以平行的执行，GIL虽然使得Python代码无法执行，但是它对系统调用却没有任何负面影响，由于Python线程在执行系统调用的时候回释放GIL，并且一直要等到执行完毕才会重新获取它，所以GIL是不会影响系统调用的。</p>
<h1 id="在线程中使用Lock来防止数据竞争"><a href="#在线程中使用Lock来防止数据竞争" class="headerlink" title="在线程中使用Lock来防止数据竞争"></a>在线程中使用Lock来防止数据竞争</h1><p>虽然同一时刻只有一个线程在运行，但是当这个线程正在操作某个数据结构的时候，其他线程可能会打断它，也就是说，Python解释器在执行两个连续的字节码时候，其他线程可能会在中途突然插进来。如果在多个线程中同时访问某个对象，那么中断现象就可能随时发生。一旦发生，就会破坏程序的状态，从而使相关的数据结构无法保持其一致性。</p>
<p>为了防止这种数据竞争，Lock类，也相当于互斥锁，就可以保护自己的数据结构不受破坏。同一时刻，只有一个线程能够获得这把锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class LockingCounter(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.lock = Lock()</div><div class="line">        self.count = 0</div><div class="line">    def increment(self, offset):</div><div class="line">        with self.lock:</div><div class="line">            self.count += offset</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看书学习后对以前不懂的概念越发的清晰了.&lt;/p&gt;
&lt;p&gt;并发是操作系统会在各程序之间迅速切换，使其都有机会运行在这一个处理器上，这种交错执行程序的方式，叫做并发。而并行是指，计算机是在同一时间做着不同的事情，多个核心的计算机，能够同时执行多个程序，使得这些程序能够在同一时刻
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python实用脚本系统管理</title>
    <link href="http://microndgt.github.io/2017/01/10/Python%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://microndgt.github.io/2017/01/10/Python实用脚本系统管理/</id>
    <published>2017-01-10T10:09:36.000Z</published>
    <updated>2017-01-27T05:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<p> 系统任务的自动化处理，解析命令行选项，操纵文件系统中的文件，获取有用的系统配置数据</p>
<h1 id="通过重定向，管道或者输入文件来作为脚本的输入"><a href="#通过重定向，管道或者输入文件来作为脚本的输入" class="headerlink" title=" 通过重定向，管道或者输入文件来作为脚本的输入"></a> 通过重定向，管道或者输入文件来作为脚本的输入</h1><p> 接受任意一种对用户来说最为方便的输入机制，从命令中产生输出给脚本，把文件重定向到脚本，或者是在命令行中传递一个或者一列文件名给脚本。</p>
<blockquote>
<p>是可以将需要传入部分文件的那个东西，只设置一个-p bool参数，然后为True的时候重定向有用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import fileinput</div><div class="line">with fileinput.input() as f_input:</div><div class="line">    for line in f_input:</div><div class="line">        print(line, end=&apos;&apos;)</div></pre></td></tr></table></figure>
<p>fileinput.input()创建并且返回一个FileInput类的实例，该实例可以用作上下文管理器使用</p>
<h1 id="终止程序并显示错误信息"><a href="#终止程序并显示错误信息" class="headerlink" title="终止程序并显示错误信息"></a>终止程序并显示错误信息</h1><p>发出一个SystemExit异常，提供错误信息作为参数</p>
<p><code>raise SystemExit(&#39;It failed&#39;)</code></p>
<h1 id="解析命令行选项"><a href="#解析命令行选项" class="headerlink" title="解析命令行选项"></a>解析命令行选项</h1><p>argparse模块解析命令行选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. parser = argparse.ArgumentParser()</div><div class="line">2. parser.add_argument()</div><div class="line">3. args = parser.parse_args()</div><div class="line">参数用法什么的参考文档</div></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="external">argparse模块使用指南</a></p>
<h1 id="执行外部命令并获取输出"><a href="#执行外部命令并获取输出" class="headerlink" title="执行外部命令并获取输出"></a>执行外部命令并获取输出</h1><p>执行一个外部命令并把输出保存为一个Python字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import subprocess</div><div class="line">out_bytes = subprocess.check_output([&apos;netstat&apos;, &apos;-a&apos;])</div></pre></td></tr></table></figure>
<p>输出结果以字节串形式返回，如果要以文本形式解读，可以再增加解码步骤</p>
<p><code>out_text = out_bytes.decode(&#39;utf-8&#39;)</code></p>
<p>该函数只会返回写入到标准输出中的结果，如果希望命令通过shell执行，可以将命令以简单的字符串形式提供并且指定参数shell=True</p>
<p><code>out_bytes = subprocess.check_output(&#39;grep python | wc &gt; output&#39;, shell=True)</code></p>
<p>如果需要实现自动向用户请求输入密码的任务，需要expect族的工具</p>
<h1 id="拷贝或者移动文件和目录"><a href="#拷贝或者移动文件和目录" class="headerlink" title="拷贝或者移动文件和目录"></a>拷贝或者移动文件和目录</h1><p>shutil模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import shutil</div><div class="line">shutil.copy(src, dst)</div><div class="line">shutil.copy2(src, dst) # preserve metadata</div><div class="line">shutil.copytree(src, dst)</div><div class="line">shutil.move(src, dst)</div></pre></td></tr></table></figure>
<p>当和文件名打交道的时候，尽量使用os.path模块获得最佳的移植性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">os.path.basename(path)</div><div class="line">os.path.dirname(path)</div><div class="line">os.path.split(filename)</div><div class="line">os.path.join(dir, filename)</div><div class="line">os.path.expanduser(path) # 把path中包含的&quot;~&quot;和&quot;~user&quot;转换成用户目录</div></pre></td></tr></table></figure>
<h1 id="创建和解包归档文件"><a href="#创建和解包归档文件" class="headerlink" title="创建和解包归档文件"></a>创建和解包归档文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import shutil</div><div class="line">shutil.unpack_archive(&apos;python.zip&apos;)</div><div class="line">shutil.make_archive(&apos;py33&apos;, &apos;zip&apos;, root_dir)</div></pre></td></tr></table></figure>
<h1 id="通过名称来查找文件"><a href="#通过名称来查找文件" class="headerlink" title="通过名称来查找文件"></a>通过名称来查找文件</h1><p>搜索文件可以使用<code>os.walk()</code>函数，将顶层目录提供给它即可，返回一个3元组，当前目录的相对路径，该目录包含的所有目录名的列表，以及该目录中所有文件名的列表</p>
<p>使用<code>os.path.join()</code>来组合路径的时候，使用<code>os.path.abspath()</code>和<code>os.path.normpath()</code>来修正路径成标准化形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import time</div><div class="line">def modified_within(top, seconds):</div><div class="line">    now = time.time()</div><div class="line">    for path, dirs, files in os.walk(top):</div><div class="line">        for name in files:</div><div class="line">            fullpath = os.path.join(path, name)</div><div class="line">            if os.path.exists(fullpath):</div><div class="line">                mtime = os.path.getmtime(fullpath)</div><div class="line">                if mtime &gt; (now - seconds):</div><div class="line">                    print(fullpath)</div></pre></td></tr></table></figure>
<h1 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h1><p>使用configparser模块来读取配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from configparser import ConfigParser</div><div class="line">cfg = ConfigParser()</div><div class="line">cfg.read(&apos;config.ini&apos;)</div><div class="line">cfg.sections()</div><div class="line">cfg.get(&apos;installation&apos;, &apos;library&apos;)</div><div class="line">cfg.getboolean(&apos;debug&apos;, &apos;log_errors&apos;)</div><div class="line">cfg.getint(&apos;server&apos;, &apos;port&apos;)</div><div class="line"># 写入</div><div class="line">cfg.set(&apos;server&apos;, &apos;port&apos;, &apos;9000&apos;)</div><div class="line">cfg.write(filename)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 系统任务的自动化处理，解析命令行选项，操纵文件系统中的文件，获取有用的系统配置数据&lt;/p&gt;
&lt;h1 id=&quot;通过重定向，管道或者输入文件来作为脚本的输入&quot;&gt;&lt;a href=&quot;#通过重定向，管道或者输入文件来作为脚本的输入&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
</feed>
