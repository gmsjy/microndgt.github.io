<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyRover</title>
  <subtitle>做我的仲夏夜之梦～</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://microndgt.github.io/"/>
  <updated>2017-03-14T15:55:28.000Z</updated>
  <id>http://microndgt.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端小白学习日记之HTML&amp;CSS</title>
    <link href="http://microndgt.github.io/2017/03/14/%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%E4%B9%8BHTML-CSS/"/>
    <id>http://microndgt.github.io/2017/03/14/前端小白学习日记之HTML-CSS/</id>
    <published>2017-03-14T15:25:36.000Z</published>
    <updated>2017-03-14T15:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>搞了后端这么久了，我觉得是时候冲出江湖啦！开始学习前端！</p>
<h2 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">        &lt;title&gt;制作我的第一个网页&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;h1&gt;Hello World&lt;/h1&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>学习web前端开发基础技术需要掌握：HTML、CSS、JavaScript语言</p>
<ol>
<li>HTML是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。</li>
<li>CSS样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。</li>
<li>JavaScript是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用JavaScript来实现的。</li>
</ol>
<h2 id="Html和CSS的关系"><a href="#Html和CSS的关系" class="headerlink" title="Html和CSS的关系"></a>Html和CSS的关系</h2><p>网页中每一个内容在浏览器中的显示，都要存放到各种标签中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">        &lt;title&gt;Html和CSS的关系&lt;/title&gt;</div><div class="line">        &lt;style type=&quot;text/css&quot;&gt;</div><div class="line">        h1&#123;</div><div class="line">            font-size: 12px;</div><div class="line">            color: #930;</div><div class="line">            text-align: center;</div><div class="line">        &#125;</div><div class="line">        &lt;/style&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;h1&gt;Hello World!&lt;/h1&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="Html文件基本结构"><a href="#Html文件基本结构" class="headerlink" title="Html文件基本结构"></a>Html文件基本结构</h2><ol>
<li><html></html>称为根标签，所有的网页标签都在<html></html>中。</li>
<li><head> 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有<title>、<script>、 <style>、<link>、 <meta>等标签，头部标签在下一小节中会有详细介绍。</li>
<li>在<body>和</body>标签之间的内容是网页的主要内容，如<h1>、<p>、<a>、<img>等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。</li>
</ol>
<h2 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h2><p>文档的头部描述了文档的各种属性和信息，包括文档的标题等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可以用在head部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;...&lt;/title&gt;</div><div class="line">    &lt;meta&gt;</div><div class="line">    &lt;link&gt;</div><div class="line">    &lt;style&gt;...&lt;/style&gt;</div><div class="line">    &lt;script&gt;...&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div></pre></td></tr></table></figure>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p><code>&lt;!--文字--&gt;</code></p>
<h2 id="标签语义化"><a href="#标签语义化" class="headerlink" title="标签语义化"></a>标签语义化</h2><p>语义化，说的通俗点就是：明白每个标签的用途（在什么情况下使用此标签合理）比如，网页上的文章的标题就可以用标题标签，网页上的各个栏目的栏目名称也可以使用标题标签。文章中内容的段落就得放在段落标签中，在文章中有想强调的文本，就可以使用 em 标签表示强调等等。</p>
<h2 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h2><p>在网页上要展示出来的页面内容一定要放在body标签中。</p>
<h2 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h2><p>如果想在网页上显示文章，这时就需要<p>标签了，把文章的段落放到<p>标签中。</p>
<p><p>标签的默认样式，段前段后都会有空白，如果不喜欢这个空白，可以用css样式来删除或改变它。</p>
<h2 id="hx标签"><a href="#hx标签" class="headerlink" title="hx标签"></a>hx标签</h2><p>使用<hx>标签来制作文章的标题。标题标签一共有6个，h1、h2、h3、h4、h5、h6分别为一级标题、二级标题、三级标题、四级标题、五级标题、六级标题。并且依据重要性递减。<h1>是最高的等级。</p>
<h2 id="em和strong标签"><a href="#em和strong标签" class="headerlink" title="em和strong标签"></a>em和strong标签</h2><p>如果想在一段话中特别强调某几个文字，这时候就可以用到<em>或<strong>标签。</p>
<p><em> 表示强调，<strong> 表示更强烈的强调。并且在浏览器中<em> 默认用斜体表示，<strong> 用粗体表示。</p>
<p><em>的内容在浏览中显示为斜体，<strong>显示为加粗。如果不喜欢这种样式，没有关系，以后可以使用css样式去改变它。那么HTML就是相当于给了一个简单的样式，而CSS可以自定义的去改变它。</p>
<h2 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h2><p><span>标签是没有语义的，它的作用就是为了设置单独的样式用的。看下面的例子就懂了，但是<code>color:blue;</code>之间是没有空格的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">&lt;title&gt;了不起的盖茨比&lt;/title&gt;</div><div class="line">&lt;style&gt;</div><div class="line">span&#123;</div><div class="line">    color:blue;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p&gt;1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。&lt;/p&gt;</div><div class="line">    &lt;p&gt;菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为&quot;爵士乐时代&quot;吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="q标签"><a href="#q标签" class="headerlink" title="q标签"></a>q标签</h2><p>短文本引用，浏览器会对q标签自动添加双引号，其实关键在于它的语义，引用别人的话。</p>
<h2 id="blockquote标签"><a href="#blockquote标签" class="headerlink" title="blockquote标签"></a>blockquote标签</h2><p>长文本引用，浏览器对<blockquote>标签的解析是缩进样式。</p>
<h2 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h2><p>分行显示文本，在需要加回车换行的地方加入<br />，<br />标签作用相当于word文档中的回车。<br />标签是一个空标签，没有HTML内容的标签就是空标签，空标签只需要写一个开始标签，这样的标签有<br />、<hr />和<img />。</p>
<p>在 html 中是忽略回车和空格的，你输入的再多回车和空格也是显示不出来的。所以必须使用<br/></p>
<h2 id="amp-nbsp-空格"><a href="#amp-nbsp-空格" class="headerlink" title="&amp;nbsp;空格"></a><code>&amp;nbsp;</code>空格</h2><p>输入空格，必须写入<code>&amp;nbsp;</code></p>
<h2 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签"></a>hr标签</h2><p>水平横线，<hr />标签和<br />标签一样也是一个空标签，所以只有一个开始标签，没有结束标签。</p>
</script></title></head></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞了后端这么久了，我觉得是时候冲出江湖啦！开始学习前端！&lt;/p&gt;
&lt;h2 id=&quot;第一段代码&quot;&gt;&lt;a href=&quot;#第一段代码&quot; class=&quot;headerlink&quot; title=&quot;第一段代码&quot;&gt;&lt;/a&gt;第一段代码&lt;/h2&gt;&lt;figure class=&quot;highlight 
    
    </summary>
    
      <category term="前端" scheme="http://microndgt.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="HTML" scheme="http://microndgt.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="http://microndgt.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>工作总结</title>
    <link href="http://microndgt.github.io/2017/03/10/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://microndgt.github.io/2017/03/10/工作总结/</id>
    <published>2017-03-10T09:10:18.000Z</published>
    <updated>2017-03-14T07:27:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><p>创建virtualenv时候遇到这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ virtualenv myblog_env --python=python3</div><div class="line">Running virtualenv with interpreter /Users/kevin/anaconda/bin/python3</div><div class="line">Using base prefix &apos;/Users/kevin/anaconda&apos;</div><div class="line">New python executable in /Users/kevin/myblog_env/bin/python3</div><div class="line">Not overwriting existing python script /Users/kevin/myblog_env/bin/python (you must use /Users/kevin/myblog_env/bin/python3)</div><div class="line">ERROR: The executable /Users/kevin/myblog_env/bin/python3 is not functioning</div><div class="line">ERROR: It thinks sys.prefix is &apos;/Users/kevin&apos; (should be &apos;/Users/kevin/myblog_env&apos;)</div><div class="line">ERROR: virtualenv is not compatible with this system or executable</div></pre></td></tr></table></figure>
<p>这个问题的原因是没有用系统级的Python，建立virtualenv的时候指定<code>-p</code>参数：<code>virtualenv -p python3 myblog_env</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;virtualenv&quot;&gt;&lt;a href=&quot;#virtualenv&quot; class=&quot;headerlink&quot; title=&quot;virtualenv&quot;&gt;&lt;/a&gt;virtualenv&lt;/h1&gt;&lt;p&gt;创建virtualenv时候遇到这个问题：&lt;/p&gt;
&lt;figure clas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-传输层</title>
    <link href="http://microndgt.github.io/2017/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://microndgt.github.io/2017/03/08/计算机网络-传输层/</id>
    <published>2017-03-08T03:06:16.000Z</published>
    <updated>2017-03-13T10:16:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="往返时延的估计与超时"><a href="#往返时延的估计与超时" class="headerlink" title="往返时延的估计与超时"></a>往返时延的估计与超时</h2><p>超时/重传机制来处理报文段的丢失问题，超时时间间隔必须大于TCP连接的往返时延RTT</p>
<p>报文段的样本RTT是从某报文段被发出，交给IP到对该报文段的确认被收到之间的时间量。仅为传输一次的报文段测量样本RTT。</p>
<p>TCP维持一个样本RTT的均值，EstimatedRTT，估计RTT，是一个由样本RTT值而得出的加权平均值。</p>
<p>要求将超时间隔设置为估计RTT加上一定余量。当DevRTT值比较大的时候，余量应该大一点。偏差DevRTT，是样本RTT和估计RTT之间差值的指数加权移动平均。</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p>IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。推荐的定时器管理过程仅使用单一的重传定时器。</p>
<p>TCP发送方有3个与发送和重传有关的主要事件：</p>
<ol>
<li>从上层应用程序接收数据。TCP接收数据后，将数据封装在一个报文段中，将报文段交给IP，每个报文段都有一个序号，是报文段第一个数据字节的字节流编号，如果定时器没有为其他报文段而运行，那么报文段传给IP时候，TCP启动定时器。</li>
<li>超时。TCP通过重传引起超时的报文段来响应超时事件，然后TCP重启定时器。</li>
<li>接收ACK报文。TCP将ACK的值y与变量sendbase比较，sendbase是最早未被确认的字节的序号，TCP采用累积确认，y确认了字节编号在y之前的所有字节都已经收到，如果y&gt;sendbase，该ACK是在确认一个或者多个先前未被确认的报文段。发送方更新其sendbase变量。如果当前有未被确认的报文段，那么TCP重启定时器。</li>
</ol>
<p>TCP重传具有最小序号的还未被确认的报文段。但是每次TCP重传都会将下一次的超时间隔设置为先前值的两倍，这种改动提供了一个有限形式的拥塞控制。定时器过期很有可能是由于网络拥塞引起的，在拥塞的时候，如果源持续重传分组，会使得拥塞更加严重，因此每个发送方的重传都是经过越来越长的时间间隔后进行的。</p>
<p>发送方可以在超时事件发生之前通过注意冗余ACK来较好的检测丢包情况。TCP接收方检测到数据流中的一个间隔，即有报文段丢失，因为TCP不使用否定确认，只需对按序接收到的最后一个字节数据进行重复确认，即产生一个冗余ACK,发送的冗余ACK，指明下一个期待字节的序号，就是间隔的低端字节序号。</p>
<p>如果TCP发送方接收到对相同数据的３个冗余ACK，就认为跟在这个已被确认过３次的报文段之后的报文段已经丢失。一旦收到３个冗余ACK，TCP就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<p>TCP发送方仅需要维持已经发送但是未被确认字节的最小序号和下一个要发送字节的序号。对TCP协议提出的一个修改就是所谓的选择确认，它允许TCP接受方有选择的确认失序报文段。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>有可能TCP连接的接收缓存溢出。TCP为应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。所以流量控制是一个速度匹配服务。TCP发送方可能因为IP网络的拥塞而被遏制，这种形式的发送方控制被成为拥塞控制。</p>
<p>TCP通过让发送方维护一个接收窗口的变量来提供流量控制，接收窗口用于告诉发送方，接收方还有多少可用的缓存空间。接收窗口是动态的，主机B通过把当前的接收窗口值放入它发给主机A的报文段接收窗口字段中，开始的时候接收窗口值大小和接收缓存大小一样。</p>
<p>有一个问题是，当缓存区满的时候，主机A会被阻塞不能再发数据，所以当主机B的接收窗口为0的时候，主机A继续发送一个字节数据的报文段，这些报文段将会被接收方确认，最后缓存开始清空的时候，确认报文里将包含一个非0的接收窗口值。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><ol>
<li>客户端TCP向服务器端的TCP发送一个特殊的TCP报文段。报文部首部SYN标志位设置为1，客户机随机选择一个起始序号，防止在该起始的TCP SYN报文段的序号字段中。该报文段封装在一个IP数据报，发送给服务器。</li>
<li>服务器提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量。并向客户TCP发送允许连接的报文段。首部SYN比特设置为1，TCP报文首部确认号字段设置为客户发来的报文＋1，服务器选择自己的初始序号。这个允许连接的报文段被称为SYNACK报文段。</li>
<li>收到SYNACK，客户机给该连接分配缓存和变量。客户机再向服务器发送另外一个报文段，报文段对服务器的允许连接的报文段进行确认。server_isn + 1,另外SYN比特置为0，因为连接已经建立了。</li>
</ol>
<p>在建立连接后，每一个报文段，SYN比特都置为0，这种连接建立的过程为三次握手。</p>
<p>关闭的时候，客户机TCP向服务器进程发送一个特殊的TCP报文段，首部的FIN比特被置为1，然后服务器接收到之后，向客户机回送一个确认报文段ACK，服务器发送终止报文段，FIN比特为1，最后客户机对这个服务器的终止报文段进行确认ACK。此时两台主机用于该连接的所有资源都被释放了。</p>
<p>客户机TCP状态，CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT</p>
<p>服务器TCP状态,CLOSED-&gt;LISTEN-&gt;SYN_RCVD-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK</p>
<p>向某台主机发送一个特殊的TCP SYN报文段后，会有以下情况：</p>
<ul>
<li>源主机从目标主机收到一个TCP SYNACK报文段，这说明主机上一个应用程序使用TCP端口运行</li>
<li>源主机从目标主机收到一个TCP RST报文段，意味着这个端口没有程序运行</li>
<li>源主机什么也没有得到，说明SYN报文段被中间的防火墙阻挡，不能到达目标主机。</li>
</ul>
<h2 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h2><p>攻击者发送大量的TCP SYN报文段，而不完成三次握手的第三步。通过多个源发送SYN可以加大攻击力度，产生DDos分布式拒绝服务SYN洪泛攻击。还有一种完全握手攻击。</p>
<h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><h2 id="拥塞原因与开销"><a href="#拥塞原因与开销" class="headerlink" title="拥塞原因与开销"></a>拥塞原因与开销</h2><p>分组到达一个已经满了的缓存时候会被丢弃，那么这个分组将会被重传。运输层向网络中发送报文段(含有初始数据或者重传数据)的速率称为对网络的供给载荷。因此这是另外一种网络拥塞开销，发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。还有一种网络拥塞的开销是，发送发在遇到大时延时后进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组拷贝。</p>
<p>由于拥塞而丢弃分组的另一种开销，当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</p>
<h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><ul>
<li>端到端拥塞控制，网络层没有为运输层拥塞控制提供显式支持，TCP通过端对端的方法处理拥塞控制。TCP报文段的丢失被认为是网络拥塞的迹象，TCP会相应减少窗口长度。TCP通过增加往返时延值作为网络拥塞程序增加的指示。</li>
<li>网络辅助的拥塞控制，网络层组件，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。拥塞信息从网络反馈到发送方通常有两种方式，一种是直接反馈信息，通常采用阻塞分组。另一种是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的发生，这个是经由接收方的网络反馈。</li>
</ul>
<h2 id="网络辅助的拥塞控制例子：ATM-ABR拥塞控制"><a href="#网络辅助的拥塞控制例子：ATM-ABR拥塞控制" class="headerlink" title="网络辅助的拥塞控制例子：ATM ABR拥塞控制"></a>网络辅助的拥塞控制例子：ATM ABR拥塞控制</h2><p>ATM采用面向虚电路方法处理分组交换问题，从源到目的地上的每台交换机将维护有关源到目的地VC的状态，允许交换机跟踪各个发送方的行为，采取源特定的拥塞控制动作。执行网络辅助拥塞控制。</p>
<p>ABR弹性数据传输服务。</p>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>TCP必须使用端到端拥塞控制而不是网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。</p>
<p>TCP拥塞控制机制让连接的每一端都记录一个额外的变量，即拥塞窗口，它对一个TCP发送方能向网络中发送流量的速率进行了限制，一个发送方中未被确认的数据量。所以也就是说允许发送方向该连接发送CongWin个字节的数据。</p>
<p>一个TCP发送方的丢包事件为，要么出现超时，要么收到接收方3个冗余的ACK。如果报文段确认到达，说明一切正常，使用确认来增加拥塞窗口的长度。TCP使用确认来触发它的拥塞窗口长度的增大，TCP是自计时的。</p>
<p>TCP发送方在感知拥塞时候，使用的调节发送速率使用的TCP拥塞控制算法。</p>
<ul>
<li>加性增，乘性减：出现丢包事件时候，让发送方降低发送速率，每次发生一次丢包事件就将其拥塞窗口值减半。如果没有检测到拥塞，则缓慢的增加其拥塞窗口的长度，探测端到端路径上额外的可用带宽。一个新的确认到达，拥塞窗口增加一个MSS/CongWin字节。</li>
<li>慢启动：拥塞窗口的值初始设为1个MSS，但是TCP发送方在初始阶段不是线性增加发送速率，而是指数速度增加。每过一个RTT将拥塞窗口翻倍，直到一个丢包事件，此时拥塞窗口降为一半。</li>
<li>对超时事件做出反应：超时事件发生时，TCP发送方进入一个慢启动阶段，同上。直到拥塞窗口到达超时事件前窗口值一半为止。然后拥塞窗口以线性速率增长。TCP通过维持一个阈值的变量来管理，阈值初始为很大的值，这个值就是超时事件前窗口值的一半。网络在显示它自己至少能交付一些报文段，即使其他报文段因拥塞而丢失了，这种在收到3个冗余ACK后取消慢启动阶段的行为称为快速恢复。分组的RTT越长，路由器中的拥塞越严重。</li>
<li>对TCP吞吐量的宏观描述：TCP发送数据速率是拥塞窗口和当前RTT的函数，</li>
<li>TCP的未来：高速TCP连接</li>
<li>公平性：较小RTT连接能够在链路空闲时候更快的抢到可用带宽，较快的打开拥塞窗口，比较大RTT连接有更高的吞吐量。目前一个研究是开发一种因特网拥塞控制机制，用于阻止UDP流量不断压制直至中断因特网吞吐量。也可以使用多条并行TCP连接来传送一个web页中的多个对象。</li>
</ul>
<p>运输层协议能够提供的服务经常受下面网络层协议服务模型的限制。在协议栈中任意一层都可以实现确认，定时器，重传以及序号，就可以向上层提供可靠数据传输。</p>
<p>数据报拥塞控制协议，DCCP，提供了低开销，面向报文，类似UDP的不可靠服务，但是具有拥塞控制。</p>
<p>流控制传输协议SCTP</p>
<p>TCP友好速率控制 TFRC 是一种拥塞控制协议而不是一种功能齐全的运输层协议。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;往返时延的估计与超时&quot;&gt;&lt;a href=&quot;#往返时延的估计与超时&quot; class=&quot;headerlink&quot; title=&quot;往返时延的估计与超时&quot;&gt;&lt;/a&gt;往返时延的估计与超时&lt;/h2&gt;&lt;p&gt;超时/重传机制来处理报文段的丢失问题，超时时间间隔必须大于TCP连接的往返时
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Designing a RESTful API With Python and Flask</title>
    <link href="http://microndgt.github.io/2017/03/06/Designing-a-RESTful-API-with-Python-and-Flask/"/>
    <id>http://microndgt.github.io/2017/03/06/Designing-a-RESTful-API-with-Python-and-Flask/</id>
    <published>2017-03-06T04:01:55.000Z</published>
    <updated>2017-03-14T07:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask" target="_blank" rel="external">https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask</a></p>
<p>最近几年REST(表现层状态转移)已经成为了设计web服务和web APIs的标准框架。</p>
<p>在这篇文章里我将向你展示使用Python和Flask微框架创建一个RESTful web服务器是多么的简单。</p>
<h1 id="What-is-REST"><a href="#What-is-REST" class="headerlink" title="What is REST?"></a>What is REST?</h1><p>REST系统的特征可以通过以下6种设计原则定义：</p>
<ul>
<li>Client-Server: 服务器和客户端应该分离，服务器提供服务，客户端消费之</li>
<li>Stateless: 客户端发出的每一个请求必须包涵服务器所需要的所有信息。也就是说，服务器不能存储客户端在一个请求中携带的信息去处理其他请求。</li>
<li>Cacheable: 服务器必须指示客户端请求是否可以被缓存</li>
<li>Layered System: 客户端和服务器的通信必须以允许中间件响应请求而不是后端服务器的方式来标准化，客户端无需改变</li>
<li>Uniform Interface: 客户端和服务器的通信必须标准化</li>
<li>Code on demand: 服务器可以提供客户端可以在其上下文运行的代码或者脚本，这一个是唯一可选的限制。</li>
</ul>
<h1 id="What-is-a-RESTful-web-service"><a href="#What-is-a-RESTful-web-service" class="headerlink" title="What is a RESTful web service?"></a>What is a RESTful web service?</h1><p>REST框架最初是为了适应www使用的HTTP协议</p>
<p>RESTful web服务的中心概念是资源。资源通过URIs来表示。客户端发送由HTTP协议定义的请求到这些URIs，接下来这些被请求的资源状态会发生变化。</p>
<p>HTTP请求方法以标准的方式设计来影响一个给定的资源</p>
<table>
<thead>
<tr>
<th>HTTP Methods</th>
<th style="text-align:center">Action</th>
<th style="text-align:right">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:center">获取资源信息</td>
<td style="text-align:right"><a href="http://example.com/api/orders" target="_blank" rel="external">http://example.com/api/orders</a></td>
</tr>
<tr>
<td>GET</td>
<td style="text-align:center">获取资源信息</td>
<td style="text-align:right"><a href="http://example.com/api/orders/123" target="_blank" rel="external">http://example.com/api/orders/123</a></td>
</tr>
<tr>
<td>POST</td>
<td style="text-align:center">创建一个新资源</td>
<td style="text-align:right"><a href="http://example.com/api/orders(create" target="_blank" rel="external">http://example.com/api/orders(create</a> a new order, from data provided with the request)</td>
</tr>
<tr>
<td>PUT</td>
<td style="text-align:center">更新一个资源</td>
<td style="text-align:right"><a href="http://example.com/api/orders/123(update" target="_blank" rel="external">http://example.com/api/orders/123(update</a> order #123, from data provided with the request)</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align:center">删除一个资源</td>
<td style="text-align:right"><a href="http://example.com/api/orders/123(delete" target="_blank" rel="external">http://example.com/api/orders/123(delete</a> order #123)</td>
</tr>
</tbody>
</table>
<p>REST设计不需要请求提供特定的数据格式，事实上数据是通过在request体的JSON数据包，或者有些时候是在URL的查询部分作为参数传递的。</p>
<h1 id="Designing-a-simple-web-service"><a href="#Designing-a-simple-web-service" class="headerlink" title="Designing a simple web service"></a>Designing a simple web service</h1><p>设计一个符合REST风格的web服务或者API的任务现在变成了确定被暴露出的资源以及他们如何被不同的请求方法改变。</p>
<p>我们现在想写一个To Do应用，我们要设计一个web服务。第一件事情就是决定进入这个服务的根URL。例如，我们可以这样暴露这个服务</p>
<p><code>http://[hostname]/todo/api/v1.0/</code></p>
<p>这里我决定在URL包含应用的名字和API的版本。在URL中包含应用名字是很有用的，特别是在相同系统上运行有其他应用，这样就可以提供一个命名空间将其分开。在URL包含版本号有助于以后升级，因为新的或者潜在的不相容的函数可能在新版本中添加，这样就不会影响依赖旧函数的应用。</p>
<p>下一步是选择服务要暴露的资源。这是一个很简单的应用，我们只有task，所以我们唯一在我们todo列表中的资源是tasks.</p>
<p>我们的tasks资源将会使用如下的HTTP方法。</p>
<table>
<thead>
<tr>
<th>HTTP Methods</th>
<th style="text-align:center">URI</th>
<th style="text-align:right">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:center"><a href="http://[hostname]/todo/api/v1.0/tasks" target="_blank" rel="external">http://[hostname]/todo/api/v1.0/tasks</a></td>
<td style="text-align:right">Retrieve list of tasks</td>
</tr>
<tr>
<td>GET</td>
<td style="text-align:center"><a href="http://[hostname]/todo/api/v1.0/tasks/[task_id" target="_blank" rel="external">http://[hostname]/todo/api/v1.0/tasks/[task_id</a>]</td>
<td style="text-align:right">Retrieve a task</td>
</tr>
<tr>
<td>POST</td>
<td style="text-align:center"><a href="http://[hostname]/todo/api/v1.0/tasks" target="_blank" rel="external">http://[hostname]/todo/api/v1.0/tasks</a></td>
<td style="text-align:right">Create a new task</td>
</tr>
<tr>
<td>PUT</td>
<td style="text-align:center"><a href="http://[hostname]/todo/api/v1.0/tasks/[task_id" target="_blank" rel="external">http://[hostname]/todo/api/v1.0/tasks/[task_id</a>]</td>
<td style="text-align:right">Update an existing task</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align:center"><a href="http://[hostname]/todo/api/v1.0/tasks/[task_id" target="_blank" rel="external">http://[hostname]/todo/api/v1.0/tasks/[task_id</a>]</td>
<td style="text-align:right">Delete a task</td>
</tr>
</tbody>
</table>
<p>我们可以定义一个task有以下字段，<strong><em>自己的应用的task也应该这么设计，然后就可以有一个计算的历史记录功能了，计算完成不用删除这条记录，而是将其done字段设为True，然后每次载入的时候检索哪些done是False进行运行。另外API也应该设置为应用名加上版本号，这个是以后要加上的功能</em></strong></p>
<ul>
<li>id: 标识符，数字类型</li>
<li>title: 简短的任务描述，字符串类型</li>
<li>description: 长的任务描述，文本类型</li>
<li>done: 任务完成状态，布尔类型</li>
</ul>
<p>现在我们基本已经完成了web服务的设计部分，剩下的就是应用！</p>
<h1 id="A-brief-introduction-to-the-Flask-microframework"><a href="#A-brief-introduction-to-the-Flask-microframework" class="headerlink" title="A brief introduction to the Flask microframework"></a>A brief introduction to the Flask microframework</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://bl
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="RESTful" scheme="http://microndgt.github.io/tags/RESTful/"/>
    
      <category term="英文" scheme="http://microndgt.github.io/tags/%E8%8B%B1%E6%96%87/"/>
    
      <category term="翻译" scheme="http://microndgt.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Using Celery With Flask</title>
    <link href="http://microndgt.github.io/2017/03/01/Using-Celery-With-Flask/"/>
    <id>http://microndgt.github.io/2017/03/01/Using-Celery-With-Flask/</id>
    <published>2017-03-01T08:59:01.000Z</published>
    <updated>2017-03-09T03:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://blog.miguelgrinberg.com/post/using-celery-with-flask" target="_blank" rel="external">https://blog.miguelgrinberg.com/post/using-celery-with-flask</a></p>
<p><a href="http://www.cnblogs.com/jay54520/p/6212623.html" target="_blank" rel="external">http://www.cnblogs.com/jay54520/p/6212623.html</a></p>
<p>终于得到自己web程序要进行计算密集型的解决办法了，所以将此文翻译留作后用，也方便有需要的人。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Working-with-Flask-and-Celery"><a href="#Working-with-Flask-and-Celery" class="headerlink" title="Working with Flask and Celery"></a>Working with Flask and Celery</h2><p>Celery和Flask的整合是非常容易的，没有其他需要的扩展包。一个使用Celery的Flask应用需要这样初始化Celery客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from celery import Celery</div><div class="line">app = Flask(__name__)</div><div class="line">app.config[&apos;CELERY_BROKER_URL&apos;] = &apos;redis://localhost:6379/0&apos;</div><div class="line">app.config[&apos;CELERY_RESULT_BACKEND&apos;] = ‘redis://localhost:6379/0’</div><div class="line">celery = Celery(app.name, broker=app.config[&apos;CELERY_BROKER_URL&apos;])</div><div class="line">celery.conf.update(app.config)</div></pre></td></tr></table></figure>
<p>正如所看到的，Celery是通过创建Celery的实例初始化的，传递了应用的名称和连接URL作为消息代理，将<code>CELERY_BROKER_URL</code>作为键放入<code>app.config</code>字典。这个URL告诉代理服务在哪里运行。如果你运行的不是Redis，或者有在不同的机器上的代理，那么你需要相应的改变这个URL。</p>
<p>另外的可选配置选项可以直接从Flask的配置通过<code>celery.conf.update()</code>传递，<code>CELERY_RESULT_BACKEND</code>只有你需要存储任务状态和结果值的时候才是必须的。第一个例子不需要这个功能，但是第二个需要，所以最好从一开始配置好。</p>
<p>任何你想作为后台任务的函数都需要使用<code>celery.task</code>装饰器装饰，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@celery.task</div><div class="line">def my_background_task(arg1, arg2):</div><div class="line">    return result</div></pre></td></tr></table></figure>
<p>然后Flask应用就可以像如下请求后台任务的运行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">task = my_background_task.delay(10, 20)</div></pre></td></tr></table></figure>
<p><code>delay()</code>方法是更加强大的<code>apply_async()</code>调用的一个缩略，这里是一个同等的调用使用<code>apply_async()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">task = my_background_task.apply_async(args=[10, 20])</div></pre></td></tr></table></figure>
<p>当使用<code>apply_async()</code>，你可以给Celery关于后台任务如何被运行更加详细的指示，一个有用的选项是请求任务在将来的某个时候运行。例如，下面的语句将会使任务在大约1分钟后运行</p>
<p><code>task = my_background_task.apply_async(args=[10, 20], countdown=60)</code></p>
<p><code>delay()</code>和<code>apply_async()</code>的返回值都是一个代表任务的对象，这个对象被用来获取状态。我将在稍后的文章里展示如何完成的，但是现在<code>keep it simple</code>并且不要关心这些任务的结果。</p>
<h2 id="Simple-Example-Sending-Asynchronous-Emails"><a href="#Simple-Example-Sending-Asynchronous-Emails" class="headerlink" title="Simple Example: Sending Asynchronous Emails"></a>Simple Example: Sending Asynchronous Emails</h2><p>第一个例子将要展示的是一个非常普通的应用需求：不阻塞主应用去发送电子邮件。</p>
<p>作为示例我将使用<code>Flask-Mail</code>扩展，我已经在其他文章中详细的介绍了。我将假定你对这这个扩展很熟悉，因此如果你需要复习一下请看我的Flask book或者这篇介绍。</p>
<p>这个我将用于展示的示例应用包含有只有一个输入的简单web表单。用户被要求输入email地址在这个区域，然后提交，服务器将会向该地址发送一封email。表单含有两个提交按钮，一个是立即发送email，另外一个是等待一分钟后发送。截图最上面的部分展示了这个表单的样子。</p>
<p>这里是支持这个例子的HTML模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;Flask + Celery Examples&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h1&gt;Flask + Celery Examples&lt;/h1&gt;</div><div class="line">    &lt;h2&gt;Example 1: Send Asynchronous Email&lt;/h2&gt;</div><div class="line">    &#123;% for message in get_flashed_messages() %&#125;</div><div class="line">    &lt;p style=&quot;color: red;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">    &#123;% endfor %&#125;</div><div class="line">    &lt;form method=&quot;POST&quot;&gt;</div><div class="line">      &lt;p&gt;Send test email to: &lt;input type=&quot;text&quot; name=&quot;email&quot; value=&quot;&#123;&#123; email &#125;&#125;&quot;&gt;&lt;/p&gt;</div><div class="line">      &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Send&quot;&gt;</div><div class="line">      &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Send in 1 minute&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>希望你没有觉得惊讶，只是常规的HTML表单，加上可以从Flask闪现消息的能力。</p>
<p>Flask-Mail扩展需要一些配置，特别是当发送email的时候使用的邮件服务器，我使用Gmail账户作为email服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Flask-Mail configuration</div><div class="line">app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.googlemail.com&apos;</div><div class="line">app.config[&apos;MAIL_PORT&apos;] = 587</div><div class="line">app.config[&apos;MAIL_USE_TLS&apos;] = True</div><div class="line">app.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)</div><div class="line">app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;)</div><div class="line">app.config[&apos;MAIL_DEFAULT_SENDER&apos;] = &apos;flask@example.com&apos;</div></pre></td></tr></table></figure>
<p>现在为了防止我的email账户处于风险中，我将它们设置成环境变量，然后导入到应用中。</p>
<p>这是一个支持这个例子的简单路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/&apos;, methods=[’GET&apos;, &apos;POST&apos;])</div><div class="line">def index():</div><div class="line">    if request.method == &apos;GET&apos;:</div><div class="line">        return render_template(&apos;index.html&apos;, email=session.get(&apos;email&apos;, &apos;&apos;))</div><div class="line">    email = request.form[&apos;email&apos;]</div><div class="line">    session[&apos;email&apos;] = email</div><div class="line">    msg = Message(&apos;Hello from flask&apos;, recipients=[request.form[&apos;email&apos;]])</div><div class="line">    msg.body = &apos;This is a test email sent from a background celery task&apos;</div><div class="line">    if request.form[&apos;submit&apos;] == &apos;Send&apos;:</div><div class="line">        send_async_email.delay(msg)</div><div class="line">        flash(&apos;Sending email to &#123;0&#125;&apos;.format(email))</div><div class="line">    else:</div><div class="line">        # 使用了两种不同的调用方法</div><div class="line">        send_async_email.apply_async(args=[msg], countdown=60)</div><div class="line">    return redirect(url_for(&apos;index&apos;))</div></pre></td></tr></table></figure>
<p>同样的，这是一个标准的Flask，因为只是一个非常简单的表单，所以我没有使用任何扩展，我使用了<code>request.method</code>和<code>request.form</code>来做所有的管理。我在<code>session</code>中保存了用户在文本输入区输入的值，这样我就可以在页面重新载入之后记住它。</p>
<p>有意思的一点是发送email，它是被一个<code>Celery</code>任务叫<code>send_async_email</code>处理的， 通过<code>delay()</code>或者<code>apply_async()</code>来激发的</p>
<p>应用最后一部分是让任务完成的异步任务函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@celery.task</div><div class="line">def send_async_email(msg):</div><div class="line">    with app.app_context():</div><div class="line">        mail.send(msg)</div></pre></td></tr></table></figure>
<p>这个函数被<code>celery.task</code>装饰器装饰，变成了后台任务。这个函数值得关注的是<code>Flask-Mail</code>需要应用上下文才能运行，所以在<code>send()</code>方法被调用之前首先应该获取应用上下文。</p>
<p>应该注意的是在这个异步调用中返回的值没有被保存，所以应用不会知道调用是否成功。当运行这个例子的时候，应该在发送邮件时候出现问题去查看Celery工作者的输出。</p>
<h2 id="Complex-Example-Showing-Status-Updates-and-Results"><a href="#Complex-Example-Showing-Status-Updates-and-Results" class="headerlink" title="Complex Example: Showing Status Updates and Results"></a>Complex Example: Showing Status Updates and Results</h2><p>上面的例子很简单，后台任务启动后，应用就不用管了。大多数的Celery的web开发指南就到这里结束了，但是事实上对很多应用来说，管理后台任务和获取结果是很必要的。</p>
<p>我现在要做的是扩展上面的应用，这个例子展示了一个长时间运行的任务。用户可以通过点击按钮来启动一个或者多个任务，浏览器上的web页面通过ajax来获取这些任务的状态更新。对于每一个任务页面将会有一个状态条，完成的百分比和一个状态信息，当任务完成后，结果值也将会显示。</p>
<h2 id="Background-Tasks-with-Status-Updates"><a href="#Background-Tasks-with-Status-Updates" class="headerlink" title="Background Tasks with Status Updates"></a>Background Tasks with Status Updates</h2><p>第二个例子中使用的后台任务，这里就相当于计算任务，然后结束的时候返回状态，使用<code>update_state</code>来更新状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@celery.task(bind=True)</div><div class="line">def long_task(self):</div><div class="line">    &quot;&quot;&quot;Background task that runs a long function with progress reports.&quot;&quot;&quot;</div><div class="line">    verb = [&apos;Starting up&apos;, &apos;Booting&apos;, &apos;Repairing&apos;, &apos;Loading&apos;, &apos;Checking&apos;]</div><div class="line">    adjective = [&apos;master&apos;, &apos;radiant&apos;, &apos;silent&apos;, &apos;harmonic&apos;, &apos;fast&apos;]</div><div class="line">    noun = [&apos;solar array&apos;, &apos;particle reshaper&apos;, &apos;cosmic ray&apos;, &apos;orbiter&apos;, &apos;bit&apos;]</div><div class="line">    message = &apos;&apos;</div><div class="line">    total = random.randint(10, 50)</div><div class="line">    for i in range(total):</div><div class="line">        if not message or random.random() &lt; 0.25:</div><div class="line">            message = &apos;&#123;0&#125; &#123;1&#125; &#123;2&#125;...&apos;.format(random.choice(verb),</div><div class="line">                                              random.choice(adjective),</div><div class="line">                                              random.choice(noun))</div><div class="line">        self.update_state(state=&apos;PROGRESS&apos;,</div><div class="line">                          meta=&#123;&apos;current&apos;: i, &apos;total&apos;: total,</div><div class="line">                                &apos;status&apos;: message&#125;)</div><div class="line">        time.sleep(1)</div><div class="line">    return &#123;&apos;current&apos;: 100, &apos;total&apos;: 100, &apos;status&apos;: &apos;Task completed!&apos;,</div><div class="line">            &apos;result&apos;: 42&#125;</div></pre></td></tr></table></figure>
<p>这个任务中我在Celery装饰器中添加了<code>bind=True</code>参数，用来传递一个<code>self</code>参数给这个函数，这样可以用来记录状态的更新。</p>
<p>既然这个任务没有做任何有用的事，我决定使用一些动词，形容词和名字的集合来创建一个有趣的状态消息。你可以在上面看到我所用到的词语。没有什么错但是有趣是吧？</p>
<p>函数有一个10到50的随机数字的循环，每一次运行任务都会有不同的时间。在第一次迭代的时候会创建一个不同的状态消息，在随后的循环中有25%的可能性改变这个消息。</p>
<p><code>self.update_state()</code>调用使得Celery接受这些任务更新。那里有好几个内置状态，比如<code>STARTED</code>, <code>SUCCESS</code>等等，但是Celery也允许自定义状态。这里我用到了自定义状态<code>PROGRESS</code>。这个状态附带了一个附加的元数据，以Python字典的形式包含了当前和总的迭代数，还有一个随机的状态消息。客户端可以使用这些元素来形成一个进度条。每一次迭代休眠一秒，模拟一些完成的工作。</p>
<p>当循环退出的时候，Python字典作为函数返回值返回。字典包涵了更新的迭代计数，最终的状态信息和有趣的结果。</p>
<p><code>long_task()</code>函数在一个Celery工作者中处理，下面是Flask应用的路由来启动后台任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/longtask&apos;, methods=[&apos;POST&apos;])</div><div class="line">def longtask():</div><div class="line">    task = long_task.apply_async()</div><div class="line">    return jsonify(&#123;&#125;), 202, &#123;&apos;Location&apos;: url_for(&apos;taskstatus&apos;, task_id=task.id)&#125;</div></pre></td></tr></table></figure>
<p>客户端需要向<code>/longtask</code>提交一个POST请求来开始一个任务，服务器开始任务并且存储返回值。响应状态值用的是202，通常用在REST APIs来标志一个请求正在被处理。我也加上了<code>Location</code>头，里面的URL用户可以用来获取状态信息。这个URL指向了Flask路由taskstatus，使用<code>task.id</code>作为动态参数</p>
<h2 id="Accessing-Task-Status-from-the-Flask-Application"><a href="#Accessing-Task-Status-from-the-Flask-Application" class="headerlink" title="Accessing Task Status from the Flask Application"></a>Accessing Task Status from the Flask Application</h2><p><code>taskstatus</code>路由负责报告由后台任务提供的状态更新，这是这个路由的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/status/&lt;task_id&gt;&apos;)</div><div class="line">def taskstatus(task_id):</div><div class="line">    task = long_task.AsyncResult(task_id)</div><div class="line">    if task.state == &apos;PENDING&apos;:</div><div class="line">        response = &#123;</div><div class="line">            &apos;state&apos;: task.state,</div><div class="line">            &apos;current&apos;: 0,</div><div class="line">            &apos;total&apos;: 1,</div><div class="line">            &apos;status&apos;: &apos;Pending...&apos;</div><div class="line">        &#125;</div><div class="line">    elif taks.state != &apos;FAILURE&apos;:</div><div class="line">        response = &#123;</div><div class="line">          &apos;state&apos;: task.state,</div><div class="line">          &apos;current&apos;: task.info.get(&apos;current&apos;, 0),</div><div class="line">          &apos;total&apos;: task.info.get(&apos;total&apos;, 1),</div><div class="line">          &apos;status&apos;: task.info.get(&apos;status&apos;, &apos;&apos;)</div><div class="line">      &#125;</div><div class="line">        if &apos;result&apos; in task.info:</div><div class="line">            response[&apos;result&apos;] = task.info[&apos;result&apos;]</div><div class="line">    else:</div><div class="line">      # something went wrong in the background job</div><div class="line">      response = &#123;</div><div class="line">          &apos;state&apos;: task.state,</div><div class="line">          &apos;current&apos;: 1,</div><div class="line">          &apos;total&apos;: 1,</div><div class="line">          &apos;status&apos;: str(task.info),  # this is the exception raised</div><div class="line">      &#125;</div><div class="line">return jsonify(response)</div></pre></td></tr></table></figure>
<p>路由生成了一个JSON响应，包涵了任务状态和所有我在<code>update_state()</code>中meta设置的值，这样客户端就可以用这个来创建一个进度条了。不幸的是，运行函数需要检查一些边界条件，因此它会运行一段时间。为了取得任务数据，我重新创建了任务对象，它是<code>AsyncResult</code>类的对象，使用在URL中传递的<code>task id</code></p>
<h1 id="防坑指南"><a href="#防坑指南" class="headerlink" title="防坑指南"></a>防坑指南</h1><p>以上内容是原文的主要内容，下面我要写一下自己在使用Celery中出现的问题和解决方法。我使用的是redis做为broker和backend，代码如下：</p>
<p><code>celery = Celery(&#39;backend&#39;, broker=&#39;redis://%s:%d/%d&#39; % (REDISHOST, REDISPORT, REDISDB),backend=&#39;redis://%s:%d/%d&#39; % (REDISHOST, REDISPORT, REDISDB))</code></p>
<p>这句话在<code>celery.py</code>文件里，该文件在应用目录最高层，和<code>__init__.py</code>是同一级的，所以在启动celery时候这样：<code>celery --app=backend.celery worker --loglevel=DEBUG --config=celery_settings</code>， <code>--app</code>这个参数就不必解释了，最后一个<code>--config</code>参数，这个是导入celery的参数，其实有很多参数，我在应用中只用到了<code>CELERY_IMPORTS = (&quot;tasks&quot;, )</code>，作用就是将<code>tasks.py</code>中的task都注册了。</p>
<p>其中<code>tasks.py</code>也是和<code>celery.py</code>同一级的，里面包涵了所有要计算的task函数，比如这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@celery.task(bind=True)</div><div class="line">def test_ing(self, a):</div><div class="line">    self.update_state(state=&apos;PROGRESS&apos;,</div><div class="line">                      meta=&#123;&apos;current&apos;: 10, &apos;total&apos;: 10, &apos;time&apos;: 10&#125;)</div><div class="line">    time.sleep(10)</div><div class="line">    return &#123;&apos;current&apos;: a, &apos;total&apos;: a, &apos;time&apos;: a / 60&#125;</div></pre></td></tr></table></figure>
<p>然后将这些函数导入到路由那块，然后启动就好了。</p>
<p>启动时候出现错误<code>connection refused</code>，这个原因应该是redis在这样的启动方式下无法连接，所以我使用<code>inv web.gunicorn</code>启动，<code>inv</code>就是<code>invoke</code>，这个是自定义启动方式的一个包，其实就是相当于gunicorn启动。启动之后就好了，可以正常运行了。</p>
<h1 id="在Celery-tasks里面使用多进程"><a href="#在Celery-tasks里面使用多进程" class="headerlink" title="在Celery tasks里面使用多进程"></a>在Celery tasks里面使用多进程</h1><p>这个可是极好的功能，我试了一下在我的程序里加入多进程，由一个Python进程中运行变成现在四个进程运行，运行时间从0.36分钟减少到0.13分钟，大概3倍，因为多进程调度有损耗，所以不会完全的是4倍，但是已经很好啦。如果是8核16线程的话，大概能有12倍左右的提升。</p>
<p>以下是一个使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">from celery import Celery</div><div class="line">import time</div><div class="line">import multiprocessing as mp</div><div class="line">app = Celery(&apos;proj&apos;, broker=&apos;amqp://admin:admin@ip:5672&apos;, include=&quot;tasks&quot;)</div><div class="line">def test_func(i):</div><div class="line">    print &quot;beg...:&quot;, i</div><div class="line">    time.sleep(5)</div><div class="line">    print &quot;....end:&quot;, i</div><div class="line">    return i * 5</div><div class="line">@app.task</div><div class="line">def fun_1(n):</div><div class="line">    curr_proc = mp.current_process()</div><div class="line">    curr_proc.daemon = False</div><div class="line">    p = mp.Pool(mp.cpu_count())</div><div class="line">    curr_proc.daemon = True</div><div class="line">    for i in range(n):</div><div class="line">        p.apply_async(test_func, args=(i,))</div><div class="line">    p.close()</div><div class="line">    p.join()</div><div class="line">    return 1</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app.start()</div></pre></td></tr></table></figure>
<p>直接启动多进程是肯定不可以的，因为是守候进程<code>curr_proc.daemon=True</code>，所以启多进程之前主动设置为非守候进程<code>curr_proc.daemon=False</code>，启动了以后再设为守候进程</p>
<h1 id="一些其他的总结"><a href="#一些其他的总结" class="headerlink" title="一些其他的总结"></a>一些其他的总结</h1><h2 id="向docker里面传文件"><a href="#向docker里面传文件" class="headerlink" title="向docker里面传文件"></a>向docker里面传文件</h2><p><code>cat invtasks/__init__.py | docker exec -i -u root beehive_ sh -c &#39;cat &gt; /opt/beehive/invtasks/__init__.py&#39;</code></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行</p>
<p><code>docker run -d --net=host --name=ability_stable -p 8888:8888 -it ability:170304</code></p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell中单引号和双引号是有区别的,单引号不执行里面的命令,双引号执行里面的命令</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>时区有问题:<code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>
<h2 id="Python模块包"><a href="#Python模块包" class="headerlink" title="Python模块包"></a>Python模块包</h2><p><code>sudo vim /usr/local/lib/python3.5/dist-packages/capacity/</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;https://blog.miguelgrinberg.com/post/using-celery-with-flask&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.miguelgrinberg.com/
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="英文" scheme="http://microndgt.github.io/tags/%E8%8B%B1%E6%96%87/"/>
    
      <category term="翻译" scheme="http://microndgt.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Celery" scheme="http://microndgt.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Docker总结</title>
    <link href="http://microndgt.github.io/2017/02/28/Docker%E6%80%BB%E7%BB%93/"/>
    <id>http://microndgt.github.io/2017/02/28/Docker总结/</id>
    <published>2017-02-28T02:09:44.000Z</published>
    <updated>2017-02-28T02:09:44.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解RESTful架构</title>
    <link href="http://microndgt.github.io/2017/02/27/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/"/>
    <id>http://microndgt.github.io/2017/02/27/理解RESTful架构/</id>
    <published>2017-02-27T01:43:24.000Z</published>
    <updated>2017-02-27T01:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解RESTful架构"><a href="#理解RESTful架构" class="headerlink" title="理解RESTful架构"></a>理解RESTful架构</h1><p>Representational State Transfer 表现层状态转化</p>
<p>表现层其实是指的是资源的表现层，所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>
<p>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。URI只代表资源的实体，不代表它的形式。而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。所以设计API的URI时候，去除表现层，只保留资源的位置。</p>
<p>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h2><ol>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层，比如json</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ol>
<h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ol>
<li>最常见的一种设计错误，就是URI包含动词。资源表示一种实体，应该是名词，URI不应该有动词，动词应该放在HTTP协议中。资源不能是动词，但是可以是一种服务。</li>
<li>在URI中加入版本号，不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Accept: vnd.example-com.foo+json; version=1.0</div><div class="line">Accept: vnd.example-com.foo+json; version=1.1</div></pre></td></tr></table></figure>
<h1 id="RESTful-API-设计指南"><a href="#RESTful-API-设计指南" class="headerlink" title="RESTful API 设计指南"></a>RESTful API 设计指南</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>路径又称”终点”（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<h2 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &quot;Invalid API key&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><ul>
<li>GET /collection：返回资源对象的列表（数组）</li>
<li>GET /collection/resource：返回单个资源对象</li>
<li>POST /collection：返回新生成的资源对象</li>
<li>PUT /collection/resource：返回完整的资源对象</li>
<li>PATCH /collection/resource：返回完整的资源对象</li>
<li>DELETE /collection/resource：返回一个空文档</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;理解RESTful架构&quot;&gt;&lt;a href=&quot;#理解RESTful架构&quot; class=&quot;headerlink&quot; title=&quot;理解RESTful架构&quot;&gt;&lt;/a&gt;理解RESTful架构&lt;/h1&gt;&lt;p&gt;Representational State Transfer 表现
    
    </summary>
    
      <category term="web" scheme="http://microndgt.github.io/categories/web/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Using Mix-Ins With Python</title>
    <link href="http://microndgt.github.io/2017/02/24/Using%20Mix-ins%20with%20Python/"/>
    <id>http://microndgt.github.io/2017/02/24/Using Mix-ins with Python/</id>
    <published>2017-02-24T04:10:49.000Z</published>
    <updated>2017-02-24T07:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Mixins扩展类功能"><a href="#利用Mixins扩展类功能" class="headerlink" title="利用Mixins扩展类功能"></a>利用Mixins扩展类功能</h1><p>扩展其他类的功能，但是这些类没有任何继承的关系。因此你不能简单的将这些方法放入一个基类,然后被其他类继承。所以就有了这个Mixins。</p>
<p>也可能是某个库提供了基础类，可以利用其构造自己的类。</p>
<p>扩展映射对象，添加日志，唯一性设置，类型检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class LoggedMappingMixin:</div><div class="line">    __slots__ = () # 混入类没有实例变量，因为直接实例化混入类没有意义</div><div class="line">    def __getitem__(self, key):</div><div class="line">        print(&apos;Getting &apos; + str(key))</div><div class="line">        return super().__getitem__(key)</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        print(&apos;Setting &#123;&#125; = &#123;!r&#125;&apos;.format(key, value))</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">    def __delitem__(self, key):</div><div class="line">        print(&apos;Deleting &apos; + str(key))</div><div class="line">        return super().__delitem__(key)</div><div class="line">class SetOnceMappingMixin:</div><div class="line">    __slots__ = ()</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        if key in self:</div><div class="line">            raise KeyError(str(key) + &apos; already set&apos;)</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">class StringKeysMappingMixin:</div><div class="line">    __slots__ = ()</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        if not isinstance(key, str):</div><div class="line">            raise TypeError(&apos;keys must be strings&apos;)</div><div class="line">        return super().__setitem__(key, value)</div></pre></td></tr></table></figure>
<p>通过多继承和其他映射对象混入使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class LoggedDict(LoggedMappingMixin, dict):</div><div class="line">    pass</div><div class="line">d = LoggedDict()</div><div class="line">d[&apos;x&apos;] = 23</div><div class="line">print(d[&apos;x&apos;])</div><div class="line">del d[&apos;x&apos;]</div><div class="line">from collections import defaultdict</div><div class="line">class SetOnceDefaultDict(SetOnceMappingMixin, defaultdict):</div><div class="line">    pass</div><div class="line">d = SetOnceDefaultDict(list)</div><div class="line">d[&apos;x&apos;].append(2)</div><div class="line">d[&apos;x&apos;].append(3)</div><div class="line">d[&apos;x&apos;] = 32 # wrong</div></pre></td></tr></table></figure>
<p>在一些大型库和框架中也会发现混入类的使用,用途同样是增强已存在的类的功能和一些可选特征,对于混入类,有几点需要记住。首先是,混入类不能直接被实例化使用。其次,混入类没有自己的态信息,也就是说它们并没有定义<code>__init__()</code>方法,并且没有实例属性。这也是为什么我们在上面明确定了<code>__slots__=()</code>。</p>
<p>还有一种实现混入类的方式就是使用类装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def LoggedMapping(cls):</div><div class="line">    cls_getitem = cls.__getitem__</div><div class="line">    cls_setitem = cls.__setitem__</div><div class="line">    cls_delitem = cls.__delitem__</div><div class="line">    def __getitem__(self, key):</div><div class="line">        print(&apos;Getting &apos; + str(key))</div><div class="line">        return super().__getitem__(key)</div><div class="line">    def __setitem__(self, key, value):</div><div class="line">        print(&apos;Setting &#123;&#125; = &#123;!r&#125;&apos;.format(key, value))</div><div class="line">        return super().__setitem__(key, value)</div><div class="line">    def __delitem__(self, key):</div><div class="line">        print(&apos;Deleting &apos; + str(key))</div><div class="line">        return super().__delitem__(key)</div><div class="line">    cls.__getitem__ = __getitem__</div><div class="line">    cls.__setitem__ = __setitem__</div><div class="line">    cls.__delitem__ = __delitem__</div><div class="line">    return cls</div><div class="line">@LoggedMapping</div><div class="line">class LoggedDict(dict):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="理解2"><a href="#理解2" class="headerlink" title="理解2"></a>理解2</h1><p>Mixin模式是一种在python里经常使用的模式，适当合理的应用能够达到复用代码，合理组织代码结构的目的。</p>
<p>Python的Mixin模式可以通过多继承的方式来实现, 举例来说，我们自定义一个简单的具有嵌套结构的数据容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class SimpleItemContainer(object):</div><div class="line">    def __init__(self, id, item_containers):</div><div class="line">        self.id = id</div><div class="line">        self.data = &#123;&#125;</div><div class="line">        for item in item_containers:</div><div class="line">            self.data[item.id] = item</div></pre></td></tr></table></figure>
<p>这时候利用python内置的<code>UserDict.DictMixin</code>来实现一个像原生字典的一样来访问数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from collections import MutableMapping as DictMixin</div><div class="line">class SimpleItemContainer(object):</div><div class="line">    def __init__(self, id, item_containers):</div><div class="line">        self.id = id</div><div class="line">        self.data = &#123;&#125;</div><div class="line">        for item in item_containers:</div><div class="line">            self.data[item[&apos;id&apos;]] = item[&apos;item&apos;]</div><div class="line">class BetterSimpleItemContainer(SimpleItemContainer, DictMixin):</div><div class="line">    def __getitem__(self, id):</div><div class="line">        return self.data[id]</div><div class="line">    def __setitem__(self, id, value):</div><div class="line">        self.data[id] = value</div><div class="line">    def __delitem__(self, id):</div><div class="line">        del self.data[id]</div><div class="line">    def __iter__(self):</div><div class="line">        return iter(self.data)</div><div class="line">    def __len__(self):</div><div class="line">        return len(self.data)</div><div class="line">    def keys(self):</div><div class="line">        return self.data.keys()</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    b = BetterSimpleItemContainer(1, [&#123;&apos;id&apos;:1,&apos;item&apos;:&apos;item&apos;&#125;])</div><div class="line">    print(b[1])</div><div class="line">    print(b)</div></pre></td></tr></table></figure>
<p>是一种特殊的多继承，而是在继承了一个基类的基础上，顺带利用多重继承的功能给这个子类添点料，增加一些其他的功能。保证Mixin的类功能单一具体，混入之后，新的类的MRO树其实也会相对很简单，并不会引起混乱。通常混入 Mixin 的类和 Mixin 类本身不是 is-a 的关系，混入 Mixin 类是为了添加某些（可选的）功能。自由地混入 Mixin 类就可以灵活地为被混入的类添加不同的功能。</p>
<p>python支持多继承后，但能否支持动态继承性质?在程序运行过程中，重定义类的继承，python是支持这种动态继承性质的。这也就是python中 的mixin，在定义类过程中改变类的继承顺序，继承类。当某个模块不能修改时，通过mixin方式可以动态添加该类的方法，动态改变类的原有继承体系。 弄懂了多继承，mixin特性就简单多了。 但需要注意mixin后的具体继承体系的改变。</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">import types</div><div class="line">def MixIn(pyClass,mixInClass,makeAncestor=0):</div><div class="line">    if makeAncestor:</div><div class="line">        pyClass.__bases__ = (mixInClass,) + pyClass.__bases__</div><div class="line">    elif mixInClass not in pyClass.__bases__:</div><div class="line">        pyClass.__bases__ = pyClass.__bases__ + (mixInClass,)</div><div class="line">    else:</div><div class="line">        pass</div><div class="line">class C1(object):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C1&apos;</div><div class="line">class C0MixIn(object):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C0MixIn&apos;</div><div class="line">class C2(C1,C0MixIn):</div><div class="line">    def test(self):</div><div class="line">        print &apos;test in C2&apos;</div><div class="line">class C0(C1):</div><div class="line">    pass</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    print C0.__mro__</div><div class="line">    c1 = C0()</div><div class="line">    c1.test()</div><div class="line">    MixIn(C0,C0MixIn,1)</div><div class="line">    c0 = C0()</div><div class="line">    c0.test()</div><div class="line">    print C0.__mro__</div><div class="line">    print C2.__mro__</div><div class="line">    MixIn(C2,C0MixIn)</div><div class="line">    print C2.__mro__</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(&lt;class &apos;__main__.C0&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">test in C1</div><div class="line">test in C0MixIn</div><div class="line">(&lt;class &apos;__main__.C0&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">(&lt;class &apos;__main__.C2&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div><div class="line">(&lt;class &apos;__main__.C2&apos;&gt;, &lt;class &apos;__main__.C1&apos;&gt;, &lt;class &apos;__main__.C0MixIn&apos;&gt;, &lt;type &apos;object&apos;&gt;)</div></pre></td></tr></table></figure>
<h1 id="Using-Mix-ins-with-Python"><a href="#Using-Mix-ins-with-Python" class="headerlink" title="Using Mix-ins with Python"></a>Using Mix-ins with Python</h1><p>翻译自<a href="http://www.linuxjournal.com/node/4540/print" target="_blank" rel="external">http://www.linuxjournal.com/node/4540/print</a></p>
<p>应用在Python中的mix-in编程风格的解释。</p>
<p>Mix-in编程是一种软件开发风格，其功能单元在一个类中创建然后在其他类中混入。可能这听起来像简单的继承，但是mix-in有别与传统的类。大多情况下mix-in不是任何一个给定类”主要的”父类，不关心它将用于什么类，被用于贯穿类继承体系的多数类，并且可以动态载入。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;利用Mixins扩展类功能&quot;&gt;&lt;a href=&quot;#利用Mixins扩展类功能&quot; class=&quot;headerlink&quot; title=&quot;利用Mixins扩展类功能&quot;&gt;&lt;/a&gt;利用Mixins扩展类功能&lt;/h1&gt;&lt;p&gt;扩展其他类的功能，但是这些类没有任何继承的关系。因此
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Mixin" scheme="http://microndgt.github.io/tags/Mixin/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter详解</title>
    <link href="http://microndgt.github.io/2017/02/24/Jupyter%E8%AF%A6%E8%A7%A3/"/>
    <id>http://microndgt.github.io/2017/02/24/Jupyter详解/</id>
    <published>2017-02-24T03:08:24.000Z</published>
    <updated>2017-02-24T03:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="import"><a href="#import" class="headerlink" title="__import__"></a><code>__import__</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def import_item(name):</div><div class="line">    parts = name.rsplit(&apos;.&apos;, 1)</div><div class="line">    if len(parts) == 2:</div><div class="line">        # called with &apos;foo.bar....&apos;</div><div class="line">        package, obj = parts</div><div class="line">        module = __import__(package, fromlist=[obj])</div><div class="line">        try:</div><div class="line">            pak = getattr(module, obj)</div><div class="line">        except AttributeError:</div><div class="line">            raise ImportError(&apos;No module named %s&apos; % obj)</div><div class="line">        return pak</div><div class="line">    else:</div><div class="line">        # called with un-dotted string</div><div class="line">        return __import__(parts[0])</div></pre></td></tr></table></figure>
<p><code>name.rsplit(&#39;.&#39;, 1)</code>表示从右边开始切分，只切分一次</p>
<p><code>__import__(package, fromlist=[obj])</code>:这里是当name是类似这种名字<code>foo.bar</code>才会运行，所以<code>package=foo</code>,fromlist不论填什么都会返回package，最后返回的module就是<code>foo</code>，然后在<code>foo</code>获取<code>bar</code>属性,如果没有这个的话，产生异常，否则返回获取的属性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;import&quot;&gt;&lt;a href=&quot;#import&quot; class=&quot;headerlink&quot; title=&quot;__import__&quot;&gt;&lt;/a&gt;&lt;code&gt;__import__&lt;/code&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Jupyter" scheme="http://microndgt.github.io/tags/Jupyter/"/>
    
  </entry>
  
  <entry>
    <title>Python 与 Zmq</title>
    <link href="http://microndgt.github.io/2017/02/24/Python-%E4%B8%8E-zmq/"/>
    <id>http://microndgt.github.io/2017/02/24/Python-与-zmq/</id>
    <published>2017-02-24T01:58:21.000Z</published>
    <updated>2017-02-24T02:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>zmq是一个云时代极速消息通信库，励志要写入Linux内核。这东西简单实用，完成同样的功能，如果是用socket，那恐怕要写出一大堆的代码，但用zmq，只需要简单的几行代码就可以了。</p>
<p>zmq的版本和pyzmq的版本:<code>zmq.zmq_version()</code>和<code>zmq.pyzmq_version()</code></p>
<h2 id="一个使用示例"><a href="#一个使用示例" class="headerlink" title="一个使用示例"></a>一个使用示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-13</div><div class="line">服务端，发布模式</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">from random import randrange</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.PUB)</div><div class="line">socket.bind(&quot;tcp://*:5556&quot;)</div><div class="line">while True:</div><div class="line">    zipcode = randrange(1, 100000)</div><div class="line">    temperature = randrange(-80, 135)</div><div class="line">    relhumidity = randrange(10, 60)</div><div class="line">    socket.send_string(&quot;%i %i %i&quot; % (zipcode,temperature , relhumidity))</div><div class="line"># 客户端</div><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-13</div><div class="line">订阅模式，如果设置了过滤条件，那么只会接收到以过滤条件开头的消息</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import sys</div><div class="line">import zmq</div><div class="line">#  Socket to talk to server</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.SUB)</div><div class="line">print(&quot;Collecting updates from weather server...&quot;)</div><div class="line">socket.connect(&quot;tcp://localhost:5556&quot;)</div><div class="line"># Subscribe to zipcode, default is NYC, 10001</div><div class="line">zip_filter = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;10002&quot;</div><div class="line"># 此处设置过滤条件，只有以 zip_filter 开头的消息才会被接收</div><div class="line">socket.setsockopt_string(zmq.SUBSCRIBE, zip_filter)</div><div class="line"># Process 5 updates</div><div class="line">total_temp = 0</div><div class="line">for update_nbr in range(5):</div><div class="line">    string = socket.recv().decode(&apos;utf-8&apos;)</div><div class="line">    print(string)</div><div class="line">    zipcode, temperature, relhumidity = string.split()</div><div class="line">    total_temp += int(temperature)</div><div class="line">print(&quot;Average temperature for zipcode &apos;%s&apos; was %dF&quot; % (zip_filter, total_temp / update_nbr))</div></pre></td></tr></table></figure>
<ul>
<li>zmq的程序，也是要分清服务端和客户端的，服务端也是要绑定ip和端口的</li>
<li>如果我们先启动客户端，后启动服务端，那么程序是可以正常运行的，换成socket，就不行，socket只能先启动服务端，后启动客户端</li>
<li>这是一个消息通信库，它自己实现了一些协议，使得我们可以非常轻松的在节点间，进程间，线程间传递消息</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>不论是服务端还是客户端，都需要获得zmq上下文<code>context = zmq.Context()</code></p>
<p>然后获得socket，每一个socket都是有自己的类型的，示例中，服务端的socket的类型是<code>zmq.PUB</code>，客户端的socket的类型是<code>zmq.SUB</code>，pub是发布，sub是订阅。说的通俗点，就是有一个pub节点，可以有多个sub节点，pub节点发出去的消息，如果sub节点没有设置过滤条件，那么就会接收所有的消息，如果有过滤条件，就只接收满足过滤条件的消息。</p>
<p>设置过滤条件很简单<code>socket.setsockopt(zmq.SUBSCRIBE, zip_filter)</code>第二个参数就是期望的过滤条件，只有那些以这个过滤条件开头的消息才会被接收</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>一个上下文可以创建任意多个socket，完全不受限制</li>
<li>先启动了客户端，服务端pub出去的一些消息也还是可能没有被收到，因为你启动服务端时，服务端与客户端要建立连接，而这个时候，消息其实已经发出去了，所以你没收到</li>
<li>客户端断开连接，没有影响。如果是服务端断开了呢，比如程序死掉了，那么客户端不会发生崩溃，只是阻塞在<code>socket.recv()</code>这条语句上，并且客户端有缓存，所以有可能客户端还在运行，只是收的数据是缓存中的数据。</li>
</ol>
<h2 id="zmq应答模式"><a href="#zmq应答模式" class="headerlink" title="zmq应答模式"></a>zmq应答模式</h2><ol>
<li>必须先提问，后回答</li>
<li>对于一个提问，只能回答一次</li>
<li>在没有收到回答前不能再次提问</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-10</div><div class="line">回复请求</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">import time</div><div class="line">context = zmq.Context()</div><div class="line">socket = context.socket(zmq.REP)</div><div class="line">socket.bind(&apos;tcp://*:5555&apos;)</div><div class="line">while True:</div><div class="line">    message = socket.recv()</div><div class="line">    print(&apos;received request: &apos;, message)</div><div class="line">    time.sleep(1)</div><div class="line">    socket.send_string(&apos;World&apos;)</div><div class="line"># 客户端</div><div class="line"># coding=utf-8</div><div class="line">&apos;&apos;&apos;&apos;&apos;</div><div class="line">Created on 2015-10-10</div><div class="line">你无法连续向服务器发送数据，必须发送一次，接收一次</div><div class="line">REQ和REP模式中，客户端必须先发起请求</div><div class="line">@author: kwsy2015</div><div class="line">&apos;&apos;&apos;</div><div class="line">import zmq</div><div class="line">context = zmq.Context()</div><div class="line">print(&apos;connect to hello world server&apos;)</div><div class="line">socket = context.socket(zmq.REQ)</div><div class="line">socket.connect(&apos;tcp://localhost:5555&apos;)</div><div class="line">for request in range(1, 10):</div><div class="line">    print(&apos;send &apos;, request, &apos;...&apos;)</div><div class="line">    socket.send_string(&apos;hello&apos;)</div><div class="line">    message = socket.recv()</div><div class="line">    print(&apos;received reply &apos;, request, &apos;[&apos;, message, &apos;]&apos;)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zmq是一个云时代极速消息通信库，励志要写入Linux内核。这东西简单实用，完成同样的功能，如果是用socket，那恐怕要写出一大堆的代码，但用zmq，只需要简单的几行代码就可以了。&lt;/p&gt;
&lt;p&gt;zmq的版本和pyzmq的版本:&lt;code&gt;zmq.zmq_version(
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>WireShark 抓包</title>
    <link href="http://microndgt.github.io/2017/02/21/WireShark-%E6%8A%93%E5%8C%85/"/>
    <id>http://microndgt.github.io/2017/02/21/WireShark-抓包/</id>
    <published>2017-02-21T04:05:10.000Z</published>
    <updated>2017-03-06T11:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h1><h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><h3 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h3><p>直接抓包本机网卡进出流量</p>
<h3 id="集线器环境"><a href="#集线器环境" class="headerlink" title="集线器环境"></a>集线器环境</h3><p>物理层，流量防洪，统一冲突域</p>
<h3 id="交换机环境"><a href="#交换机环境" class="headerlink" title="交换机环境"></a>交换机环境</h3><p>网络层产品，所以使用路由表或者Mac地址来通信的</p>
<p><strong>端口镜像SPAN</strong></p>
<p>将交换机流量copy过来，设置混杂模式，网络监控</p>
<p><strong>ARP欺骗</strong></p>
<p><code>Cain&amp;Abel</code> ARP攻击软件，ARP请求，广播，ARP回复，ARP欺骗。ARP表，后到优先，改掉了交换机的MAC表。最后决定是否将流量转出来。局域网攻击。</p>
<p><strong>MAC泛洪</strong></p>
<p>攻击交换机中抓包，泛洪垃圾包，产生大量的MAC地址，交换机的表会被爆表，如果没有MAC地址，会对外放洪。</p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul>
<li>GTK 1/2 图形化处理界面</li>
<li>Core</li>
<li>Wiretap 格式支持引擎</li>
<li>Capture 抓包引擎</li>
<li>Win-/libpcap</li>
</ul>
<h2 id="快速抓包"><a href="#快速抓包" class="headerlink" title="快速抓包"></a>快速抓包</h2><ul>
<li>选择网卡</li>
<li>停止抓包</li>
<li>保存数据包</li>
</ul>
<p>RTT 往返时延<br>TTL TTL的作用是限制IP数据包在计算机网络中的存在的时间</p>
<h2 id="名字解析"><a href="#名字解析" class="headerlink" title="名字解析"></a>名字解析</h2><ul>
<li>Mac地址解析</li>
<li>IP地址解析，网络名字解析</li>
<li>传输名字解析</li>
</ul>
<h2 id="数据包操作"><a href="#数据包操作" class="headerlink" title="数据包操作"></a>数据包操作</h2><ul>
<li>标记数据包，标记，配色方案</li>
<li>注释数据包</li>
<li>合并数据包</li>
<li>打印数据包</li>
<li>输出数据包</li>
</ul>
<h2 id="抓包选项设置"><a href="#抓包选项设置" class="headerlink" title="抓包选项设置"></a>抓包选项设置</h2><p>网卡设置，抓包过滤器，多文件连续保存，停止抓包规则，名字解析</p>
<p>过滤器：抓包过滤器，显示过滤器</p>
<p>BPF语法 Berkeley Packet Filter</p>
<p>类型：host主机 net子网 port端口</p>
<p>方向Dir： src dst</p>
<p>协议Proto： ether,ip,tcp,udp,http,ftp</p>
<p>逻辑运算符: &amp;&amp;, ||, !</p>
<p>示例：<code>src host 192.168.1.1 &amp;&amp; dst port 80</code>,抓取源地址为192.168.1.1，目的为80端口的流量</p>
<p><code>host 192.168.1.1 || host 192.168.1.2</code> 抓取这两个ip的流量</p>
<p><code>!broadcast</code> 不要抓取广播包</p>
<p>例子：</p>
<p>过滤MAC地址： <code>ether host 00:88:ca:86:f8:0d</code>, <code>ether src host 00:88:ca:86:f8:0d</code>, <code>ether dst host 00:88:ca:86:f8:0d</code></p>
<p>过滤IP地址：<code>host 192.168.0.1</code>,<code>src host 192.168.1.1</code>, <code>dst host 192.168.1.1</code></p>
<p>过滤端口：<code>port 80</code>, <code>!port 80</code>, <code>dst port 80</code></p>
<p>过滤协议：<code>arp</code>, <code>icmp</code></p>
<p>综合：<code>host 192.168.1.1 &amp;&amp; port 8080</code></p>
<p>先协议，然后方向，然后主机，端口</p>
<ul>
<li>显示过滤器</li>
</ul>
<p>==, !=, &gt;, &lt;, &gt;=, &lt;=</p>
<p>and, or, xor（有仅有一个条件满足), not</p>
<p>ip.addr, ip.src, ip.dst</p>
<p>tcp.port, tcp.srcport, tcp.dstport, tcp.flag.syn, tcp.flag.ack</p>
<p>arp, ip, icmp, udp, tcp, bootp, dns</p>
<ul>
<li>案例</li>
</ul>
<p><code>ip.addr == 192.168.1.1</code>, <code>ip.src == 192.168.1.1</code>, <code>ip.dst == 192.168.1.1</code>, <code>ip.src == 192.168.1.100 and ip.dst = 192.168.1.1</code></p>
<p><code>tcp.port == 80</code>, <code>tcp.srcport == 80</code>, <code>tcp.dstport == 80</code>, <code>tcp.flag.syn == 1</code></p>
<p><code>arp</code>, <code>tcp</code>, <code>udp</code>, <code>not http</code>, <code>not arp</code></p>
<p><code>ip.src == 192.168.1.1 and tcp.dstport == 80</code></p>
<p><code>ip.addr == 192.168.1.1 and udp.port == 4000</code></p>
<h1 id="数据流追踪"><a href="#数据流追踪" class="headerlink" title="数据流追踪"></a>数据流追踪</h1><p>tcp,udp,ssl数据流进行重组并且完整呈现出来</p>
<h1 id="专家信息说明"><a href="#专家信息说明" class="headerlink" title="专家信息说明"></a>专家信息说明</h1><p>可以对数据包中特定状态进行警告说明，errors, warnings, notes, chats</p>
<h1 id="统计摘要说明"><a href="#统计摘要说明" class="headerlink" title="统计摘要说明"></a>统计摘要说明</h1><p>对抓取的数据包进行全局统计</p>
<h1 id="协议分层统计"><a href="#协议分层统计" class="headerlink" title="协议分层统计"></a>协议分层统计</h1><p>统计通信流量中不同协议占用的百分比，通过这个可以对全网流量有 直观的了解，整个网络哪些流量占用最多，哪些最少</p>
<h1 id="网络节点和会话统计"><a href="#网络节点和会话统计" class="headerlink" title="网络节点和会话统计"></a>网络节点和会话统计</h1><h1 id="数据包长度"><a href="#数据包长度" class="headerlink" title="数据包长度"></a>数据包长度</h1><h1 id="图表分析"><a href="#图表分析" class="headerlink" title="图表分析"></a>图表分析</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抓包原理&quot;&gt;&lt;a href=&quot;#抓包原理&quot; class=&quot;headerlink&quot; title=&quot;抓包原理&quot;&gt;&lt;/a&gt;抓包原理&lt;/h1&gt;&lt;h2 id=&quot;网络原理&quot;&gt;&lt;a href=&quot;#网络原理&quot; class=&quot;headerlink&quot; title=&quot;网络原理&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
      <category term="WireShark" scheme="http://microndgt.github.io/tags/WireShark/"/>
    
  </entry>
  
  <entry>
    <title>BAIDU的DNS解析</title>
    <link href="http://microndgt.github.io/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/"/>
    <id>http://microndgt.github.io/2017/02/19/BAIDU的DNS解析/</id>
    <published>2017-02-19T09:31:18.000Z</published>
    <updated>2017-02-20T02:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天用<code>nslookup</code>命令解析查看了<code>www.baidu.com</code>的IP地址，却意外发现百度的<code>CNAME</code>居然是<code>www.a.shifen.com</code></p>
<h1 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">nslookup www.baidu.com</div><div class="line">&gt;&gt;&gt;</div><div class="line">Server:		119.29.29.29</div><div class="line">Address:	119.29.29.29#53</div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">www.baidu.com	canonical name = www.a.shifen.com.</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.111.188</div><div class="line">Name:	www.a.shifen.com</div><div class="line">Address: 220.181.112.244</div></pre></td></tr></table></figure>
<p>接下来看看一个详细的baidu的dns解析过程</p>
<p>理论上，目前我的电脑通过ISP接入互联网，ISP就会分配一个本地DNS服务器（非权威服务器），然后我的电脑向这个ISP DNS服务器发起请求，查询<code>www.baidu.com</code>的IP地址。</p>
<p>首先DNS会检查自己的缓存里面有没有这个地址，如果有的话直接返回，没有的话，ISP会把请求发送给根DNS服务器（13台），然后根DNS服务器发现是<code>.com</code>结尾，是<code>.com</code>这个顶级域名下的，就告诉请求者负责解析<code>.com</code>的DNS服务器，ISP DNS再次向baidu.com这个域的权威服务器发起请求，服务器收到之后，查一下www这台主机，然后把IP返回给IPS DNS，然后把地址返回给PC，并且存入缓存中，以便再次访问。</p>
<p>使用dig命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+trace 表示将显示从根域逐级查询的过程，追踪dns解析中的问题</div><div class="line">+tcp dig默认使用udp协议，使用tcp方式</div></pre></td></tr></table></figure>
<p><code>dig www.baidu.com</code>的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">kevin:~ $ dig www.baidu.com</div><div class="line"># 版本信息和全局设置选项</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line"># DNS返回的技术信息</div><div class="line">;; Got answer:</div><div class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20158</div><div class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</div><div class="line"># 问题，查询的名字和类型字段，A记录</div><div class="line">;; QUESTION SECTION:</div><div class="line">;www.baidu.com.			IN	A</div><div class="line"># 回答，对查询的响应中的RR</div><div class="line">;; ANSWER SECTION:</div><div class="line">www.baidu.com.		1014	IN	CNAME	www.a.shifen.com.</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.111.188</div><div class="line">www.a.shifen.com.	114	IN	A	220.181.112.244</div><div class="line"># 查询的统计数据</div><div class="line">;; Query time: 60 msec</div><div class="line">;; SERVER: 119.29.29.29#53(119.29.29.29)</div><div class="line">;; WHEN: Sun Feb 19 15:07:00 2017</div><div class="line">;; MSG SIZE  rcvd: 90</div></pre></td></tr></table></figure>
<p>然后使用trace功能，从头显示dns解析过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace www.baidu.com</div><div class="line"># 查询根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace www.baidu.com</div><div class="line">;; global options: +cmd</div><div class="line">.			335103	IN	NS	m.root-servers.net.</div><div class="line">.			335103	IN	NS	a.root-servers.net.</div><div class="line">.			335103	IN	NS	j.root-servers.net.</div><div class="line">.			335103	IN	NS	e.root-servers.net.</div><div class="line">.			335103	IN	NS	c.root-servers.net.</div><div class="line">.			335103	IN	NS	i.root-servers.net.</div><div class="line">.			335103	IN	NS	b.root-servers.net.</div><div class="line">.			335103	IN	NS	g.root-servers.net.</div><div class="line">.			335103	IN	NS	h.root-servers.net.</div><div class="line">.			335103	IN	NS	k.root-servers.net.</div><div class="line">.			335103	IN	NS	l.root-servers.net.</div><div class="line">.			335103	IN	NS	d.root-servers.net.</div><div class="line">.			335103	IN	NS	f.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 3126 ms</div><div class="line"># 查询到的com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">;; Received 503 bytes from 198.41.0.4#53(198.41.0.4) in 5139 ms</div><div class="line"># 查询到的baidu.com权威dns服务器</div><div class="line">baidu.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">baidu.com.		172800	IN	NS	ns7.baidu.com.</div><div class="line">;; Received 201 bytes from 192.52.178.30#53(192.52.178.30) in 1697 ms</div><div class="line"># 查询到的别名</div><div class="line">www.baidu.com.		1200	IN	CNAME	www.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 228 bytes from 61.135.165.235#53(61.135.165.235) in 123 ms</div></pre></td></tr></table></figure>
<p>首先获取13个根服务器的13个IP和主机名，然后向其中一个<code>198.41.0.4</code>发送<code>www.baidu.com</code>请求，返回<code>.com</code>顶级域的服务器IP，接着向<code>.com</code>域的一台服务器<code>192.52.178.30</code>请求，返回<code>baidu.com</code>域名服务器IP和名称，向百度的顶级域名服务器<code>dns.baidu.com</code>请求<code>www.baidu.com</code>，他发现这个www有别名叫<code>www.a.shifen.com</code>。</p>
<p>一般来讲，dns请求到别名的时候，查询就会终止，然后重新发起查询别名的请求，所以应该返回<code>www.a.shifen.com</code>，但是其实它返回了<code>a.shifen.com</code>的NS</p>
<p>再使用dig工具来查询一下<code>shifen.com</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~ $ dig +trace shifen.com</div><div class="line"># 查询的根DNS服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace shifen.com</div><div class="line">;; global options: +cmd</div><div class="line">.			188674	IN	NS	a.root-servers.net.</div><div class="line">.			188674	IN	NS	b.root-servers.net.</div><div class="line">.			188674	IN	NS	h.root-servers.net.</div><div class="line">.			188674	IN	NS	d.root-servers.net.</div><div class="line">.			188674	IN	NS	g.root-servers.net.</div><div class="line">.			188674	IN	NS	l.root-servers.net.</div><div class="line">.			188674	IN	NS	m.root-servers.net.</div><div class="line">.			188674	IN	NS	f.root-servers.net.</div><div class="line">.			188674	IN	NS	j.root-servers.net.</div><div class="line">.			188674	IN	NS	c.root-servers.net.</div><div class="line">.			188674	IN	NS	i.root-servers.net.</div><div class="line">.			188674	IN	NS	e.root-servers.net.</div><div class="line">.			188674	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 1573 ms</div><div class="line"># com顶级域dns服务器</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">;; Received 488 bytes from 192.33.4.12#53(192.33.4.12) in 2454 ms</div><div class="line"># shifen.com 权威dns服务器</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 170 bytes from 192.33.14.30#53(192.33.14.30) in 430 ms</div><div class="line"># 最终的A记录和NS记录</div><div class="line">shifen.com.		7200	IN	A	202.108.250.218</div><div class="line">shifen.com.		86400	IN	NS	ns4.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		86400	IN	NS	ns1.baidu.com.</div><div class="line">;; Received 186 bytes from 61.135.165.235#53(61.135.165.235) in 24 ms</div></pre></td></tr></table></figure>
<p>从这里可以看出来<code>shifen.com</code>和<code>baidu.com</code>的域名服务器是同一台，当拿到别名<code>www.a.shifen.com</code>的时候，本来要重新到com域查找<code>shifen.com</code>的NS，又因为两个域在同一台NS上，所以直接本机发起了<code>shifen.com</code>请求，发现<code>www.a.shifen.com</code>是属于<code>a.shifen.com</code>这个域的，所以直接访问<code>shifen.com</code>所返回的IP地址，结果是<code>403 Forbidden</code>，所以应该去到<code>a.shifen.com</code>这个域获取，于是把<code>a.shifen.com</code>这个NS和IP返回，然后在<code>a.shifen.com</code>这个域的域名服务器上查询<code>www.a.shifen.com</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">kevin@duguangtingdeMacBook-Pro:~/Desktop/work/capacity $ dig www.a.shifen.com +trace</div><div class="line"># 根dns服务器</div><div class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; www.a.shifen.com +trace</div><div class="line">;; global options: +cmd</div><div class="line">.			174188	IN	NS	a.root-servers.net.</div><div class="line">.			174188	IN	NS	b.root-servers.net.</div><div class="line">.			174188	IN	NS	h.root-servers.net.</div><div class="line">.			174188	IN	NS	d.root-servers.net.</div><div class="line">.			174188	IN	NS	g.root-servers.net.</div><div class="line">.			174188	IN	NS	l.root-servers.net.</div><div class="line">.			174188	IN	NS	m.root-servers.net.</div><div class="line">.			174188	IN	NS	f.root-servers.net.</div><div class="line">.			174188	IN	NS	j.root-servers.net.</div><div class="line">.			174188	IN	NS	c.root-servers.net.</div><div class="line">.			174188	IN	NS	i.root-servers.net.</div><div class="line">.			174188	IN	NS	e.root-servers.net.</div><div class="line">.			174188	IN	NS	k.root-servers.net.</div><div class="line">;; Received 228 bytes from 119.29.29.29#53(119.29.29.29) in 39 ms</div><div class="line"># com域</div><div class="line">com.			172800	IN	NS	c.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	d.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	m.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	j.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	f.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	e.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	b.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	h.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	a.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	k.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	i.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	l.gtld-servers.net.</div><div class="line">com.			172800	IN	NS	g.gtld-servers.net.</div><div class="line">;; Received 494 bytes from 192.203.230.10#53(192.203.230.10) in 523 ms</div><div class="line"># 先查的是shifen.com</div><div class="line">shifen.com.		172800	IN	NS	dns.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns2.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns3.baidu.com.</div><div class="line">shifen.com.		172800	IN	NS	ns4.baidu.com.</div><div class="line">;; Received 176 bytes from 192.33.14.30#53(192.33.14.30) in 27 ms</div><div class="line"># 发现是属于 a.shifen.com这个域的</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">;; Received 204 bytes from 61.135.165.235#53(61.135.165.235) in 82 ms</div><div class="line"># 在a.shifen.com这个域上查找</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.125</div><div class="line">www.a.shifen.com.	300	IN	A	61.135.169.121</div><div class="line">a.shifen.com.		1200	IN	NS	ns3.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns4.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns5.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns1.a.shifen.com.</div><div class="line">a.shifen.com.		1200	IN	NS	ns2.a.shifen.com.</div><div class="line">;; Received 236 bytes from 61.135.162.215#53(61.135.162.215) in 38 ms</div></pre></td></tr></table></figure>
<p>直接访问之，正是百度的页面。</p>
<h1 id="彩蛋-shifen-com由来"><a href="#彩蛋-shifen-com由来" class="headerlink" title="彩蛋-shifen.com由来"></a><code>彩蛋-shifen.com由来</code></h1><p><code>http://shifen.com</code>是百度当年为了竞价排名这个广告系统注册的，这个后台系统被命名为Shifen竞价排名，以前的销售系统现在还叫shifen销售系统。因为当年百度那个广告最低点击10分起价。为什么有这么一个奇怪的名字呢？在《相信中国》中，梁冬先生这样写道：“这个将来成就了百度80%收入的商业模式，最初的管理平台是由一个叫刘子正的实习生主持开发的。这也是唯一一个除<code>http://baidu.com</code>以外，外人所知的百度公司所拥有的国际域名。</p>
<p>另外：大公司都跟“十分”有关系啊，比如腾讯——TenCent⋯⋯</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天用&lt;code&gt;nslookup&lt;/code&gt;命令解析查看了&lt;code&gt;www.baidu.com&lt;/code&gt;的IP地址，却意外发现百度的&lt;code&gt;CNAME&lt;/code&gt;居然是&lt;code&gt;www.a.shifen.com&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;解析过
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 应用层</title>
    <link href="http://microndgt.github.io/2017/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://microndgt.github.io/2017/02/19/计算机网络-应用层/</id>
    <published>2017-02-19T03:06:16.000Z</published>
    <updated>2017-02-20T08:52:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><h2 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h2><p>网络体系结构是固定的，为应用程序提供了特定的服务集合，应用程序体系结构主要有一下：客户－服务器体系结构或者对等P2P体系结构</p>
<p>客户－服务器体系结构有一个打开的主机作为服务器，服务于来自其他客户的主机请求，客户通过向该服务器的IP地址发送分组来与其联系。</p>
<p>P2P体系结构中，应用程序在间断链接的主机对之间使用直接通信，这些主机对被称为对等方，通信不必经过专门的服务器，在即时讯息应用，服务器被用于跟踪用户的IP地址，用户和用户的报文在用户主机之间直接发送。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进行通信的实际上是进程而不是程序，进程运行在相同的端系统上时，他们使用进程间通信机制相互通信，进程间通信规则由端系统上的操作系统确定。两个不同端系统上的进行，通过跨越计算机网络交换报文而相互通信。</p>
<p>进程通过一个被称为套接字的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口。开发者可以控制套接字在应用层端的一切，但是对套接字在运输层端几乎没有控制权。</p>
<p>为了标识接收进程，需要定义两种信息，主机的地址和接收进程标识符。IP地址和目的端口号。</p>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>主要有可靠运输服务，吞吐量，定时和安全性。</p>
<p>可靠运输：确保数据交付服务，进程到进程之间的可靠数据传输</p>
<p>吞吐量：发送进程能够向接收进程交付比特的速率，运输层协议能够以某种特定的速率提供确保的可用吞吐量，使用这种服务，应用程序能够请求r比特/s的确保吞吐量</p>
<p>定时：提供定时保证</p>
<p>安全性，运输协议能够为应用程序提供一种或者多种安全性服务。</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
<p>SSL：安全套接字层，是对TCP的加强，这种强化是在应用层上实现的。</p>
<p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
<p>当前互联网能够为时间敏感应用提供服务，但是不能提供定时或者带宽保证。</p>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><p>定义了运行在不同端系统的应用程序进程如何相互传递报文，定义了</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则</li>
</ul>
<p>web的应用层协议是HTTP，定义了在浏览器和web服务器之间传输的报文格式和序列</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>超文本传输协议，HTTP，web的核心，HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<p>每个URL地址由两部分组成，存放对象的服务器主机名和对象的路径名</p>
<p>web浏览器实现了HTTP的客户端，web服务器实现了HTTP的服务器端，存储web对象，每个对象由URL寻址。</p>
<p>HTTP定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式。HTTP使用TCP作为他的支撑运输协议。</p>
<p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议。</p>
<h2 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h2><p>HTTP在其默认方式下使用持续连接，HTTP客户和服务器能够配置成使用非持续连接。每个请求响应对是经一个单独的TCP连接发送，非持续连接。所有请求和响应经过相同的TCP链接发送，持续连接。</p>
<p>往返时间RTT，指一个短分组从客户到服务器然后再返回客户所花费的时间。因此一个TCP连接总的响应时间是两个RTT加上服务传输HTML文件的时间，三次握手及传输。</p>
<p>采用持续连接，服务器在发送响应后保持该TCP连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。如果经过一定时间间隔没有使用，HTTP服务器就关闭该链接。</p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /somedir/sth.html HTTP/1.1</div><div class="line">Host: www.someschool.edu</div><div class="line">Connection: close</div><div class="line">User-agent: Mozilla/5.0</div><div class="line">Accept-language: fr</div></pre></td></tr></table></figure>
<p>每行由一个回车和换行符结束，最后一行再附加一个回车换行符。第一行是请求行，其后继行叫做首部行，对于POST请求，后面还附有实体体。Connection close说明服务器不希望使用持续连接。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Connection: close</div><div class="line">Date: Tue, 09 Aug 2016 15:44:04 GMT</div><div class="line">Server: Apache/2.2.3 (CentOS)</div><div class="line">Last-Modified:</div><div class="line">Content-Length: 6821</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">(data...)</div></pre></td></tr></table></figure>
<p>初始状态行，首部行和实体体，Date是服务器产生并且发送该响应报文的日期和时间。</p>
<h2 id="用户和服务器的交互：cookie"><a href="#用户和服务器的交互：cookie" class="headerlink" title="用户和服务器的交互：cookie"></a>用户和服务器的交互：cookie</h2><p>HTTP使用cookie允许站点对用户进行跟踪</p>
<p>HTTP响应报文中一个cookie首部行，HTTP请求报文中一个cookie首部行，用户端系统保留有一个cookie文件，并有用户的浏览器进行管理，后端Web站点有一个后端数据库。</p>
<p>cookie用于标识一个用户，用户首次访问一个站点需要一个用户标识，cookie可以在无状态的HTTP上建立了一个用户会话层。</p>
<h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体，具体内容见书74页。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<p>通过使用内容分发网络，CDN，web缓存器，CDN公司安装了地理上分散的缓存器，使得大量流量本地化。</p>
<h2 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h2><p>http协议有一种机制，允许缓存器证实它的对象是最新的，就是条件get方法，请求报文使用get方法， 有一个<code>If-Modified-Since</code>首部，其内容是日期，指当指定日期之后该对象被修改过，才发送该对象。作为对条件get方法的响应，web服务器仍然发送一个响应报文，但是没有在响应报文中包含所请求的对象，如果没有修改过的话。<code>304 Not Modified</code>表示缓存器可以使用该对象，能向请求的浏览器转发它缓存的该对象副本。</p>
<h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><p>FTP与HTTP都是运行在TCP上，FTP用了两个并行的TCP来传输文件，一个是控制链接，一个是数据连接。控制链接用于在两主机上传输控制信息，数据连接用于实际发送文件数据，HTTP是在同一个TCP连接内发送请求和响应的，HTTP是带内发送控制信息的，FTP是带外发送控制信息的。</p>
<p>FTP的客户首先在服务器21号端口发起一个用于控制的TCP连接。对FTP传输而言，控制连接贯穿了整个用户会话期间，但是对会话的每次文件传输都需要建立一个新的数据连接，数据连接是非持续的。</p>
<p>FTP服务器将对每个进行中的用户会话状态信息进行追踪，大大限制了FTP同时维护的会话总数。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络应用方面的原理和实现，包括应用程序所需要使用的网络服务，客户和服务器，进程和运输层接口。研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。&lt;/p&gt;
&lt;h1 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;heade
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python后台开发工程师面试指南</title>
    <link href="http://microndgt.github.io/2017/02/17/Python%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://microndgt.github.io/2017/02/17/Python后台开发工程师面试指南/</id>
    <published>2017-02-17T09:15:39.000Z</published>
    <updated>2017-02-23T10:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者得天下。。万一有面试者提前看了这篇文章，那就偷着乐吧，啊哈哈哈哈。</p>
<h1 id="Python篇"><a href="#Python篇" class="headerlink" title="Python篇"></a>Python篇</h1><h2 id="序列倒序"><a href="#序列倒序" class="headerlink" title="序列倒序"></a>序列倒序</h2><p>这个问题是我乐此不疲的问题之一，方法有好多种。。。另外，记住拼写，<code>reverse</code>，好多面试者写错了= =</p>
<ol>
<li><code>a[::-1]</code></li>
<li>对于列表<code>a.reverse()</code>,原地倒序</li>
<li>对于字符串不可变对象，<code>&#39;&#39;.join(list(reversed(a)))</code></li>
</ol>
<h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>这个主要有两种常用方法一种套路</p>
<ol>
<li><code>sorted(a.items(), key=lambda x: x[0])</code></li>
<li>使用itemgetter</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from operator import itemgetter</div><div class="line">sorted(a.items(), key=itemgetter(0))</div></pre></td></tr></table></figure>
<p>对列表字典等结构排序也很容易。</p>
<h2 id="寻找序列中次数最多的元素"><a href="#寻找序列中次数最多的元素" class="headerlink" title="寻找序列中次数最多的元素"></a>寻找序列中次数最多的元素</h2><p>这个问题在leetcode刷题的时候遇到过，当时是用字典手动实现的，但是用<code>collections</code>模块的<code>Counter</code>类更简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from collections import Counter</div><div class="line">word_counts = Counter(word)</div><div class="line">top_three = word_counts.most_common(3)</div></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>实现一个简单的闭包，以及阐述其特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def func(name):</div><div class="line">    def inner_func(age):</div><div class="line">        print &apos;name:&apos;, name, &apos;age:&apos;, age</div><div class="line">    return inner_func</div></pre></td></tr></table></figure>
<p>在python中很重要也很常见的一个使用场景就是装饰器，Python为装饰器提供了一个很友好的“语法糖”——<code>@</code>，让我们可以很方便的使用装饰器</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>实现一个简单的生成器函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def odd():</div><div class="line">    n = 1</div><div class="line">    while True:</div><div class="line">        yield n</div><div class="line">        n += 2</div><div class="line">odd_num = odd()</div><div class="line">count = 0</div><div class="line">for o in odd_num:</div><div class="line">    if count &gt;= 5: break</div><div class="line">    print(o)</div><div class="line">    count += 1</div></pre></td></tr></table></figure>
<h2 id="静态方法，类方法，实例方法的区别"><a href="#静态方法，类方法，实例方法的区别" class="headerlink" title="静态方法，类方法，实例方法的区别"></a>静态方法，类方法，实例方法的区别</h2><p>实例方法就是类的实例能够使用的方法。</p>
<p>静态方法是一种普通函数，就位于类定义的命名空间中，它不会对任何实例类型进行操作。使用装饰器<code>@staticmethod</code>定义静态方法。</p>
<p>类方法是将类本身作为对象进行操作的方法。类方法使用<code>@classmethod</code>装饰器定义，其第一个参数是类，约定写为<code>cls</code>。类对象和实例都可以调用类方法</p>
<h2 id="Python中有哪几种导入方法"><a href="#Python中有哪几种导入方法" class="headerlink" title="Python中有哪几种导入方法"></a>Python中有哪几种导入方法</h2><ul>
<li><code>import modname</code></li>
<li><code>from modname import a</code></li>
<li>内建函数<code>__import__()</code></li>
</ul>
<h2 id="一个使用上下文管理器的例子"><a href="#一个使用上下文管理器的例子" class="headerlink" title="一个使用上下文管理器的例子"></a>一个使用上下文管理器的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with open(filename, mode) as writer:</div><div class="line">    writer.write(&quot;hello&quot;)</div><div class="line">    writer.write(&quot;world&quot;)</div></pre></td></tr></table></figure>
<h2 id="property属性"><a href="#property属性" class="headerlink" title="property属性"></a>property属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Celsius:</div><div class="line">    def __init__(self, temperature = 0):</div><div class="line">        self._temperature = temperature</div><div class="line">    def to_fahrenheit(self):</div><div class="line">        return (self.temperature * 1.8) + 32</div><div class="line">    @property</div><div class="line">    def temperature(self):</div><div class="line">        print(&quot;Getting value&quot;)</div><div class="line">        return self._temperature</div><div class="line">    @temperature.setter</div><div class="line">    def temperature(self, value):</div><div class="line">        if value &lt; -273:</div><div class="line">            raise ValueError(&quot;Temperature below -273 is not possible&quot;)</div><div class="line">        print(&quot;Setting value&quot;)</div><div class="line">        self._temperature = value</div></pre></td></tr></table></figure>
<h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><h2 id="简述Python全局锁问题"><a href="#简述Python全局锁问题" class="headerlink" title="简述Python全局锁问题"></a>简述Python全局锁问题</h2><p>线程安全: 在多线程环境中，当各线程不共享数据的时候，那么一定是线程安全的。问题是这种情况并不多见，在多数情况下需要共享数据，这时就需要进行适当的同步控制了。</p>
<p>Python全局锁问题: 解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="因特网的协议栈由哪几个层次组成？"><a href="#因特网的协议栈由哪几个层次组成？" class="headerlink" title="因特网的协议栈由哪几个层次组成？"></a>因特网的协议栈由哪几个层次组成？</h2><ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<h2 id="运输层有哪两种主要的协议，有什么特点"><a href="#运输层有哪两种主要的协议，有什么特点" class="headerlink" title="运输层有哪两种主要的协议，有什么特点."></a>运输层有哪两种主要的协议，有什么特点.</h2><ul>
<li><p>TCP：包括面向链接的服务和可靠数据传输服务，在应用层数据开始流动之前，TCP让服务器和客户互联，即握手，之后TCP链接就在两个进程的套接字之间建立了，是全双工的，即链接双方的进程可以在此链接上同时进行报文收发。同时其具有拥塞控制机制。</p>
</li>
<li><p>UDP：不提供不必要服务的轻量级运输协议，提供最小服务，提供一种不可靠数据传送服务，不保证报文将到达接收进程，到达也可能是乱序到达的，没有拥塞控制机制。</p>
</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP由两个程序实现，一个客户程序，一个服务器程序，客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。</p>
<h2 id="简述web缓存器（代理服务器）的作用和特点。"><a href="#简述web缓存器（代理服务器）的作用和特点。" class="headerlink" title="简述web缓存器（代理服务器）的作用和特点。"></a>简述web缓存器（代理服务器）的作用和特点。</h2><p>web缓存器也叫做代理服务器，他是能够代表初始web服务器来满足http请求的网络实体。web缓存器既是服务器又是客户，当它接收浏览器的请求并且发回响应的时候是服务器，当它向初始服务器发送请求并且接收响应时候，是一个客户。</p>
<p>web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与web缓存器之间的瓶颈带宽时。</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支的原理</p>
<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h2 id="REST表现层状态迁移"><a href="#REST表现层状态迁移" class="headerlink" title="REST表现层状态迁移"></a>REST表现层状态迁移</h2><p>如何理解web service</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统的本质是什么？"><a href="#操作系统的本质是什么？" class="headerlink" title="操作系统的本质是什么？"></a>操作系统的本质是什么？</h2><p>对计算机资源的调度</p>
<h2 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h2><p>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。</p>
<p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="Reverse-a-singly-linked-list"><a href="#Reverse-a-singly-linked-list" class="headerlink" title="Reverse a singly linked list."></a>Reverse a singly linked list.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Definition for singly-linked list.</div><div class="line"># class ListNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.next = None</div><div class="line"></div><div class="line">class Solution(object):</div><div class="line">    def reverseList(self, head):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type head: ListNode</div><div class="line">        :rtype: ListNode</div><div class="line">        &quot;&quot;&quot;</div></pre></td></tr></table></figure>
<h2 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h2><p>Given two binary trees, write a function to check if they are equal or not.<br>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># Definition for a binary tree node.</div><div class="line"># class TreeNode(object):</div><div class="line">#     def __init__(self, x):</div><div class="line">#         self.val = x</div><div class="line">#         self.left = None</div><div class="line">#         self.right = None</div><div class="line">class Solution(object):</div><div class="line">    def isSameTree(self, p, q):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        :type p: TreeNode</div><div class="line">        :type q: TreeNode</div><div class="line">        :rtype: bool</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        #判断结构和值，并且注意空节点的判断</div><div class="line">        if p is None and q is None:</div><div class="line">            return True</div><div class="line">        elif p is None or q is None:</div><div class="line">            return False</div><div class="line">        else:</div><div class="line">            if p.val == q.val:</div><div class="line">                #值相同的时候，比较左子树</div><div class="line">                if self.isSameTree(p.left,q.left):</div><div class="line">                    #如果左子树相同，比较右子树</div><div class="line">                    return self.isSameTree(p.right,q.right)</div><div class="line">            #如果值不相同</div><div class="line">            return False</div></pre></td></tr></table></figure>
<h1 id="web（flask）"><a href="#web（flask）" class="headerlink" title="web（flask）"></a>web（flask）</h1><h2 id="web程序的结构，开发模式"><a href="#web程序的结构，开发模式" class="headerlink" title="web程序的结构，开发模式"></a>web程序的结构，开发模式</h2><h2 id="蓝本的作用"><a href="#蓝本的作用" class="headerlink" title="蓝本的作用"></a>蓝本的作用</h2><p>蓝本中定义的路由处于休眠状态，直到蓝本注册到程序中后，路由才真正成为程序的一部分。蓝本可以在单个文件定义，也可以用结构化的方式在包中的多个模块中构建。</p>
<h2 id="如何理解restful"><a href="#如何理解restful" class="headerlink" title="如何理解restful"></a>如何理解restful</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两天当了三次面试官，刚开始面试的时候不知道问些什么，后来就形成套路了，基本就是先是Python语法，多线程多进程，然后是数据分析，数据结构与算法，操作系统，Linux，数据库。不过有些问题自己也不知道答案。。。为了防止自己什么时候卡壳，所以总结一下这个面试指南，得指南者
    
    </summary>
    
      <category term="面试" scheme="http://microndgt.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>密钥加解密</title>
    <link href="http://microndgt.github.io/2017/02/17/%E5%AF%86%E9%92%A5%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://microndgt.github.io/2017/02/17/密钥加解密/</id>
    <published>2017-02-17T08:03:45.000Z</published>
    <updated>2017-02-17T08:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用不同的加密算法与加密模式进行加密"><a href="#使用不同的加密算法与加密模式进行加密" class="headerlink" title="使用不同的加密算法与加密模式进行加密"></a>使用不同的加密算法与加密模式进行加密</h1><p><code>openssl enc</code>加密解密文件,<code>openssl enc ciphertype -e -in plain.txt -out cipher.bin -K 00112233445566778899aabbccddeeff -iv 0102030405060708</code></p>
<p>cipher 密码，密码(cipher):指 bf, cast, des, aes, rs2 等 加密模式(encryption mode):指 cbc, ecb, cfb, ofb 等。两者组合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-K/-iv 十六进制密钥与初始向量</div><div class="line">-e 加密</div><div class="line">-d 解密</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;a href=&quot;#使用不同的加密算法与加密模式进行加密&quot; class=&quot;headerlink&quot; title=&quot;使用不同的加密算法与加密模式进行加密&quot;&gt;&lt;/a&gt;使用不同的加密算法与加密模式进行加密&lt;/h1&gt;&lt;p&gt;&lt;code&gt;
    
    </summary>
    
      <category term="信息安全" scheme="http://microndgt.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://microndgt.github.io/2017/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://microndgt.github.io/2017/02/17/计算机网络/</id>
    <published>2017-02-17T06:03:41.000Z</published>
    <updated>2017-02-18T11:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。</p>
<h1 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h1><h2 id="网络的具体构成"><a href="#网络的具体构成" class="headerlink" title="网络的具体构成"></a>网络的具体构成</h2><p>设备：主机或端系统，端系统通过通信链路和分组交换机链接在一起，链路的速率是bps度量，数据发送是，发送端将数据分段，每段加上首部字节。这样的信息包称为分组。两种分组交换机是路由器和链路层交换机。分组交换机类似于立交桥。</p>
<p>端系统通过因特网服务提供商ISP接入互联网，每个ISP是一个由多个分组交换机和多段通信链路组成的网络。地层ISP通过国家的，国际的高层ISP互联起来，高层ISP是由通过高速光纤链路互联的高速路由器组成的。</p>
<p>信息接收和发送的协议：TCP传输控制协议,IP网际协议。</p>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><p>从为应用程序提供服务的基础设施的角度来描述互联网，互联网是一种基础设施，新应用程序正在其上不断的发明和设置。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>完成一项工作，要求两个通信实体运行相同的协议。一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和接收或其他事件方面所采取的动作。</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><p>端系统连接到器边缘路由器的物理链路，边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>通过网络链路和交换机移动数据有两种方法，电路交换和分组交换。电路交换需要的资源在通信会话期间会被预留。分组交换网络，这些资源不被预留。电话网络是电路交换网络。因特网是分组交换网络。因特网尽力而为的以适时的方式传递分组。</p>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>存储转发传输，当路由器已经接收完了该分组的所有比特后，它才能开始向出链路传输，即转发该分组</p>
<p>排队时延和分组丢失，对于每条相连的链路，该分组交换机有一个输出缓存，缓存空间是有限的，网络拥塞程度越大，排队时延越大，还有可能出现分组丢失。</p>
<p>转发表和路由选择协议，源在该分组的首部包含了目的地的IP地址，每台路由器具有一个转发表，用于将目的地址映射城输出链路。路由器使用分组的目的地址来索引转发表并决定适当的出链路，因特网具有一些特殊的路由选择协议，用于自动的设置这些转发表，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>在端系统间通话会话期间，预留了端系统间通信沿路径所需要的资源，缓存，链路传输速率，传统的电话网络是电路交换网络的例子，建立链接后，沿着发送方和接收方之间路径上的交换机都将为该链接维护链接状态，当网络创建这种电路时候，他也在链接期间在该网络链路上预留了恒定的传输速率，表示为每条链路传输容量的一部分。</p>
<h2 id="分组交换网中的时延"><a href="#分组交换网中的时延" class="headerlink" title="分组交换网中的时延"></a>分组交换网中的时延</h2><p>分组在每个节点经受了以下几种不同类型的时延，节点处理时延，排队时延，传输时延和传播时延，加起来是节点总时延。</p>
<p>处理时延，检查分组首部和决定将分组导向何处所需要的时间是处理时延的一部分。处理之后，路由器将该分组引向通往路由器B链路之前的队列。</p>
<p>排队时延，在队列中，当分组在链路上等待传输的时候，经受排队时延。到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数。</p>
<p><strong><em>传输时延</em></strong>,传输时延L/R是将所有分组的比特推向链路所需要的时间</p>
<p>传播时延，从链路的起点到路由器B传播所需要的时间是传播时延</p>
<h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>到达路由器队列的分组发现一个满的队列，由于没有地方存储这个分组，路由器将丢弃该分组，丢包现象是一个分组已经传输到网络核心，绝不会从网络发送到目的地，分组丢失的份额随着流量强度增加而增加，因此，一个节点的性能也需要根据分组丢失的概率来度量。</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>除了时延和丢包，另外一个性能指标是端到端吞吐量，在任何时间瞬时吞吐量是主机B接受到该文件的速率。对于简单的两链路的网络，吞吐量是最小的链路速率，它是瓶颈链路的传输速率。吞吐量取决于数据流过的链路的传输速率，近似于沿着源和目的地之间路径的最小传输速率。</p>
<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>分层只要每个层次的接口不变，实现的功能不变，那么怎么实现它，改变服务的实现而不影响该系统其他组件是分层的优点。每层通过在该层中执行某些动作或使用直接下层的服务来提供服务。因特网的协议栈由5个层次组成，物理层，链路层，网络层，运输层和应用层。</p>
<p>应用层，HTTP，SMTP，FTP，DNS，位于应用层的信息分组称为报文</p>
<p>运输层，在应用程序端点之间传送应用层报文。TCP，面向连接的服务，确保传递和流量控制。UDP提供无连接服务，运输层分组称为报文段</p>
<p>网络层，负责将数据报的网络层分组从一台主机移动到另一台主机，IP协议，协议定义了数据报中的各个字段以及端系统和路由器如何作用于这些字段，也包括决定路由的路由选择协议，IP是将因特网链接在一起的</p>
<p>链路层，一个数据报可能被沿途不同链路上的不同链路层协议处理，网络层将受到来自每个不同的链路层协议的不同服务，链路层分组称为帧</p>
<p>物理层，将帧中的一个个比特从一个节点移动到下一个节点，这层的协议是链路相关的，进一步和链路的实际传输媒体相关。</p>
<p>OSI模型中多了两层，表示层和会话层，在应用层和运输层之间，表示层的作用是使得通信的应用程序能够解释交换数据的含义，会话层提供了数据交换定界功能，应用程序开发者决定一个服务是否重要，在应用程序中构建该功能。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>路由器和链路层交换机以多层次的方式组织他们的网络硬件和软件，链路层交换机实现了物理层和链路层，路由器实现了物理层，链路层和网络层，能够实现IP协议，链路层交换机不能识别IP地址，但是能够识别第二层地址，以太网地址。</p>
<p>应用层报文传到运输层，加上运输层首部信息形成运输层报文段，然后向网路层传递报文段，网路层增加源和目的端系统地址等网路层首部信息，产生了网路层数据报，然后传给链路层，链路层增加自己的链路层首部信息并且创建链路层帧。所以一个分组具有两种类型的字段，首部字段和有效载荷字段。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络中运行的端系统和网络应用，计算机网络的核心，传输数据的链路和交换机，链接端系统与网络核心的接入网和物理媒体。&lt;/p&gt;
&lt;h1 id=&quot;因特网&quot;&gt;&lt;a href=&quot;#因特网&quot; class=&quot;headerlink&quot; title=&quot;因特网&quot;&gt;&lt;/a&gt;因特网&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="计算机网络" scheme="http://microndgt.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://microndgt.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 元编程2</title>
    <link href="http://microndgt.github.io/2017/02/17/Python-%E5%85%83%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/17/Python-元编程2/</id>
    <published>2017-02-17T02:16:05.000Z</published>
    <updated>2017-02-17T03:28:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器为被包装函数增加参数"><a href="#装饰器为被包装函数增加参数" class="headerlink" title="装饰器为被包装函数增加参数"></a>装饰器为被包装函数增加参数</h1><p>在装饰器中给被包装函数增加额外的参数,可以使用关键字参数来给被包装函数增加额外参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from functools import wraps</div><div class="line">def optional_debug(func):</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=True, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def spam(a, b, c):</div><div class="line">    print(a, b, c)</div><div class="line">spam(1, 2, 3)</div><div class="line">spam(1, 2, 3, debug=True)</div></pre></td></tr></table></figure>
<p>可以避免一些重复代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">def a(x, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling a&apos;)</div><div class="line">def b(x, y, z, debug=False):</div><div class="line">    if debug:</div><div class="line">        print(&apos;Calling b&apos;)</div><div class="line">from functools import wraps</div><div class="line">import inspect</div><div class="line">def optional_debug(func):</div><div class="line">    if &apos;debug&apos; in inspect.getargspec(func).args:</div><div class="line">        raise TypeError(&apos;debug argument already defined&apos;)</div><div class="line">    @wraps(func)</div><div class="line">    def wrapper(*args, debug=False, **kwargs):</div><div class="line">        if debug:</div><div class="line">            print(&apos;Calling&apos;, func.__name__)</div><div class="line">        return func(*args, **kwargs)</div><div class="line">    return wrapper</div><div class="line">@optional_debug</div><div class="line">def a(x):</div><div class="line">    pass</div><div class="line">@optional_debug</div><div class="line">def b(x, y, z):</div><div class="line">    pass</div></pre></td></tr></table></figure>
<h1 id="使用装饰器扩充类的功能"><a href="#使用装饰器扩充类的功能" class="headerlink" title="使用装饰器扩充类的功能"></a>使用装饰器扩充类的功能</h1><p>通过反省或者重写类定义的某部分来修改它的行为，这种情况是类装饰器最好的使用场景了，下面是重写了特殊方法<code>__getattribute__</code>的类装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def log_getattribute(cls):</div><div class="line">    orig_getattribute = cls.__getattribute__</div><div class="line">    def new_getattribute(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return orig_getattribute(self, name)</div><div class="line">    cls.__getattribute__ = new_getattribute</div><div class="line">    return cls</div><div class="line">@log_getattribute</div><div class="line">class A:</div><div class="line">    def __init__(self, x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>类装饰器通常可以作为其他高级技术比如混入或元类的一种非常简洁的替代方案。</p>
<p>使用继承的方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class LoggedGetattribute:</div><div class="line">    def __getattribute__(self, name):</div><div class="line">        print(&apos;getting:&apos;, name)</div><div class="line">        return super().__getattribute__(name)</div><div class="line"># Example:</div><div class="line">class A(LoggedGetattribute):</div><div class="line">    def __init__(self,x):</div><div class="line">        self.x = x</div><div class="line">    def spam(self):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<h1 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h1><p>通过改变实例创建方式来实现单例，缓存等。自定义创建实例的方式，可以定义一个元类并自己实现<code>__call__()</code>方法。继承type的类叫做元类，元类是创建类的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class NoInstance(type):</div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        raise TypeError(&apos;can not instantiate directly&apos;)</div><div class="line">class Spam(metaclass=NoInstance):</div><div class="line">    @staticmethod</div><div class="line">    def grok(x):</div><div class="line">        print(&apos;Spam.grok&apos;)</div></pre></td></tr></table></figure>
<p>所以只能调用静态方法，不能创建它的实例。下面是实现单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Singleton(type):</div><div class="line">    def __init__(self, *args, **kwargs):</div><div class="line">        self.__instance = None</div><div class="line">        super().__init__(*args, **kwargs)</div><div class="line"></div><div class="line">    def __call__(self, *args, **kwargs):</div><div class="line">        if self.__instance is None:</div><div class="line">            self.__instance = super().__call__(*args, **kwargs)</div><div class="line">            return self.__instance</div><div class="line">        else:</div><div class="line">            return self.__instance</div><div class="line">class Spam(metaclass=Singleton):</div><div class="line">    def __init__(self):</div><div class="line">        print(&apos;Creating Spam&apos;)</div></pre></td></tr></table></figure>
<p>利用元类实现多种实例创建模式通常要比不使用元类的方式优雅得多。</p>
<h1 id="定义有可选参数的元类"><a href="#定义有可选参数的元类" class="headerlink" title="定义有可选参数的元类"></a>定义有可选参数的元类</h1><p>定义类的时候，使用<code>metaclass</code>参数来指定特定的元类：元类是用来控制类的创建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from abc import ABCMeta, abstractmethod</div><div class="line">class IStream(metaclass=ABCMeta):</div><div class="line">    @abstractmethod</div><div class="line">    def read(self, maxsize=None):</div><div class="line">        pass</div><div class="line">    @abstractmethod</div><div class="line">    def write(self, data):</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>在自定义元类中我们还可以提供其他的关键字参数,为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code> , <code>__new__()</code> 和 <code>__init__()</code> 方法中都使用强制关键字参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Spam(metaclass=MyMeta, debug=True, synchronize=True):</div><div class="line">    pass</div><div class="line">class MyMeta(type):</div><div class="line">    # Optional</div><div class="line">    @classmethod</div><div class="line">    def __prepare__(cls, name, bases, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__prepare__(name, bases)</div><div class="line">    # Required</div><div class="line">    def __new__(cls, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        return super().__new__(cls, name, bases, ns)</div><div class="line">    # Required</div><div class="line">    def __init__(self, name, bases, ns, *, debug=False, synchronize=False):</div><div class="line">        # Custom processing</div><div class="line">        pass</div><div class="line">        super().__init__(name, bases, ns)</div></pre></td></tr></table></figure>
<p><code>__prepare__()</code>方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code>方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code> 方法最后被调用，用来执行其他的一些初始化工作。通过使用强制关键字参数，在类的创建过程中我们必须通过关键字来指定这些参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;a href=&quot;#装饰器为被包装函数增加参数&quot; class=&quot;headerlink&quot; title=&quot;装饰器为被包装函数增加参数&quot;&gt;&lt;/a&gt;装饰器为被包装函数增加参数&lt;/h1&gt;&lt;p&gt;在装饰器中给被包装函数增加额外的参数,可以使用关键字
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
      <category term="Python_Cookbook" scheme="http://microndgt.github.io/tags/Python-Cookbook/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式</title>
    <link href="http://microndgt.github.io/2017/02/15/Python-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://microndgt.github.io/2017/02/15/Python-设计模式/</id>
    <published>2017-02-15T07:56:20.000Z</published>
    <updated>2017-02-15T08:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式-The-Factory-Pattern"><a href="#工厂模式-The-Factory-Pattern" class="headerlink" title="工厂模式 The Factory Pattern"></a>工厂模式 The Factory Pattern</h1><p>解决对象创建问题，处理对象创建，客户端可以申请一个对象而不用知道对象被哪个class创建。可以方便地解耦对象的使用和创建。有两种实现，工厂方法和抽象工厂.</p>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>执行单独的函数，通过传参提供需要的对象的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line">import xml.etree.ElementTree as etree</div><div class="line">class JSONConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.data = dict()</div><div class="line">        with open(filepath, mode=&apos;r&apos;, encoding=&apos;utf8&apos;) as f:</div><div class="line">            self.data = json.load(f)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.data</div><div class="line">class XMLConnector:</div><div class="line">    def __init__(self, filepath):</div><div class="line">        self.tree = etree.parse(filepath)</div><div class="line">    @property</div><div class="line">    def parsed_data(self):</div><div class="line">        return self.tree</div><div class="line">def connection_factory(filepath):</div><div class="line">    &quot;&quot;&quot; 工厂方法 &quot;&quot;&quot;</div><div class="line">    if filepath.endswith(&apos;json&apos;):</div><div class="line">        connector = JSONConnector</div><div class="line">    elif filepath.endswith(&apos;xml&apos;):</div><div class="line">        connector = XMLConnector</div><div class="line">    else:</div><div class="line">        raise ValueError(&apos;Cannot connect to &#123;&#125;&apos;.format(filepath))</div><div class="line">    return connector(filepath)</div></pre></td></tr></table></figure>
<h2 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h2><p>工厂方法适合对象种类较少的情况，如果有多种不同类型对象需要创建，使用抽象工厂模式。在一个抽象工厂类里实现多个关联对象的创建。也就是这些关联对象都实现了相同的方法，因此可以直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Frog:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        &quot;&quot;&quot; 不同类型玩家遇到的障碍不同 &quot;&quot;&quot;</div><div class="line">        print(&apos;&#123;&#125; the Frog encounters &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Bug:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;a bug&apos;</div><div class="line"></div><div class="line">    def action(self):</div><div class="line">        return &apos;eats it&apos;</div><div class="line">class FrogWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t----Frog World -----&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Frog(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Bug()</div><div class="line">class Wizard:</div><div class="line">    def __init__(self, name):</div><div class="line">        self.name = name</div><div class="line">    def __str__(self):</div><div class="line">        return self.name</div><div class="line">    def interact_with(self, obstacle):</div><div class="line">        print(&apos;&#123;&#125; the Wizard battles against &#123;&#125; and &#123;&#125;!&apos;.format(</div><div class="line">            self, obstacle, obstacle.action()))</div><div class="line">class Ork:</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;an evil ork&apos;</div><div class="line">    def action(self):</div><div class="line">        return &apos;kill it&apos;</div><div class="line">class WizardWorld:</div><div class="line">    def __init__(self, name):</div><div class="line">        print(self)</div><div class="line">        self.player_name = name</div><div class="line">    def __str__(self):</div><div class="line">        return &apos;\n\n\t------ Wizard World -------&apos;</div><div class="line">    def make_character(self):</div><div class="line">        return Wizard(self.player_name)</div><div class="line">    def make_obstacle(self):</div><div class="line">        return Ork()</div><div class="line">class GameEnvironment:</div><div class="line">    &quot;&quot;&quot; 抽象工厂，根据不同的玩家类型创建不同的角色和障碍 (游戏环境)</div><div class="line">    这里可以根据年龄判断，成年人返回『巫师』游戏，小孩返回『青蛙过河』游戏&quot;&quot;&quot;</div><div class="line">    def __init__(self, factory):</div><div class="line">        self.hero = factory.make_character()</div><div class="line">        self.obstacle = factory.make_obstacle()</div><div class="line">    def play(self):</div><div class="line">        self.hero.interact_with(self.obstacle)</div><div class="line">GameEnvironment(WizardWorld(&quot;kevin&quot;)).play()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式-The-Factory-Pattern&quot;&gt;&lt;a href=&quot;#工厂模式-The-Factory-Pattern&quot; class=&quot;headerlink&quot; title=&quot;工厂模式 The Factory Pattern&quot;&gt;&lt;/a&gt;工厂模式 The Facto
    
    </summary>
    
      <category term="设计模式" scheme="http://microndgt.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程2</title>
    <link href="http://microndgt.github.io/2017/02/14/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B2/"/>
    <id>http://microndgt.github.io/2017/02/14/Python并发编程2/</id>
    <published>2017-02-14T04:23:49.000Z</published>
    <updated>2017-02-15T04:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>并发编程第二部分,并没有深入研究</p>
<h1 id="给关键部分加锁"><a href="#给关键部分加锁" class="headerlink" title="给关键部分加锁"></a>给关键部分加锁</h1><p>一次仅允许一个进程使用的资源称为临界资源。临界区内放的一般是被1个以上的进程或线程（以下只说进程）共用的数据。临界区内的数据一次只能同时被一个进程使用，当一个进程使用临界区内的数据时，其他需要使用临界区数据的进程进入等待状态。</p>
<p>在多线程程序中安全使用可变对象，使用threading库中的Lock对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with self._value_lock:</div><div class="line">            self._value -= delta</div></pre></td></tr></table></figure>
<p>线程调度本质上是不稳定的。RLock可重入锁，可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下,当锁被持有时,只有一个线程可以使用完整 的函数或者类中的方法。一个被所 有实例共享的类级锁。这个锁用来同步类方法,具体来说就是,这个锁可以保证一次 只有一个线程可以调用这个类方法。不过,与一个标准的锁不同的是,已经持有这个 锁的方法在调用同样使用这个锁的方法时,无需再次获取锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">class SharedCounter:</div><div class="line">    _lock = threading.RLock()</div><div class="line">    def __init__(self, initial_value=0):</div><div class="line">        self._value = initial_value</div><div class="line">        self._value_lock = threading.Lock()</div><div class="line">    def incr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self._value += delta</div><div class="line">    def decr(self, delta=1):</div><div class="line">        with SharedCounter._lock:</div><div class="line">            self.incr(-delta)</div></pre></td></tr></table></figure>
<h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>死锁是由于线程同时获取多个锁造成的，一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。原来是这个意思，因为获得了第一个锁，所以该线程一直占用资源，但是阻塞又无法释放锁，所以造成死锁。阻塞的原因也可能是别的线程将这个锁占有，同时又需要上一个线程已经占用的锁。</p>
<p><strong><em>解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁</em></strong></p>
<p>使用上下文管理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">from contextlib import contextmanager</div><div class="line"># Thread-local state to stored information on locks already acquired，保存线程的状态信息</div><div class="line">_local = threading.local()</div><div class="line">@contextmanager</div><div class="line">def acquire(*locks):</div><div class="line">    # Sort locks by object identifier</div><div class="line">    locks = sorted(locks, key=lambda x: id(x))</div><div class="line">    # Make sure lock order of previously acquired locks is not violated</div><div class="line">    acquired = getattr(_local,&apos;acquired&apos;,[])</div><div class="line">    # 保证已经获得的锁最大值不大于新获得的锁的id值</div><div class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</div><div class="line">        raise RuntimeError(&apos;Lock Order Violation&apos;)</div><div class="line">    acquired.extend(locks)</div><div class="line">    _local.acquired = acquired</div><div class="line">    try:</div><div class="line">        for lock in locks:</div><div class="line">            lock.acquire()</div><div class="line">        yield</div><div class="line">    finally:</div><div class="line">        # Release locks in reverse order of acquisition</div><div class="line">        ＃ 由大到小释放锁</div><div class="line">        for lock in reversed(locks):</div><div class="line">            lock.release()</div><div class="line">        del acquired[-len(locks):]</div></pre></td></tr></table></figure>
<p>使用这个上下文管理器，不管用户以什么顺序来请求锁，这些锁都会按照固定的顺序被获取。因此不会发生死锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">x_lock = threading.Lock()</div><div class="line">y_lock = threading.Lock()</div><div class="line">def thread_1():</div><div class="line">    while True:</div><div class="line">        with acquire(x_lock, y_lock):</div><div class="line">            print(&apos;Thread-1&apos;)</div><div class="line">def thread_2():</div><div class="line">    while True:</div><div class="line">        with acquire(y_lock, x_lock):</div><div class="line">            print(&apos;Thread-2&apos;)</div><div class="line">t1 = threading.Thread(target=thread_1)</div><div class="line">t1.daemon = True</div><div class="line">t1.start()</div><div class="line">t2 = threading.Thread(target=thread_2)</div><div class="line">t2.daemon = True</div><div class="line">t2.start()</div></pre></td></tr></table></figure>
<p>尽可能保证每一个线程只能同时保持一个锁，这样就不会产生死锁。一个常用的死锁检测方案是看门狗计数器，线程正常运行的时候会每隔一段时间重置计数器，一旦发生死锁，无法重置计数器导致定时器超时，这样程序会重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>哲学家进餐问题死锁避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line"># The philosopher thread</div><div class="line">def philosopher(left, right):</div><div class="line">    while True:</div><div class="line">        with acquire(left,right):</div><div class="line">             print(threading.currentThread(), &apos;eating&apos;)</div><div class="line"># The chopsticks (represented by locks)</div><div class="line">NSTICKS = 5</div><div class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</div><div class="line"># Create all of the philosophers</div><div class="line">for n in range(NSTICKS):</div><div class="line">    t = threading.Thread(target=philosopher,</div><div class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</div><div class="line">    t.start()</div></pre></td></tr></table></figure>
<h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><p>使用<code>thread.local()</code>创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">from socket import socket, AF_INET, SOCK_STREAM</div><div class="line">import threading</div><div class="line">class LazyConnection:</div><div class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</div><div class="line">        self.address = address</div><div class="line">        self.family = AF_INET</div><div class="line">        self.type = SOCK_STREAM</div><div class="line">        self.local = threading.local()</div><div class="line">    def __enter__(self):</div><div class="line">        if hasattr(self.local, &apos;sock&apos;):</div><div class="line">            raise RuntimeError(&apos;Already connected&apos;)</div><div class="line">        self.local.sock = socket(self.family, self.type)</div><div class="line">        self.local.sock.connect(self.address)</div><div class="line">        return self.local.sock</div><div class="line">    def __exit__(self, exc_ty, exc_val, tb):</div><div class="line">        self.local.sock.close()</div><div class="line">        del self.local.sock        </div><div class="line">from functools import partial</div><div class="line">def test(conn):</div><div class="line">    with conn as s:</div><div class="line">        s.send(b&apos;GET /index.html HTTP/1.0\r\n&apos;)</div><div class="line">        s.send(b&apos;Host: www.python.org\r\n&apos;)</div><div class="line"></div><div class="line">        s.send(b&apos;\r\n&apos;)</div><div class="line">        resp = b&apos;&apos;.join(iter(partial(s.recv, 8192), b&apos;&apos;))</div><div class="line"></div><div class="line">    print(&apos;Got &#123;&#125; bytes&apos;.format(len(resp)))</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    conn = LazyConnection((&apos;www.python.org&apos;, 80))</div><div class="line"></div><div class="line">    t1 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t2 = threading.Thread(target=test, args=(conn,))</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div></pre></td></tr></table></figure>
<p>每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
<p>比如一个套接字或文件。你不能让所有线程贡献一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。所以之前传递什么文件的时候，会出现问题。</p>
<h1 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h1><p>你应该避免编写线程数量可以无限制增长的程序。</p>
<p>服务器端程序也应该这样做，至少要限制进程创建的数目，最大应该是8，然后使用Condition对象或者event，等到一个进程结束运行后，然后再将阻塞的创建进程的函数解除阻塞。</p>
<p>不过进程与线程区别是，线程可以无限制创造，但是进程与硬件，处理器核心数有关。</p>
<h1 id="Python的全局锁问题"><a href="#Python的全局锁问题" class="headerlink" title="Python的全局锁问题"></a>Python的全局锁问题</h1><p>Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。怪不得需要全局解释器锁保护，确保任何时候都只有一个Python线程执行。 程序大部分只会设计到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。</p>
<p>依赖CPU的程序，优化底层算法要比使用多线程运行快得多。由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，并且函数参数和返回值必须要兼容pickle。</p>
<h1 id="定义一个Actor任务"><a href="#定义一个Actor任务" class="headerlink" title="定义一个Actor任务"></a>定义一个Actor任务</h1><p>actor最简单的并行和分布式计算解决方案，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。</p>
<p>结合使用一个线程和一个队列可以很容易的定义actor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line"></div><div class="line"># Sentinel used for shutdown</div><div class="line">class ActorExit(Exception):</div><div class="line">    pass</div><div class="line"></div><div class="line">class Actor:</div><div class="line">    def __init__(self):</div><div class="line">        self._mailbox = Queue()</div><div class="line">    def send(self, msg):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Send a message to the actor</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._mailbox.put(msg)</div><div class="line">    def recv(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Receive an incoming message</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        msg = self._mailbox.get()</div><div class="line">        if msg is ActorExit:</div><div class="line">            raise ActorExit()</div><div class="line">        return msg</div><div class="line">    def close(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Close the actor, thus shutting it down</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self.send(ActorExit)</div><div class="line">    def start(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Start concurrent execution</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._terminated = Event()</div><div class="line">        t = Thread(target=self._bootstrap)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def _bootstrap(self):</div><div class="line">        try:</div><div class="line">            self.run()</div><div class="line">        except ActorExit:</div><div class="line">            pass</div><div class="line">        finally:</div><div class="line">            self._terminated.set()</div><div class="line">    def join(self):</div><div class="line">        self._terminated.wait()</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run method to be implemented by the user</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line"># Sample ActorTask</div><div class="line">class PrintActor(Actor):</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            msg = self.recv()</div><div class="line">            print(&apos;Got:&apos;, msg)</div><div class="line"># Sample use</div><div class="line">p = PrintActor()</div><div class="line"># 开启了一个线程，轮询</div><div class="line">p.start()</div><div class="line">p.send(&apos;Hello&apos;)</div><div class="line">p.send(&apos;World&apos;)</div><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure>
<h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>使用生成器（协程）替代系统线程来实现并发。这个有时又被称为用户级线程或绿色线程。yield 语句会让一个生成器挂起它的执行，这样就可以编写一个调度器， 将生成器当做某种“任务”并使用任务协作切换来替换它们的执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># Two simple generator functions</div><div class="line">def countdown(n):</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;T-minus&apos;, n)</div><div class="line">        yield</div><div class="line">        n -= 1</div><div class="line">    print(&apos;Blastoff!&apos;)</div><div class="line">def countup(n):</div><div class="line">    x = 0</div><div class="line">    while x &lt; n:</div><div class="line">        print(&apos;Counting up&apos;, x)</div><div class="line">        yield</div><div class="line">        x += 1</div></pre></td></tr></table></figure>
<p>下面是一个简单任务调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line">class TaskScheduler:</div><div class="line">    def __init__(self):</div><div class="line">        self._task_queue = deque()</div><div class="line">    def new_task(self, task):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Admit a newly started task to the scheduler</div><div class="line"></div><div class="line">        &apos;&apos;&apos;</div><div class="line">        self._task_queue.append(task)</div><div class="line">    def run(self):</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        Run until there are no more tasks</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        while self._task_queue:</div><div class="line">            task = self._task_queue.popleft()</div><div class="line">            try:</div><div class="line">                # Run until the next yield statement</div><div class="line">                next(task)</div><div class="line">                self._task_queue.append(task)</div><div class="line">            except StopIteration:</div><div class="line">                # Generator is no longer executing</div><div class="line">                pass</div><div class="line"># Example use</div><div class="line">sched = TaskScheduler()</div><div class="line">sched.new_task(countdown(10))</div><div class="line">sched.new_task(countdown(5))</div><div class="line">sched.new_task(countup(15))</div><div class="line">sched.run()</div></pre></td></tr></table></figure>
<p> 生成器函数就是认为，而yield语句是任务挂起的信号。调度器循环检查任务列表直到没有任务要执行为止。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发编程第二部分,并没有深入研究&lt;/p&gt;
&lt;h1 id=&quot;给关键部分加锁&quot;&gt;&lt;a href=&quot;#给关键部分加锁&quot; class=&quot;headerlink&quot; title=&quot;给关键部分加锁&quot;&gt;&lt;/a&gt;给关键部分加锁&lt;/h1&gt;&lt;p&gt;一次仅允许一个进程使用的资源称为临界资源。临界区内放
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python并发编程</title>
    <link href="http://microndgt.github.io/2017/02/13/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://microndgt.github.io/2017/02/13/Python并发编程/</id>
    <published>2017-02-13T04:49:52.000Z</published>
    <updated>2017-02-14T04:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程，调用子进程，生成器函数，并行计算</p>
<h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p>threading库可以在单独的线程中执行任何的在Python中可以调用的对象，可以创建一个Thread对象并且将要执行的对象以target参数的形式提供给该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">t = Thread(target=countdown, args=(10, ))</div><div class="line">t.start()</div></pre></td></tr></table></figure>
<p>线程会在一个单独的系统级线程中执行，这些线程由操作系统全权管理，一旦启动，独立执行到目标函数返回。查询线程状态<code>t.is_alive()</code>，将一个线程加入到当前线程，等待它终止<code>t.join()</code></p>
<p>Python解释器在所有线程都终止后才继续执行代码，所以长时间运行的线程或者需要一直运行的后台任务，使用后台线程。<code>t = Thread(target=countdown, args=(10, ), daemon=True)</code></p>
<p>后台线程无法等待，但是这些线程会在主线程终止时候自动销毁，但是无法结束线程，必须自己写一个调度类来实现这些功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class CountdownTask:</div><div class="line">    def __init__(self):</div><div class="line">        self.running = True</div><div class="line">    def terminate(self):</div><div class="line">        self.running = False</div><div class="line">    def run(self, n):</div><div class="line">        while self.running and n &gt; 0:</div><div class="line">            print(&quot;T-minus&quot;, n)</div><div class="line">            n -= 1</div><div class="line">            time.sleep(5)</div><div class="line">c = CountdownTask()</div><div class="line">t = Thread(target=c.run, args=(10,))</div><div class="line">t.start()</div><div class="line">c.terminate()</div><div class="line">t.join()</div></pre></td></tr></table></figure>
<p>如果线程执行I/O阻塞操作，name就应该使用超时循环来操作线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class IOTask:</div><div class="line">    def terminate(self):</div><div class="line">        self._running = False</div><div class="line">    def run(self, sock):</div><div class="line">        sock.settimeout(5)</div><div class="line">        while self._running:</div><div class="line">            try:</div><div class="line">                data = sock.recv(8192)</div><div class="line">                break</div><div class="line">            except socket.timeout:</div><div class="line">                continue</div><div class="line">        return</div></pre></td></tr></table></figure>
<p>Python线程被限制到同一时刻只允许一个线程执行，所以Python线程更适用于I/O和其他需要并发执行的阻塞操作，而不是需要多处理器并行的计算密集型任务。</p>
<p>以下的实现的线程也可以工作，但是依赖于threading库，所以只能在线程上下文中使用，但是上面的与threading库无关，所以可以被用在其他上下文中，比如在multiprocessing单独进程中执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line">class CountdownTask(Thread):</div><div class="line">    def __init__(self, n):</div><div class="line">        super().__init__()</div><div class="line">        self.n = 0</div><div class="line">    def run(self):</div><div class="line">        while self.n &gt; 0:</div><div class="line">            self.n -= 1</div><div class="line">            time.sleep(5)</div></pre></td></tr></table></figure>
<h1 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h1><p>程序其他线程判断某个线程的状态来确定下一步，使用threading的Event来设置一个信号标志来协调线程的启动。初始状态为假。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">from threading import Thread, Event</div><div class="line">import time</div><div class="line">def countdown(n, started_evt):</div><div class="line">    print(&quot;starting&quot;)</div><div class="line">    # 在此设置event对象为真</div><div class="line">    started_evt.set()</div><div class="line">    while n &gt; 0:</div><div class="line">        print(&apos;t-minus&apos;)</div><div class="line">        n -= 1</div><div class="line">        time.sleep(2)</div><div class="line">started_evt = Event()</div><div class="line">print(&apos;launching countdown&apos;)</div><div class="line">t = Thread(target=countdown, args=(10, started_evt))</div><div class="line">t.start()</div><div class="line"># 为真后执行继续执行主线程</div><div class="line">started_evt.wait()</div><div class="line">print(&apos;running&apos;)</div></pre></td></tr></table></figure>
<p>event对象最好单次使用，一旦对象设置为真，就应该丢弃它。如果需要多次使用，则使用Condition对象代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line">class PeriodcTimer:</div><div class="line">    def __init__(self, interval):</div><div class="line">        self._interval = interval</div><div class="line">        self._flag = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def start(self):</div><div class="line">        t = threading.Thread(target=self.run)</div><div class="line">        t.daemon = True</div><div class="line">        t.start()</div><div class="line">    def run(self):</div><div class="line">        while True:</div><div class="line">            time.sleep(self._interval)</div><div class="line">            with self._cv:</div><div class="line">                self._flag ^= 1</div><div class="line">                self._cv.notify_all()</div><div class="line">    def wait_for_tick(self):</div><div class="line">        with self._cv:</div><div class="line">            last_flag = self._flag</div><div class="line">            while last_flag == self._flag:</div><div class="line">                # 当每次有notify_all时候结束循环,开始计数</div><div class="line">                self._cv.wait()</div><div class="line">ptiemr = PeriodcTimer(5)</div><div class="line">ptiemr.start()</div><div class="line">def countdown(nticks):</div><div class="line">    while nticks &gt; 0:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;T-minus&quot;, nticks)</div><div class="line">        nticks -= 1</div><div class="line">def countup(last):</div><div class="line">    n = 0</div><div class="line">    while n &lt; last:</div><div class="line">        ptiemr.wait_for_tick()</div><div class="line">        print(&quot;counting&quot;, n)</div><div class="line">        n += 1</div><div class="line">threading.Thread(target=countdown, args=(10, )).start()</div><div class="line">threading.Thread(target=countup, args=(5, )).start()</div></pre></td></tr></table></figure>
<p>event当它设置为真的时候会唤醒所有等待它的线程，如果只想唤醒单个线程，最好使用信号量或者Condition对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def worker(n, sema):</div><div class="line">    sema.acquire()</div><div class="line">    print(&quot;working &quot;, n)</div><div class="line">sema = threading.Semaphore(0)</div><div class="line">nworkers = 10</div><div class="line">for n in range(nworkers):</div><div class="line">    # 会启动一个线程池，但是所有线程都在等待获取信号量</div><div class="line">    t = threading.Thread(target=worker, args=(n, sema, ))</div><div class="line">    t.start()</div><div class="line"># 每次释放信号量的时候，只有一个线程会唤醒并且执行</div><div class="line">sema.release()</div></pre></td></tr></table></figure>
<p>使用队列来进行线程间通信或者把每个线程当成一个Actor，使用Actor模型控制并发。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式是使用queue库中的队列。创建一个被多个线程共享的Queue对象，这些线程通过使用put()和get()方法来向队列中添加或者删除元素。Queue中含有了必要的锁，可以在多个线程中安全地共享数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line"># 哨兵</div><div class="line">_sentinel = object()</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">    out_q.put(_sentinel)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        if data is _sentinel:</div><div class="line">            # 再放回去，这样所有监听这个队列的消费者线程就可以都关闭了。</div><div class="line">            in_q.put(_sentinel)</div><div class="line">            break</div></pre></td></tr></table></figure>
<p>使用Condition变量来包装数据结构，创建一个线程安全的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import heapq</div><div class="line">import threading</div><div class="line">class PriorityQueue:</div><div class="line">    def __init__(self):</div><div class="line">        self._queue = []</div><div class="line">        self._count = 0</div><div class="line">        self._cv = threading.Condition()</div><div class="line">    def put(self, item, priority):</div><div class="line">        with self._cv:</div><div class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</div><div class="line">            self._count += 1</div><div class="line">            self._cv.notify()</div><div class="line">    def get(self):</div><div class="line">        with self._cv:</div><div class="line">            while len(self._queue) == 0:</div><div class="line">                # 在这里阻塞,而不是循环，直到添加元素后解除阻塞</div><div class="line">                self._cv.wait()</div><div class="line">            # 获取优先级最低的</div><div class="line">            return heapq.heappop(self._queue)[-1]</div></pre></td></tr></table></figure>
<p>使用task_done()和join()来表示已经完成,q.task_done()，每次从queue中get一个数据之后，当处理好相关问题，最后调用该方法，以提示q.join()是否停止阻塞，让线程向前执行或者退出；q.join()，阻塞，直到queue中的数据均被删除或者处理。为队列中的每一项都调用一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        out_q.put(data)</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data = in_q.get()</div><div class="line">        in_q.task_done()</div><div class="line">q = Queue()</div><div class="line">t2 = Thread(target=producer, args=(q, ))</div><div class="line">t1 = Thread(target=consumer, args=(q, ))</div><div class="line">t2.start()</div><div class="line">t1.start()</div><div class="line">q.join() #所有生产的都被消费</div></pre></td></tr></table></figure>
<p>使用event当消费者线程处理完数据后生产者立即得到通知，来监测处理过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from queue import Queue</div><div class="line">from threading import Thread, Event</div><div class="line">def producer(out_q):</div><div class="line">    while running:</div><div class="line">        evt = Event()</div><div class="line">        out_q.put((data, event))</div><div class="line">        evt.wait()</div><div class="line">def cousumer(in_q):</div><div class="line">    while True:</div><div class="line">        data, evt = in_q.get()</div><div class="line">        evt.set()</div></pre></td></tr></table></figure>
<p>使用线程队列需要注意向队列中添加数据项并不会复制此数据项，实际上是在线程中传递对象引用。可以使用不变结构或者深拷贝。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程，调用子进程，生成器函数，并行计算&lt;/p&gt;
&lt;h1 id=&quot;启动和停止线程&quot;&gt;&lt;a href=&quot;#启动和停止线程&quot; class=&quot;headerlink&quot; title=&quot;启动和停止线程&quot;&gt;&lt;/a&gt;启动和停止线程&lt;/h1&gt;&lt;p&gt;threading库可以在单独的线程中执行任
    
    </summary>
    
      <category term="Python" scheme="http://microndgt.github.io/categories/Python/"/>
    
    
      <category term="编程" scheme="http://microndgt.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://microndgt.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
